{"title": "PDF", "author": "PDF", "url": "https://www.uoc.edu/pdf/masters/oficiales/img/913.pdf", "hostname": "PDF", "description": "PDF", "sitename": "PDF", "date": "PDF", "id": "PDF", "license": "PDF", "body": "PDF", "comments": "PDF", "commentsbody": "PDF", "raw_text": "PDF", "text": "Rafael Camps Par\u00e9 \nSoftware libre\nU\nFormaci\u00f3n de PosgradoBases de datos\n71Z799014MOOscar P\u00e9rez MoraCarme Mart\u00edn EscofetMarc Gibert Ginest\u00e0Dolors Costal CostaLuis Alberto Casillas Santill\u00e1n\uf8e9 FUOC \u2022 71Z799014MO 2 Bases de datos\nDavid Meg\u00edas Jim\u00e9nez Jordi Mas Hern\u00e1ndez Rafael Camps Par\u00e9\nCoordinador Coordinador Autor\nIngeniero de Inform\u00e1tica por la UAB.\nMag\u00edster en T\u00e9cnicas Avanzadas de \nAutomatizaci\u00f3n de Procesos por la UAB.\nDoctor en Inform\u00e1tica por la UAB.\nProfesor de los Estudios de Inform\u00e1tica \ny Multimedia de la UOC.Coordinador general de Softcatal\u00e0 y \ndesarrollador del procesador de textos libre Abiword.\nMiembro fundador de Softcatal\u00e0 \ny de la red telem\u00e1tica RedBBS.\nEn calidad de consultor, ha trabajado\nen empresas como Menta, Tel\u00e9polis, Vodafone, Lotus, eresMas, Amena y Terra Espa\u00f1a.Profesional inform\u00e1tico en varias empresas. \nHa sido profesor universitario en la Facultad de Inform\u00e1tica de Barcelona de la Universidad Polit\u00e9cnica de Catalu\u00f1a. Actualmente est\u00e1 adscrito a la Escuela Universitaria Polit\u00e9cnica de Vilanovai la Geltr\u00fa. \nLuis Alberto Casillas Santill\u00e1n Dolors Costal Costa Marc Gibert Ginest\u00e0\nAutor Autora Autor\nLicenciado en Inform\u00e1tica (1995), maestro en Sistemas (1998), doctorante en Ingenier\u00eda y Tecnolog\u00eda (2003), est\u00e1 estudiando el doctorado en la UOC. Profesor universitario desde marzo de 1995. Investigador en Inteligencia Artificial desde 1998. Consultor Universitario para cuestiones educativas.Doctora en Inform\u00e1tica por la Universidad \nPolit\u00e9cnica de Catalu\u00f1a. Profesora titular del Departamento de Lenguajes y Sistemas Inform\u00e1ticos de la Universidad Polit\u00e9cnica de Catalu\u00f1a, asignada a la Facultad de Inform\u00e1tica de Barcelona.Ingeniero en Inform\u00e1tica por la Universidad \nRamon Llull. Socio fundador y jefe de proyectos de Cometa Technologies, empresa dedicada a dar soluciones en tecnolog\u00edas de la informaci\u00f3n, basadas en el uso de est\u00e1ndares y herramientas de c\u00f3digo abierto. Profesor del M\u00e1ster en Seguridad en Tecnolog\u00edas de la Informaci\u00f3n en Enginyeria y Arquitectura La Salle y consultor del Master Internacional en Software Libre de la UOC. \nCarme Mart\u00edn Escofet Oscar P\u00e9rez Mora\nAutora Autor\nLicenciada en Inform\u00e1tica por la Universidad Polit\u00e9cnica de Catalu\u00f1a. Profesora de la asignatura Introducci\u00f3n a las bases de datos en la Facultad de Inform\u00e1tica de Barcelona, y de la asignatura Sistemas orientados a bases de datos en la Facultad de Matem\u00e1ticas y Estad\u00edstica. Tambi\u00e9n ha sido profesora de las asignaturas Dise\u00f1o de sistemas y Gesti\u00f3n de sistemas inform\u00e1ticos en la Escuela Universitaria Polit\u00e9cnica de Vilanova i la Geltr\u00fa.Ingeniero en Comunicaciones y \nElectr\u00f3nica por la Universidad de Guadalajara (M\u00e9xico) y Maestro en Sistemas de Informaci\u00f3n.  Ha participado en diversas publicaciones e impartido cursos especializados. Miembro Fundador del Marichi del SUTUdeG y del Grupo Linux de Occidente A. C. (www.glo.org.mx). Organizador del Festival GNU/Linux y Software Libre (http://www.festivaldesoftwarelibre.org).\nPrimera edici\u00f3n: mayo 2005\n\u00a9 Fundaci\u00f3 per a la Universitat Oberta de Catalunya\nAv. Tibidabo, 39-43, 08035 BarcelonaMaterial realizado por Eureca Media, SL\n\u00a9 Autores: Rafael Camps Par\u00e9, Luis Alberto Casillas Santill\u00e1n, Dolors Costal Costa, Marc Gibert Ginest\u00e0,\nCarme Mart\u00edn Escofet, Oscar P\u00e9rez MoraDep\u00f3sito legal: B-15.562-2005\nISBN: 84-9788-269-5\nSe garantiza permiso para copiar, distribuir y mo dificar este documento seg\u00fan los t\u00e9rminos de la GNU  Free Documentation License ,\nVersion 1.2 o cualquiera posterior publicada por la Free Software Foundation , sin secciones invariantes ni textos de cubierta delantera\no trasera. Se dispone de una copia de la licencia en el apartado \u201cGNU Free Documentation License\u201d de este documento.\uf8e9 FUOC \u2022 71Z799014MO 3 Bases de datos\nAgradecimientos\nLos autores agradecen a la Fundaci\u00f3n para la Universitat Oberta de Catalunya\n(http://www.uoc.edu) la financiaci\u00f3n de la primera edici\u00f3n de esta obra, en-\nmarcada en el M\u00e1ster Internacional en Software Libre ofrecido por la citada\ninstituci\u00f3n.\nEl autor \u00d3scar P\u00e9rez Mora desea hacer co nstar el agradecimiento siguiente: \u201cA\nJos\u00e9 P\u00e9rez Arias, gracias po r haber sido mi padre\u201d, en  memoria de su padre fa-\nllecido durante la realiz aci\u00f3n de este material.\uf8e9 FUOC \u2022 71Z799014MO 5 Bases de datos\nIntroducci\u00f3n\nLas bases de datos son el m\u00e9todo prefer ido para el almace namiento estructu-\nrado de datos. Desde las grandes aplicac iones multiusuario, hasta los tel\u00e9fonos\nm\u00f3viles y las agendas electr\u00f3nicas utilizan tecnolog\u00eda de bases de datos para ase-\ngurar la integridad de los datos y facilitar  la labor tanto de usuarios como de los\nprogramadores que las desarrollaron.\nDesde la realizaci\u00f3n del primer modelo de datos, pasando por la administra-\nci\u00f3n del sistema gestor, hasta llegar al de sarrollo de la aplicaci\u00f3n, los conceptos\ny la tecnolog\u00eda asociados son muchos y muy heterog\u00e9neos. Sin embargo, es im-\nprescindible conocer los aspectos clave de cada uno de estos temas para tener\n\u00e9xito en cualquier proyec to que implique trabajar con bases de datos.\nEn este curso trataremos de dar una visi\u00f3n completa de los conceptos relacio-\nnados con los sistemas gestores de bases de datos. En los primeros cap\u00edtulos ve-\nremos los aspectos involucrados en los motores de estos almacenes de datos, su\nevoluci\u00f3n hist\u00f3rica y los di stintos tipos de organizaci \u00f3n y abs-tracci\u00f3n que han\nido surgiendo desde su  conceptualizaci\u00f3n hasta nuestros d\u00edas. \nA continuaci\u00f3n profundizaremos en el modelo llamado relacional (el m\u00e1s usa-\ndo en nuestros d\u00edas), proporcionando los m\u00e9todos y herramientas que nos per-\nmitan representar necesidades de almacenamiento y consulta de datos en este\nmodelo. En el siguiente cap\u00edtulo estudiar emos a fondo el lenguaje de consultas\nestructurado SQL, imprescindible para tr abajar con bases de datos relacionales,\nya sea directamente o a trav\u00e9s de cualquier lenguaje de programaci\u00f3n.\nEl dise\u00f1o de bases de datos tiene tamb i\u00e9n un cap\u00edtulo dedicado a aprender a\nmodelar y representar gr\u00e1ficamente una ba se de datos, a detectar los posibles\nproblemas de dise\u00f1o antes de que \u00e9stos af ecten a la aplicaci\u00f3n, y a construir ba-\nses de datos \u00f3ptimas para los distintos casos de relaciones entre entidades que\nformar\u00e1n nuestra base de datos.\nUna vez sentadas estas bases, estaremos en disposici\u00f3n de examinar detenida-\nmente dos de los sistemas gestores de bases de datos de software libre m\u00e1s usa-dos y populares actualmente. As\u00ed pues, ap renderemos el uso, administraci\u00f3n y\nparticularidades de MySQL y PostgreSQL mediante ej emplos y casos pr\u00e1cticos.\nTambi\u00e9n veremos las herramientas de co nsulta y administra ci\u00f3n gr\u00e1ficas para\nestos dos sistemas gestores de bases de datos, que nos permitir\u00e1n mejorar nues-\ntra productividad en el trabajo diario con ellos.\nA continuaci\u00f3n, veremos los m\u00e9todos de acceso a estos sistemas gestores de bases\nde datos desde algunos lenguajes de programaci\u00f3n. En cada caso, comentaremos\uf8e9 FUOC \u2022 71Z799014MO 6 Bases de datos\nlas mejores pr\u00e1cticas para cada uno, as\u00ed como sus particularidades, e introducire-\nmos algunos conceptos relacionados con la  programaci\u00f3n en bases de datos como\nla persistencia, tratamiento de errores, etc.\nFinalmente, creemos que la mejor forma de finalizar este curso es mediante un\ncaso de estudio completo que aborde lo s temas tratados en todos los cap\u00edtulos,\nen el orden en que se producir\u00edan en la  realidad de un proyecto y primando la\npr\u00e1ctica sobre la teor\u00eda.\nAs\u00ed pues, este curso trata de proporcionar  al estudiante una visi\u00f3n completa de\nlos aspectos implicados en el trabajo co n bases de datos. Aunque no profundi-\nzaremos en algunos temas muy especializados como el dise\u00f1o interno de un sis-\ntema gestor de bases de datos, profun dizaremos t\u00e9cnicamente en los temas m\u00e1s\nnecesarios.\uf8e9 FUOC \u2022 71Z799014MO 7 Bases de datos\nObjetivos\nLos objetivos que el estudiante deber\u00e1 alcanzar al finalizar el curso Bases de datos\nson los siguientes:\n\u2022 Comprender los diferentes modelos de bases de datos, y en concreto do-\nminar el modelo relacional.\n\u2022 Ser capaz de realizar el modelo de un a base de datos relacional, a partir de\nla especificaci\u00f3n de requ erimientos de un proyecto, comprendiendo y apli-\ncando los conceptos y tran sformaciones implicados.\n\u2022 Conocer el uso y administraci\u00f3n de do s de los gestores de bases de datos\nrelacionales m\u00e1s populares en el \u00e1mbi to del software libre: PostgreSQL y\nMySQL.\n\u2022 Tener experiencia en el desarrollo de  aplicaciones en conexi\u00f3n con bases\nde datos en varios lenguajes.\uf8e9 FUOC \u2022 71Z799014MO 8 Bases de datos\nContenidos\nM\u00f3dulo did\u00e1ctico 1\nIntroducci\u00f3n a las bases de datosRafael Camps Par\u00e91. Concepto y origen de las BD y de los SGBD2. Evoluci\u00f3n de los SGBD3. Objetivos y funcio nalidad de los SGBD\n4. Arquitectura de los SGBD\n5. Modelos de BD6. Lenguajes y usuarios7. Administraci\u00f3n de BD\nM\u00f3dulo did\u00e1ctico 2\nEl modelo relacional y el \u00e1lgebra relacionalDolors Costal Costa\n1. Introducci\u00f3n al modelo relacional\n2. Estructura de los datos3. Operaciones del modelo relacional4. Reglas de integridad5. El \u00e1lgebra relacional\nM\u00f3dulo did\u00e1ctico 3\nEl lenguaje SQL\nCarme Mart\u00edn Escofet1. Sentencias de definici\u00f3n2. Sentencias de manipulaci\u00f3n3. Sentencias de control4. Sublenguajes especializados\nM\u00f3dulo did\u00e1ctico 4\nIntroducci\u00f3n al dise\u00f1o de bases de datos\nDolors Costal Costa1. Introducci\u00f3n al dise\u00f1o de bases de datos2. Dise\u00f1o conceptual: el modelo ER3. Dise\u00f1o l\u00f3gico: la transformaci\u00f3n de l modelo ER en el modelo relacional\nM\u00f3dulo did\u00e1ctico 5\nBases de datos en MySQLLuis Alberto Casillas Sa ntill\u00e1n; Marc Gibert Gi nest\u00e0; Oscar P\u00e9rez Mora\n1. Caracter\u00edsticas de MySQL\n2. Acceso a un servidor MySQL 3. Creaci\u00f3n y manipulaci\u00f3n de tablas \uf8e9 FUOC \u2022 71Z799014MO 9 Bases de datos\n4. Consultas \n5. Administraci\u00f3n de MySQL 6. Clientes gr\u00e1ficos\nM\u00f3dulo did\u00e1ctico 6\nBases de datos en PostgreSQL\nMarc Gibert Ginest\u00e0; Oscar P\u00e9rez Mora1. Caracter\u00edsticas de PostgreSQL 2. Introducci\u00f3n a la orientaci\u00f3n a objetos 3. Acceso a un servidor PostgreSQL 4. Creaci\u00f3n y manipulaci\u00f3n de tablas \n5. Manipulaci\u00f3n de datos \n6. Funciones y disparadores 7. Administraci\u00f3n de PostgreSQL 8. Cliente gr\u00e1fico: pgAdmin3\nM\u00f3dulo did\u00e1ctico 7\nDesarrollo de aplicaciones en conexi\u00f3n con bases de datos\nMarc Gibert Ginest\u00e0\n1. Conexi\u00f3n y uso de bases de datos en lenguaje PHP 2. Conexi\u00f3n y uso de bases de datos en lenguaje Java\nM\u00f3dulo did\u00e1ctico 8\nCaso de estudio\nMarc Gibert Ginest\u00e0\n1. Presentaci\u00f3n del caso de estudio 2. El modelo relacional y el \u00e1lgebra relacional 3. El lenguaje SQL 4. Introducci\u00f3n al dise\u00f1o de bases de datos 5. Bases de datos en MySQL \n6. Bases de datos en PostgreSQL \n7. Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nAp\u00e9ndice\nGNU Free Documentation LicenseIntroducci\u00f3n  \na las bases  \nde datos\nRafael Camps Par\u00e9\uf8e9 FUOC \u2022 71Z799014MO Introducci\u00f3n a las bases de datos\n\u00cdndice\nIntroducci\u00f3n ............................................................................................... 5\nObjetivos ...................................................................................................... 5\n1. Concepto y origen de las BD y de los SGBD ................................... 7\n2. Evoluci\u00f3n de los SGBD ........................................................................ 9\n2.1. Los a\u00f1os sesenta y setenta: sistemas centralizados ........................... 9\n2.2. Los a\u00f1os ochenta: SGBD relacionales................................................ 9\n2.3. Los a\u00f1os noventa: distribuci\u00f3n, C/S y 4GL....................................... 10\n2.4. Tendencias actuales ........................................................................... 13\n3. Objetivos y servicios de los SGBD ..................................................... 15\n3.1. Consultas no predefinidas y complejas............................................. 15\n3.2. Flexibilidad e independen cia............ ............. .......... .......... .......... ...... 15\n3.3. Problemas de la redundancia ............................................................ 16\n3.4. Integridad de los datos ...................................................................... 18\n3.5. Concurrencia de usuarios .................................................................. 18\n3.6. Seguridad ........................................................................................... 21\n3.7. Otros objetivos................................................................................... 21\n4. Arquitectura de los SGBD .................................................................. 22\n4.1. Esquemas y niveles ............................................................................ 22\n4.2. Independencia de los datos ............................................................... 25\n4.3. Flujo de datos y de control................................................................ 27\n5. Modelos de BD ....................................................................................... 29\n6. Lenguajes y usuarios ............................................................................ 32\n7. Administraci\u00f3n de BD ........................................................................ 35\nResumen ....................................................................................................... 36\nActividades .................................................................................................. 37\nEjercicios de autoevaluaci\u00f3n .................................................................. 37\nSolucionario ................................................................................................ 38\nGlosario ........................................................................................................ 38\nBibliograf\u00eda ................................................................................................. 39\uf8e9 FUOC \u2022 71Z799014MO 5 Introducci\u00f3n a las bases de datos\nIntroducci\u00f3n a las bases de datos\nIntroducci\u00f3n\nEmpezaremos esta unidad did\u00e1ctica viendo cu\u00e1les son los objetivos de los \nsistemas de gesti\u00f3n de las bases de datos (SGBD)  y, a continuaci\u00f3n, daremos \nuna visi\u00f3n general de la arquitectura , el funcionamiento  y el entorno  de estos \nsistemas.\nObjetivos\nEn los materiales did\u00e1cticos de esta unid ad encontrar\u00e9is las herramientas para ad -\nquirir una visi\u00f3n global del mundo de las BD y de los SGBD, as\u00ed como para \nalcanzar los siguientes objetivos:\n1.Conocer a grandes rasgos la evoluci\u00f3n de los SGBD desde los a\u00f1os sesenta \nhasta la actualidad.\n2.Distinguir los principales objetivos de  los SGBD actuales y contrastarlos \ncon los sistemas de fi cheros tradicionales.\n3.Saber explicar mediante ejemplos lo s problemas que intenta resolver el \nconcepto de transacci\u00f3n .\n4.Relacionar la idea de flexibilidad en  los cambios con la independencia l\u00f3 -\ngica y f\u00edsica de los datos, as\u00ed como con la arquitectura de tres niveles.\n5.Distinguir los principales modelos de BD.\n6.Conocer a grandes rasgos el funcionamiento de un SGBD.\n7.Saber relacionar los diferentes tipos de  lenguajes con los diferentes tipos de \nusuarios.\uf8e9 FUOC \u2022 71Z799014MO 7 Introducci\u00f3n a las bases de datos\n1. Concepto y origen de las BD y de los SGBD\nLas aplicaciones inform\u00e1ticas de los a\u00f1os sesenta acostumbraban a darse total -\nmente por lotes ( batch ) y estaban pensadas para un a tarea muy espec\u00edfica rela -\ncionada con muy pocas entidades tipo.\nCada aplicaci\u00f3n (una o va rias cadenas de programas)  utilizaba ficheros de mo -\nvimientos para actualizar (creando una copia nueva) y/o para consultar uno o \ndos ficheros maestros o, excepcionalmente, m\u00e1s de dos. Cada programa trata -\nba como m\u00e1ximo un fichero maestro, que sol\u00eda estar sobre cinta magn\u00e9tica y, \nen consecuencia, se trabajaba con acceso secuencial. Cada vez que se le quer\u00eda a\u00f1adir una aplicaci\u00f3n que requer\u00eda el us o de algunos de los datos que ya exis\n-\nt\u00edan y de otros nuevos, se dise\u00f1aba un fichero nuevo con todos los datos ne -\ncesarios (algo que provocaba redundancia) para evitar que los programas \ntuviesen que leer muchos ficheros.\nA medida que se fueron introduciendo las l\u00edneas de comunicaci\u00f3n, los termi -\nnales y los discos, se fueron escribie ndo programas que permit\u00edan a varios \nusuarios consultar los mismos ficheros on-line  y de forma simult\u00e1nea. M\u00e1s ade -\nlante fue surgiendo la necesidad de  hacer las actua lizaciones tambi\u00e9n on-line .\nA medida que se integraban las aplicaciones,  se tuvieron que interrelacionar \nsus ficheros y fue necesario eliminar la redundancia. El nuevo conjunto de fi -\ncheros se deb\u00eda dise\u00f1ar de modo que estuviesen interrelacionados; al mismo \ntiempo, las informaciones redundantes (como por ejemplo, el nombre y la di -\nrecci\u00f3n de los clientes o el  nombre y el precio de lo s productos), que figuraban \nen los ficheros de m\u00e1s de una de las aplic aciones, deb\u00edan estar ahora en un solo \nlugar.\nEl acceso on-line y la utilizaci\u00f3n eficiente de la s interrelaciones exig\u00edan estruc -\nturas f\u00edsicas que diesen un acceso r\u00e1pido, como por ejemplo los \u00edndices, las \nmultilistas, las t\u00e9cnicas de hashing , etc.\nEstos conjuntos de ficher os interrelacionados , con estructuras complejas y \ncompartidos por varios procesos de forma simult\u00e1nea (unos on-line  y otros por \nlotes), recibieron al pr incipio el nombre de Data Banks , y despu\u00e9s, a inicios de \nlos a\u00f1os setenta, el de Data Bases . Aqu\u00ed los denominamos bases de datos (BD) .\nEl software de gesti\u00f3n de ficheros  era demasiado elemental para dar satisfac -\nci\u00f3n a todas estas necesidades. Por ejemplo, el tratamiento de las interrelaciones \nno estaba previsto, no era posible que va rios usuarios actualizaran datos simul -\nt\u00e1neamente, etc. La utilizaci\u00f3n de estos conjuntos de ficheros por parte de los \nprogramas de aplicaci\u00f3n era excesivamente compleja, de modo que, especial -\nmente durante la segunda mitad de los a\u00f1 os setenta, fue saliendo al mercado Aplicaciones inform\u00e1ticas \nde los a\u00f1os sesenta\nLa emisi\u00f3n de facturas, el  \ncontrol de pedidos pendientes de servir, el mantenimiento  \ndel fichero de productos  \no la n\u00f3mina del personal eran  \nalgunas de las aplicaciones  \ninform\u00e1ticas habituales  \nen los a\u00f1os sesenta.\nIntegraci\u00f3n  \nde aplicaciones\nPor ejemplo, se integra  \nla aplicaci\u00f3n de facturas,  \nla de pedidos pendientes  \ny la gesti\u00f3n del fichero  \nde productos.\uf8e9 FUOC \u2022 71Z799014MO 8 Introducci\u00f3n a las bases de datos\nsoftware  m\u00e1s sofisticado: los Data Base Management Systems , que aqu\u00ed denomi -\nnamos sistemas de gesti\u00f3n de BD (SGBD) .\nEn otras palabras, una base de datos es un conjunto estructurado de datos que \nrepresenta entidades y sus interrelaciones . La representaci\u00f3n ser\u00e1 \u00fanica e inte -\ngrada, a pesar de que de be permitir utilizacione s varias y simult\u00e1neas.\nLos ficheros tradicionales y las BD\nAunque de forma muy simplificada, podr\u00edamos en umerar las principales diferencias entre los \nficheros tradicionales y las BD tal y como se indica a continuaci\u00f3n:\n1)Entidades tipos:\n\u2022 Ficheros: tienen registros de una sola entidad tipo.\n\u2022 BD: tienen datos de varias entidades tipo.\n2)Interrelaciones:\n\u2022 Ficheros: el sistema no  interrelaciona ficheros.\n\u2022 BD: el sistema tiene previstas herrami entas para interrelacionar entidades.\n3)Redundancia:\n\u2022 Ficheros: se crean ficheros a la medida de cada aplicaci\u00f3n, con todos los datos necesarios \naunque algunos sean redundantes respecto de otros ficheros.\n\u2022 BD: todas las aplicaciones trabajan con la mism a BD y la integraci\u00f3n de los datos es b\u00e1sica, \nde modo que se evita la redundancia.\n4)Usuarios\n\u2022 Ficheros: sirven para un solo usuario o una sola aplicaci\u00f3n. Dan una sola visi\u00f3n del mundo \nreal.\n\u2022 BD: es compartida por muchos  usuarios de distintos tipos. Ofrece varias visiones del \nmundo real.Con todo lo que hemos dicho hasta ah ora, podr\u00edamos definir el t\u00e9rmino \nBD; una base de datos de un SI  es la representaci\u00f3n integrada de los con -\njuntos de entidades instancia correspo ndientes a las diferentes entidades \ntipo del SI y de sus interrelaciones. Esta representaci\u00f3n inform\u00e1tica (o \nconjunto estructurado de datos) de be poder ser utilizada de forma com -\npartida por muchos usuarios de distintos tipos.\uf8e9 FUOC \u2022 71Z799014MO 9 Introducci\u00f3n a las bases de datos\n2. Evoluci\u00f3n de los SGBD\nPara entender mejor qu\u00e9 son los SGBD, haremos un repaso de su evoluci\u00f3n \ndesde los a\u00f1os sesenta hasta nuestros d\u00edas.\n2.1. Los a\u00f1os sesenta y sete nta: sistemas centralizados\nLos primeros SGBD  \u2013en los a\u00f1os sesenta todav\u00eda no se les denominaba as\u00ed\u2013 \nestaban orientados a facilit ar la utilizaci\u00f3n de grande s conjuntos de datos en \nlos que las interrelaciones eran compleja s. El arquetipo de aplicaci\u00f3n era el Bill \nof materials  o Parts explosion , t\u00edpica en las industrias del autom\u00f3vil, en la cons -\ntrucci\u00f3n de naves espaciales y en campos similares. Estos sistemas trabajaban \nexclusivamente por lotes ( batch ).\nAl aparecer  los terminales de teclado, conectados al ordenador central mediante \nuna l\u00ednea telef\u00f3nica, se em piezan a construir grandes aplicaciones on-line  tran -\nsaccionales (OLTP) . Los SGBD estaban \u00edntimamente ligados al software  de co -\nmunicaciones y de gesti\u00f3n de transacciones.\nAunque para escribir los programas de aplicaci\u00f3n  se utilizaban lenguajes de \nalto nivel como Cobol o PL/I, se dispon \u00eda tambi\u00e9n de instrucciones y de subru -\ntinas especializadas para tratar las BD  que requer\u00edan que el programador cono -\nciese muchos detalles del dise\u00f1o f\u00edsico, y que hac\u00edan que la programaci\u00f3n fuese \nmuy compleja.\nPuesto que los programas estaban relacion ados con el nivel f\u00edsico, se deb\u00edan \nmodificar continuamente cuando se hac\u00ed an cambios en el dise\u00f1o y la organi -\nzaci\u00f3n de la BD. La preocupaci\u00f3n b\u00e1si ca era maximizar el rendimiento: el \ntiempo de respuesta y las transacciones por segundo. \n2.2. Los a\u00f1os ochenta: SGBD relacionales\nLos ordenadores minis , en primer lugar, y despu\u00e9s los ordenadores micros , \nextendieron la inform\u00e1tica a pr\u00e1cticamente todas las empresas e instituciones. Los SGBD de los a\u00f1os sesenta y setenta (IMS de IBM, IDS de Bull, DMS \nde Univac, etc.) eran sistemas totalmente centralizados , como corres -\nponde a los sistemas operativos de aquellos a\u00f1os, y al hardware  para el \nque estaban hechos: un gran ordenado r para toda la empresa y una red \nde terminales sin inteligencia ni memoria.\nEl Data Base  / Data \nComunications\nIBM denominaba Data Base/\nData Comunications  (DB/DC) \nel software  de comunicaciones \ny de gesti\u00f3n de transacciones  \ny de datos. Las aplicaciones  \nt\u00edpicas eran la reserva/compra de billetes a las compa\u00f1\u00edas  \na\u00e9reas y de ferrocarriles y,  \nun poco m\u00e1s tarde, las cuentas de clientes en el mundo  \nbancario.\n\uf8e9 FUOC \u2022 71Z799014MO 10 Introducci\u00f3n a las bases de datos\nEsto exig\u00eda que el desarrollo de aplic aciones fuese m\u00e1s sencillo. Los SGBD de \nlos a\u00f1os setenta eran demasiado complejo s e inflexibles, y s\u00f3lo los pod\u00eda uti -\nlizar un personal muy cualificado.\nTodos estos factores hacen que se extien da el uso de los SGBD. La estandariza -\nci\u00f3n, en el a\u00f1o 1986, del lenguaje SQL  produjo una aut\u00e9ntica explosi\u00f3n de \nlos SGBD relacionales.\nLos ordenadores personales\nDurante los a\u00f1os ochenta aparecen y se extienden muy r\u00e1pidamente los ordenadores perso -\nnales. Tambi\u00e9n surge software  para estos equipos monousuario (por ejemplo, dBase y sus de -\nrivados, Access), con los cuales  es muy f\u00e1cil crear y utilizar conjuntos de datos, y que se \ndenominan personal data bases . Notad que el hecho de denomi nar SGBD estos primeros sis -\ntemas para PC es un poco forzado, ya que no  aceptaban estructuras complejas ni interrela -\nciones, ni pod\u00edan ser utilizados en una red que sirviese simult\u00e1neamente a muchos usuarios \nde diferentes tipos. Sin embargo, algunos, co n el tiempo, se han ido convirtiendo en aut\u00e9n -\nticos SGBD.\n2.3. Los a\u00f1os noventa: distribuci\u00f3n, C/S y 4GL\nAl acabar la d\u00e9cada de los ochenta, lo s SGBD relacionales ya se utilizaban pr\u00e1c -\nticamente en todas las empresas. A pesar de todo, hasta la mitad de los noven -\nta, cuando se ha necesitado un rendim iento elevado se han seguido utilizando \nlos SGBD prerrelacionales.\nA finales de los ochenta y principios de  los noventa, las empresas se han en -\ncontrado con el hecho de que sus departamentos han ido comprando orde -\nnadores departamentales y personales, y han ido haciendo aplicaciones con \nBD. El resultado ha sido que en el seno de la empresa hay numerosas BD y \nvarios SGBD de diferentes tipos o proveedores. Este fen\u00f3meno de multiplica -\nci\u00f3n de las BD y de los SGBD  se ha visto incrementado  por la fiebre de las \nfusiones de empresas.\nEsta distribuci\u00f3n ideal se consigue cu ando las diferentes BD son soportadas \npor una misma marca de SGBD, es decir, cuando hay homogeneidad. Sin em -La aparici\u00f3n de los SGBD relacionales*  supone un avance importante \npara facilitar la programaci\u00f3n de aplicaciones con BD y para conseguir \nque los programas sean in dependientes de los aspe ctos f\u00edsicos de la BD.\nLa necesidad de tener una visi\u00f3n global de la empresa y de interrelacio -\nnar diferentes aplicaciones que utiliz an BD diferentes , junto con la fa -\ncilidad que dan las redes para la intercomunicac i\u00f3n entre ordenadores, \nha conducido a los SGBD actuales, que permiten que un programa pue -\nda trabajar con diferentes BD como si se tratase de una sola. Es lo que se conoce como base de datos distribuida . * Oracle aparece en el a\u00f1o 1980.\uf8e9 FUOC \u2022 71Z799014MO 11 Introducci\u00f3n a las bases de datos\nbargo, esto no es tan senc illo si los SGBD son hetero g\u00e9neos. En la actualidad, \ngracias principalmente a la estandariz aci\u00f3n del lenguaje SQL, los SGBD de \nmarcas diferentes pueden darse servicio  unos a otros y colaborar para dar ser -\nvicio a un programa de apli caci\u00f3n. No obstante, en general, en los casos de he -\nterogeneidad no se llega a poder dar en el  programa que los utiliza la apariencia \nde que se trata de una \u00fanica BD.\nFigura 1\nAdem\u00e1s de esta distribuci\u00f3n \u201cimpuesta\u201d, al querer tratar de forma integrada distintas BD preexistentes, tambi\u00e9n se  puede hacer una distribuci\u00f3n \u201cdesea\n-\nda\u201d, dise\u00f1ando una BD distribuida f\u00edsica mente, y con ciertas partes replicadas \nen diferentes sistemas. Las razones b\u00e1sicas por las que interesa esta distribu -\nci\u00f3n son las siguientes: \n1) Disponibilidad . La disponibilidad de un si stema con una BD distribuida \npuede ser m\u00e1s alta, porque si queda fuera de servicio uno de los sistemas, los de -\n\uf8e9 FUOC \u2022 71Z799014MO 12 Introducci\u00f3n a las bases de datos\nm\u00e1s seguir\u00e1n funcionando. Si los datos re sidentes en el sistema no disponible \nest\u00e1n replicados en otro sistema, contin uar\u00e1n estando disponibles. En caso con -\ntrario, s\u00f3lo estar\u00e1n disponibles los datos de los dem\u00e1s sistemas.\n2) Coste . Una BD distribuida puede reducir el coste. En el caso de un sistema \ncentralizado, todos los equipos usuarios, que pueden estar distribuidos por dis -\ntintas y lejanas \u00e1reas geogr\u00e1ficas, est\u00e1 n conectados al sistema central por medio \nde l\u00edneas de comunicaci\u00f3n. El coste tota l de las comunicaciones se puede redu -\ncir haciendo que un usuario tenga m\u00e1 s cerca los datos que utiliza con mayor \nfrecuencia; por ejemplo, en un ordenador de  su propia oficina o, incluso, en su \nordenador personal.\nPor ejemplo,  un programa de aplicaci\u00f3n que un usuario ejecuta en su PC (que \nest\u00e1 conectado a una red) pide ciertos datos de una BD que reside en un equipo \nUNIX donde, a su vez, se ejecuta el SG BD relacional que la gestiona. El progra -\nma de aplicaci\u00f3n es el client e y el SGBD es el servidor.\nUn proceso cliente puede pedir servicios a varios servidores. Un servidor puede \nrecibir peticiones de muchos clientes. En general, un proceso A que hace de \ncliente, pidiendo un servicio a otro proceso B puede hacer tambi\u00e9n de servidor \nde un servicio que le pida otro proceso C (o incluso el B, que en esta petici\u00f3n \nser\u00eda el cliente). Incluso el cliente y el servidor pueden residir en un mismo sis -\ntema.\nFigura 2La tecnolog\u00eda que se utiliza habitualme nte para distribuir datos es la que \nse conoce como entorno  (o arquitectura) cliente/servidor  (C/S) . Todos \nlos SGBD relacionales del mercado han sido adaptados a este entorno.\nLa idea del C/S es senc illa. Dos procesos diferent es, que se ejecutan en \nun mismo sistema o en sistemas separados, act\u00faan de forma que uno \ntiene el papel de cliente  o peticionario de un servicio, y el otro el de ser-\nvidor  o proveedor del servicio.\nOtros servicios\nNotad que el servicio que da \nun servidor de un sistema  \nC/S no tiene por qu\u00e9 estar  \nrelacionado con las BD; puede ser un servicio de impresi\u00f3n, de env\u00edo de un fax, etc.,  \npero aqu\u00ed nos interesan los  \nservidores que son SGBD.\n\uf8e9 FUOC \u2022 71Z799014MO 13 Introducci\u00f3n a las bases de datos\nLa facilidad para disponer de distribuci\u00f3n  de datos no es la \u00fanica raz\u00f3n, ni si -\nquiera la b\u00e1sica, del gran \u00e9xito de los entornos C/S en los a\u00f1os noventa. Tal \nvez el motivo fundamental ha sido la fl exibilidad para construir y hacer crecer \nla configuraci\u00f3n inform\u00e1tica global de la empresa, as\u00ed como de hacer modifi -\ncaciones en ella, mediante hardware  y software  muy est\u00e1ndar y barato.\nEl \u00e9xito de las BD, incluso en sistemas personales , ha llevado a la aparici\u00f3n de \nlos Fourth Generation Languages  (4GL) , lenguajes muy f\u00e1ciles y potentes, es -\npecializados en el desarro llo de aplicaciones fundam entadas en BD. Proporcio -\nnan muchas facilidades en el momento de definir, generalmente de forma \nvisual, di\u00e1logos para introducir, modificar y consultar datos en entornos C/S.\n2.4. Tendencias actuales\nLos tipos de datos que se pueden definir en los SGBD relacionales de los a\u00f1os \nochenta y noventa so n muy limitados. La incorporaci\u00f3n de tecnolog\u00edas \nmultimedia  \u2013imagen y sonido\u2013 en los SI hace  necesario que los SGBD relacio -\nnales acepten atributos de estos tipos.\nSin embargo, algunas aplicaciones no tien en suficiente con la incorporaci\u00f3n de \ntipos especializados en multimedia. Necesitan tipos complejos que el desarro -\nllador pueda definir a medi da de la aplicaci\u00f3n. En definitiva, se necesitan tipos \nabstractos de datos: TAD . Los SGBD m\u00e1s recientes ya incorporaban esta posi -\nbilidad, y abren un amplio mercado de TA D predefinidos o librer\u00edas de clases.\nEsto nos lleva a la orientaci\u00f3n a objetos (OO) . El \u00e9xito de la OO al final de los \na\u00f1os ochenta, en el desarrollo de software  b\u00e1sico, en las aplicaciones de inge -\nnier\u00eda industrial y en la construcci\u00f3n de  interfaces gr\u00e1ficas con los usuarios, ha \nhecho que durante la d\u00e9cada de los no venta se extendiese en pr\u00e1cticamente \ntodos los campos de la inform\u00e1tica.\nEn los SI se inicia tambi\u00e9n la adopci\u00f3n , t\u00edmida de momento, de la OO. La uti -\nlizaci\u00f3n de lenguajes como C++ o Java re quiere que los SGBD  relacionales se \nadapten a ellos con interfaces adecuadas.\nLa r\u00e1pida adopci\u00f3n de la web a los SI hace que los SGBD incorporen recursos \npara ser servidores de p\u00e1 ginas web, como por ejemplo la inclusi\u00f3n de SQL en \nguiones HTML, SQL incorporado en Java, etc. Notad que en el mundo de la \nweb son habituales los da tos multimedia y la OO.Hoy d\u00eda, los SGBD relacionales es t\u00e1n en plena transformaci\u00f3n para \nadaptarse a tres tecnolog\u00edas de \u00e9xit o reciente, fuertemente relacionadas: \nla multimedia, la de or ientaci\u00f3n a objetos (OO) e Internet y la web.C/S, SQL y 4GL...\n... son siglas de moda desde el \nprincipio de los a\u00f1os noventa en el mundo de los sistemas  \nde informaci\u00f3n.\nNos puede interesar,...\n... por ejemplo, tener en la  \nentidad alumno  un atributo \nfoto tal que su valor sea una tira \nde bits muy larga, resultado de la digitalizaci\u00f3n de la fotograf\u00eda \ndel alumno.\uf8e9 FUOC \u2022 71Z799014MO 14 Introducci\u00f3n a las bases de datos\nDurante estos \u00faltimos a\u00f1os se ha empezado a extender un tipo de aplicaci\u00f3n \nde las BD denominado Data Warehouse , o almac\u00e9n de datos , que tambi\u00e9n \nproduce algunos cambios en los SGBD relacionales del mercado.\nA lo largo de los a\u00f1os que han trabajado con BD de distintas aplicaciones, las \nempresas han ido acumulando gran cantidad de datos de todo tipo. Si estos \ndatos se analizan convenientemente  pueden dar informaci\u00f3n valiosa*.\nPor lo tanto, se trata de mantener un a gran BD con informaci\u00f3n proveniente \nde toda clase de aplicaciones de la empresa (e, incluso, de fuera). Los datos de \neste gran almac\u00e9n, el Data Warehouse , se obtienen por una replicaci\u00f3n m\u00e1s o \nmenos elaborada de la s que hay en las BD que se ut ilizan en el trabajo cotidia -\nno de la empresa. Estos almacenes de datos se ut ilizan exclusivamente para ha -\ncer consultas, de forma especial para que lleven a cabo estudios* los analistas \nfinancieros, los analis tas de mercado, etc.\nActualmente, los SGBD se adaptan a este  tipo de aplicaci\u00f3n, incorporando, por \nejemplo, herramientas como las siguientes:\na)La creaci\u00f3n y el mantenim iento de r\u00e9plicas, con una cierta elaboraci\u00f3n de \nlos datos.\nb)La consolidaci\u00f3n de datos de or\u00edgenes diferentes.\nc)La creaci\u00f3n de estructuras f\u00edsicas que soporten eficientemente el an\u00e1lisis \nmultidimensional.* Por ejemplo, la evoluci\u00f3n\ndel mercado en relaci\u00f3n con \nla pol\u00edtica de precios.\n* Con frecuencia se trata de \nestad\u00edsticas multidimensionales.\uf8e9 FUOC \u2022 71Z799014MO 15 Introducci\u00f3n a las bases de datos\n3. Objetivos y servicios de los SGBD\nLos SGBD que actualmente est\u00e1n en el mercado pretenden satisfacer un con -\njunto de objetivos directamente deducibles de lo que hemos explicado hasta \nahora. A continuaci\u00f3n los comentaremos, pero sin entrar en detalles que ya se \nver\u00e1n m\u00e1s adelante en otras asignaturas.\n3.1. Consultas no predefinidas y complejas\nEl objetivo fundamental de los SGBD es permitir que se hagan consultas no \npredefinidas  (ad hoc ) y complejas .\nConsultas que afectan a m\u00e1s de una entidad tipo\n\u2022 Se quiere conocer el n\u00famero de alumnos de  m\u00e1s de veinticinco a\u00f1os y con nota media \nsuperior a siete que est\u00e1n matriculad os actualmente en la asignatura Bases de datos I .\n\u2022 De cada alumno matriculado en menos de tres  asignaturas, se quiere obtener el nombre, \nel n\u00famero de matr\u00edcula, el nombre de las asignaturas y el nombre de profesores de estas asignaturas.\nEl usuario debe formular la consulta con un lenguaje sencillo  (que se quede, \nobviamente, en el nivel l\u00f3gico), que el  sistema debe interpretar directamente. \nSin embargo, esto no significa que no se puedan escribir programas con con -\nsultas incorporadas (por ejempl o, para procesos repetitivos).\nLa soluci\u00f3n est\u00e1ndar para alcanzar es te doble objetivo (consultas no prede -\nfinidas y complejas) es el lenguaje SQL , que explicaremos en otro m\u00f3dulo \ndid\u00e1ctico. \n3.2. Flexibilidad e independencia\nLa complejidad de las BD y la necesidad de irlas adaptando a la evoluci\u00f3n del SI \nhacen que un objetivo b\u00e1sico de los SGBD sea dar flexibilidad a los cambios .\nInteresa obtener la m\u00e1xima independencia  posible entre los datos y los proce -\nsos usuarios para que se pueda llevar a cabo todo tipo de cambios tecnol\u00f3gicos Los usuarios podr\u00e1n hacer consultas de cualquier tipo y complejidad \ndirectamente al SGBD. El SGBD te ndr\u00e1 que responder inmediatamente \nsin que estas consultas est\u00e9n preestabl ecidas; es decir, sin que se tenga \nque escribir, compilar y ejecutar un programa espec\u00edfico para cada con -\nsulta.Ficheros tradicionales\nEn los ficheros tradicionales, \ncada vez que se quer\u00eda hacer una consulta se ten\u00eda que  \nescribir un programa a medida.\n\uf8e9 FUOC \u2022 71Z799014MO 16 Introducci\u00f3n a las bases de datos\ny variaciones en la descripci\u00f3n de la BD, sin que se deban modificar los progra -\nmas de aplicaci\u00f3n ya escritos ni cambiar la forma de escribir las consultas (o ac -\ntualizaciones) directas.\nEn el mundo de los ficheros ya hab\u00eda independencia f\u00edsica en un cierto grado, \npero en el mundo de las BD acostumbra a ser mucho mayor.\nEjemplos de independencia l\u00f3gica\n1)El personal administrativo de secretar\u00eda podr\u00eda tener una visi\u00f3n de la entidad alumno  sin \nque fuese necesario que existiese el atributo nota. Sin embargo, los usuari os profesores (o los \nprogramas dirigidos a ellos) podr\u00edan tener un a visi\u00f3n en la que ex istiese el atributo nota pero \nno el atributo fecha de pago .\n2)Decidimos ampliar la lo ngitud del atributo nombre  y lo aumentamos de treinta a cin -\ncuenta caracteres, pero no ser\u00eda necesario mo dificar los programas que ya tenemos escritos \nsi no nos importa que los valore s obtenidos tengan s\u00f3lo los pr imeros treinta caracteres del \nnombre.\n3.3. Problemas de la redundancia\nEn el mundo de los ficheros tradicionales,  cada aplicaci\u00f3n utilizaba su fichero. \nSin embargo, puesto que se daba mucha coincidencia de datos entre aplicacio -Para conseguir esta independencia,  tanto los usuarios que hacen con -\nsultas (o actualizacione s) directas como los pr ofesionales inform\u00e1ticos \nque escriben programas que las lle van incorporadas, deben poder des -\nconocer las caracter\u00edsticas f\u00edsicas de  la BD con que trabajan. No necesi -\ntan saber nada sobre el soporte f\u00edsico, ni estar al corriente de qu\u00e9 SO se \nutiliza, qu\u00e9 \u00edndices hay, la compresi \u00f3n o no compresi\u00f3n de datos, etc.\nDe este modo, se pueden hacer camb ios de tecnolog\u00eda y cambios f\u00edsicos \npara mejorar el rendimiento sin afec tar a nadie. Este tipo de indepen -\ndencia recibe el nombre de independencia f\u00edsica de los datos .\nSin embargo, con la independenci a f\u00edsica no tenemos suficiente. Tam-\nbi\u00e9n queremos que los usuarios (los programadores de aplicaciones o \nlos usuarios directos) no tengan qu e hacer cambios cuando se modifica \nla descripci\u00f3n l\u00f3gica o el esquema de la BD (por ejemplo, cuando se a\u00f1a -\nden/suprimen entidades o interrelaciones, atributos, etc.\nY todav\u00eda m\u00e1s: queremos que diferent es procesos usuarios puedan tener \ndiferentes visiones l\u00f3gi cas de una misma BD, y que estas visiones se pue -\ndan mantener lo m\u00e1s independientes posibles de la BD, y entre ellas mis -\nmas. Este tipo de independencia se denomina  independencia l\u00f3gica de \nlos datos , y da flexibilidad y elasticidad a los cambios l\u00f3gicos.Independencia l\u00f3gica  \nde los datos\nPor ejemplo, el hecho  \nde suprimir el atributo fecha  \nde nacimiento  de la entidad \nalumno  y a\u00f1adir otra entidad \naula no deber\u00eda afectar  \na ninguno de los programas existentes que no utilicen el atributo fecha de nacimiento .\nLas diferentes visiones l\u00f3gicas de \nuna BD se ver\u00e1n en el apartado 4  \nde esta unidad did\u00e1ctica.\nIndependencia l\u00f3gica\nLos sistemas de gesti\u00f3n  \nde ficheros tradicionales no dan ninguna independencia l\u00f3gica. Los SGBD s\u00ed que la dan; uno de sus objetivos es conse-guir la m\u00e1xima posible, pero dan menos de lo que ser\u00eda  \ndeseable.\uf8e9 FUOC \u2022 71Z799014MO 17 Introducci\u00f3n a las bases de datos\nnes, se produc\u00eda tambi\u00e9n mucha redundan cia entre los ficheros. Ya hemos dicho \nque uno de los objetivos de los SGBD es facilitar la eliminaci\u00f3n de la redun -\ndancia .\nSeguramente pens\u00e1is que el problema de la re dundancia es el espacio perdido. \nAntiguamente, cuando el precio del byte de disco era muy elevado, esto era un \nproblema grave, pero actu almente pr\u00e1cticamente nunc a lo es. \u00bfQu\u00e9 problema \nhay, entonces? Simplemente, lo que to dos hemos sufrido m\u00e1s de una vez; si \ntenemos algo apuntado en dos lugares diferentes no pasar\u00e1 demasiado tiempo \nhasta que las dos anotaciones dejen de  ser coherentes, porque habremos mo -\ndificado la anotaci\u00f3n en uno de los lu gares y nos habremos olvidado de hacer -\nlo en el otro.\nAs\u00ed pues, el verdadero problema es el grave riesgo de inco nsistencia o incohe -\nrencia de los datos; es decir, la  p\u00e9rdida de integridad  que las actu alizaciones \npueden provocar cuando existe redundancia. \nPor lo tanto, convendr\u00eda evitar la redund ancia. En principio, nos conviene hacer \nque un dato s\u00f3lo figure una vez en la BD . Sin embargo, esto no siempre ser\u00e1 cier -\nto. Por ejemplo, para repres entar una interrelaci\u00f3n entr e dos entidades, se suele \nrepetir un mismo atributo en las dos, para que una haga referencia a la otra.\nOtro  ejemplo podr\u00eda ser el disponer de r\u00e9plicas de los datos por razones de fia -\nbilidad, disponibilidad o co stes de comunicaciones.\nLa duplicaci\u00f3n  de datos es el tipo de redundancia m\u00e1s habitual, pero tambi\u00e9n \ntenemos redundancia cuando guardamos en  la BD datos derivados (o calcula -\ndos) a partir de otros datos de la misma BD. De este modo podemos responder \nr\u00e1pidamente a consultas globales, ya que nos ahorramos la lectura de gran \ncantidad de registros.\nEn los casos de datos derivados, para que el resultado del c\u00e1lculo se mantenga consistente con los datos elementales, es  necesario rehacer el c\u00e1lculo cada vez \nque \u00e9stos se modifican. El usuario (y a sea programador o no) puede olvidarse \nde hacer el nuevo c\u00e1lculo;  por ello convendr\u00e1 que el mismo SGBD lo haga \nautom\u00e1ticamente.El SGBD debe permitir que el dise\u00f1a dor defina datos redundantes, pero \nentonces tendr\u00eda que ser el mismo SGBD el que hiciese autom\u00e1ticamen -\nte la actualizaci\u00f3n de los datos  en todos los lugares donde estuviesen \nrepetidos.Consultad el apartado 1  \nde esta unidad did\u00e1ctica.\n\u00bfPor qu\u00e9 queremos evitar \nla redundancia? \u00bfQu\u00e9 problema \nnos comporta?\nPara recordar lo que se ha dicho \nsobre datos replicados, consultad  \nel subapartado 2.3 de esta unidad did\u00e1ctica.\nDatos derivados\nEs frecuente tener datos num\u00e9ri-\ncos acumulados o agregados: el importe total de todas las matr\u00ed-culas hechas hasta hoy, el n\u00fa-mero medio de alumnos por asignatura, el saldo de la caja  \nde la oficina, etc.\uf8e9 FUOC \u2022 71Z799014MO 18 Introducci\u00f3n a las bases de datos\n3.4. Integridad de los datos\nNos interesar\u00e1 que los SGBD aseguren el mantenimiento de la calidad de los \ndatos  en cualquier circunstancia. Acabamos de ver que la redundancia puede \nprovocar p\u00e9rdida de integrid ad de los datos, pero no es la \u00fanica causa posible. \nSe podr\u00eda perder la correcci\u00f3n o la cons istencia de los datos por muchas otras \nrazones: errores de progra mas, errores de operaci\u00f3n humana, aver\u00eda de disco, \ntransacciones incompletas por corte de alimentaci\u00f3n el\u00e9ctrica, etc.\nEn el subapartado anterior hemos visto que podrem os decir al SGBD que nos lle -\nve el control de las actualizaciones en el  caso de las redundancias, para garanti -\nzar la integridad. Del mismo modo, podremos darle otras reglas de integridad\n\u2013o restricciones\u2013 para que asegure que los programas las cumplen cuando efec -\nt\u00faan las actualizaciones.\nAparte de las reglas de integridad que el dise\u00f1ador de la BD puede definir y que \nel SGBD entender\u00e1 y har\u00e1 cumplir, el mi smo SGBD tiene reglas de integridad \ninherentes al modelo de datos que utiliza y que siempre se cumplir\u00e1n. Son las \ndenominadas reglas de integridad del modelo . Las reglas definibles por parte \ndel usuario son las reglas de integridad del usuario . El concepto de integridad \nde los datos  va m\u00e1s all\u00e1 de prevenir que los programas usuarios almacenen da -\ntos incorrectos. En casos de errores o desastres, tambi\u00e9n podr\u00edamos perder la \nintegridad de los datos. El SGBD no s debe dar las herramientas para recons -\ntruir o restaurar los datos estropeados.\n3.5. Concurrencia de usuariosCuando el SGBD detecte que un pr ograma quiere hacer una operaci\u00f3n \nque va contra las reglas establecidas al  definir la BD, no se lo deber\u00e1 per -\nmitir, y le tendr\u00e1 que devo lver un estado de error.\nAl dise\u00f1ar una BD para un SI concreto y escribir su esquema, no s\u00f3lo de -\nfiniremos los datos, sino tambi\u00e9n las reglas de integridad que queremos \nque el SGBD haga cumplir.\nLos procesos de restauraci\u00f3n  (restore  o recovery ) de los que todo SGBD \ndispone pueden reconstruir la BD y darle el estado consistente y correc -\nto anterior al incidente. Esto se acostumbra a hacer gracias a la obten -\nci\u00f3n de copias peri\u00f3dicas de los datos (se denominan copias de seguridad\no back-up ) y mediante el mantenimiento continuo de un diario ( log) \ndonde el SGBD va anotando todas las escrituras que se hacen en la BD.\nUn objetivo fundamental de los SGBD  es permitir que varios usuarios \npuedan acceder concurrentemente a la misma BD.Reglas de integridad\nPor ejemplo, podremos  \ndeclarar que el atributo DNI \ndebe ser clave o que la fecha  \nde nacimiento  debe ser una  \nfecha correcta y, adem\u00e1s,  \nse debe cumplir que el alumno no pueda tener menos  \nde dieciocho a\u00f1os ni m\u00e1s de noventa y nueve, o que el n\u00fa-mero de alumnos matriculados de una asignatura no sea supe-rior a veintisiete, etc.\nReglas de integridad  \ndel modelo\nPor ejemplo, un SGBD  \nrelacional nunca aceptar\u00e1  \nque una tabla tenga filas  \nduplicadas, un SGBD  \njer\u00e1rquico nunca aceptar\u00e1  \nque una entidad tipo est\u00e9  \ndefinida como hija de dos  \nentidades tipo diferentes, etc.\nUsuarios concurrentes\nActualmente ya no son  \nraros los SI que tienen, en un instante determinado, miles  \nde sesiones de usuario abiertas simult\u00e1neamente. No hace  \nfalta pensar en los t\u00edpicos siste-mas de los consorcios de com-pa\u00f1\u00edas a\u00e9reas o casos similares, sino en los servidores de p\u00e1gi-nas web.\uf8e9 FUOC \u2022 71Z799014MO 19 Introducci\u00f3n a las bases de datos\nCuando los accesos concurrentes son todo s de lectura (es decir, cuando la BD \ns\u00f3lo se consulta), el problema que se produce es simplement e de rendimiento, \ncausado por las limitaciones de los soportes de que se dispone: pocos mecanis -\nmos de acceso independientes, movimien to del brazo y del giro del disco de -\nmasiado lentos, buffers  locales demasiado peque\u00f1os, etc.\nCuando un usuario o m\u00e1s de uno est\u00e1n actualizando los datos, se pueden pro -\nducir problemas de interferencia  que tengan como consecuencia la obten -\nci\u00f3n de datos err\u00f3neos y la p\u00e9 rdida de integridad de la BD. \nPara tratar los acce sos concurrentes , los SGBD utilizan el concepto de transac -\nci\u00f3n de BD, concepto de especial utilid ad para todo aquello  que hace referen -\ncia a la integridad de los dato s, como veremos a continuaci\u00f3n.\nEjemplos de transacciones\n1)Imaginemos un programa pensado para llevar a cabo la operaci\u00f3n de transferencia de di -\nnero de una cuenta X a otra Y. Supongamos qu e la transferencia efect\u00faa dos operaciones: en \nprimer lugar, el cargo a X y despu\u00e9s, el abono a Y. Este programa se debe ejecutar de forma \nque se hagan las dos operaciones o ninguna, ya que si por cualquier raz\u00f3n (por ejemplo, por \ninterrupci\u00f3n del flujo el\u00e9ctrico) el programa ej ecutase s\u00f3lo el cargo de dinero a X sin abonar -\nlos a Y, la BD quedar\u00eda en un estado incorrecto. Queremos que la ejecuci\u00f3n de este programa \nsea tratada por el SGBD como una transacci\u00f3n de BD.\n2)Otro ejemplo de programa que querr\u00edamos  que tuviera un comportamiento de tran -\nsacci\u00f3n podr\u00eda ser el que aumentara el 30% de  la nota de todos los alumnos. Si s\u00f3lo au -\nmentara la nota a unos cuantos alum nos, la BD quedar\u00eda incorrecta.\nPara indicar al SGBD que damos por acabada la ejecuci\u00f3n de la transacci\u00f3n, el \nprograma utilizar\u00e1 la operaci\u00f3n de COMMIT . Si el programa no puede acabar \nnormalmente (es decir, si el conjunto de  operaciones se ha hecho s\u00f3lo de for -\nma parcial), el SGBD tendr\u00e1 que deshacer  todo lo que la transacci\u00f3n ya haya \nhecho. Esta operaci\u00f3n se denomina ROLLBACK .\nAcabamos de observar la utilidad del concepto de transacci\u00f3n  para el manteni -\nmiento de la integridad de los datos en  caso de interrupci\u00f3n de un conjunto \nde operaciones l\u00f3gicamente unitario. Sin embargo, entre transacciones que se \nejecutan concurrentemente  se pueden producir pr oblemas de interferencia \nque hagan obtener resultados err\u00f3neos o que comporten la p\u00e9rdida de la inte -\ngridad de los datos.\nConsecuencias de la interferencia entre transacciones\n1)Imaginemos que una transacci\u00f3n que transfier e dinero de X a Y se ejecuta concurrente -\nmente con una transacci\u00f3n que observa el saldo de las cuentas Y y X, en este orden, y nos \nmuestra su suma. Si la ejecuci\u00f3n de forma co ncurrente de las dos transacciones casualmente Denominamos transacci\u00f3n de BD  o, simplemente, transacci\u00f3n  un con -\njunto de operaciones simples que se ejecutan como una unidad. Los SGBD \ndeben conseguir que el conjunto de operaciones de una transacci\u00f3n nunca \nse ejecute parcialmente. O se ejecut an todas, o no se ejecuta ninguna.\n\uf8e9 FUOC \u2022 71Z799014MO 20 Introducci\u00f3n a las bases de datos\nes tal que la transferencia se ejecuta entre la ej ecuci\u00f3n de las dos lecturas  de la transacci\u00f3n de \nsuma, puede producir resu ltados incorrectos. Adem\u00e1s, si los decide escribir en la BD, \u00e9sta que -\ndar\u00e1 inconsistente (consultad la figura 3).\n2)Si simult\u00e1neamente con el generoso programa que aumenta la nota de los alumnos en un \n30%, se ejecuta un programa qu e determina la nota media de  todos los alumnos de una de -\nterminada asignatura, se podr\u00e1 encontrar a alumno s ya gratificados y a otros no gratificados, \nalgo que producir\u00e1 resultados err\u00f3neos. \nEstos son s\u00f3lo dos ejemplos de las diferentes consecuencias negativas que puede tener la in -\nterferencia entre transacciones en la integridad de la BD y en la correcci\u00f3n del resultado de \nlas consultas.\nFigura 3\nCuando se provocan bloqueos, se producen esperas, retenciones y, en conse -\ncuencia, el sistema es m\u00e1s lento. Los SGBD se esfuerzan en minimizar estos \nefectos negativos.\nRecordad que esta asignatura es s\u00f3lo  introductoria y que m\u00e1s adelante, en \notras asignaturas, estudiar\u00e9is con m\u00e1s detalle los temas que, como el de la con -\ncurrencia, aqu\u00ed s\u00f3 lo introducimos. Nos interesar\u00e1 que el SGBD  ejecute las transacciones de forma que no \nse interfieran; es decir, que queden aisladas unas de otras. Para conse -\nguir que las transaccione s se ejecuten como si estuviesen aisladas, los \nSGBD utilizan distintas t\u00e9cn icas. La m\u00e1s conocida es el  bloqueo  (lock).\nEl bloqueo de unos datos en beneficio de una transacci\u00f3n consiste en po -\nner limitaciones a los acce sos que las dem\u00e1s transacciones podr\u00e1n hacer a \nestos datos.\nBloqueos en la \ntransferencia de dinero\nPor ejemplo, si la transacci\u00f3n \nde transferencia de dinero  \nmodifica el saldo de la cuenta X, el SGBD bloquea esta  \ncuenta de forma que, cuando la transacci\u00f3n de suma quiera leerla, tenga que esperar a que la transacci\u00f3n de transferencia acabe; esto se debe al hecho de que al acabar una transac-ci\u00f3n, cuando se efect\u00faan las operaciones COMMIT  o  \nROLLBACK  se liberan los  \nobjetos que ten\u00eda bloqueados.\n\uf8e9 FUOC \u2022 71Z799014MO 21 Introducci\u00f3n a las bases de datos\n3.6. Seguridad\nEl t\u00e9rmino seguridad se ha utilizado en diferentes se ntidos a lo largo de la his -\ntoria de la inform\u00e1tica.\nEstas cuestiones siempre han sido import antes en los SI militares, las agencias \nde informaci\u00f3n y en \u00e1mbito s similares, pero durante los a\u00f1os noventa han ido \nadquiriendo importancia en cualquier SI  donde se almacene n datos sobre per -\nsonas. Recordad que en el Estado espa \u00f1ol tenemos una ley*, que exige la pro -\ntecci\u00f3n de la confidenci alidad de estos datos.\nLos SGBD permiten definir autorizaciones  o derechos de acceso a diferentes \nniveles: al nivel global de toda la BD, al nivel entidad y al nivel atributo.\nEstos mecanismos de seguridad requieren que el usuario se pueda identificar. \nSe acostumbra a utilizar c\u00f3digos de usua rios (y grupos de usuarios) acompa\u00f1a -\ndos de contrase\u00f1as ( passwords ), pero tambi\u00e9n se utiliz an tarjetas magn\u00e9ticas, \nidentificaci\u00f3n por reconocimiento de la voz, etc.\nNos puede interesar almacenar la inform aci\u00f3n con una codificaci\u00f3n secreta; \nes decir, con t\u00e9cnicas de encriptaci\u00f3n  (como m\u00ednimo se deber\u00edan encriptar \nlas contrase\u00f1as). Muchos de los SGBD actu ales tienen prevista la encriptaci\u00f3n.\nPr\u00e1cticamente todos los SGBD del mercado dan una gran variedad de herra -\nmientas para la vigilancia y la administraci\u00f3n de la seguridad. Los hay que, in -\ncluso, tienen opciones (con precio separado) para los SI con unas exigencias \nalt\u00edsimas, como por ejemplo los militares.\n3.7. Otros objetivos\nAcabamos de ver los objetivos fundamentales de los SGBD actuales. Sin em -\nbargo, a medida que los SGBD evoluc ionan, se imponen nuevos objetivos \nadaptados a las nuevas necesidades y las nuevas tecnolog\u00edas. Como ya hemos visto, en estos momentos podr\u00edamos ci tar como objetivos nuevos o recientes \nlos siguientes: \n1)Servir eficientemente los Data Warehouse .\n2)Adaptarse al desarrollo orientado a objetos.\n3)Incorporar el tiempo como un elemento  de caracterizaci\u00f3n de la informaci\u00f3n.\n4)Adaptarse al mundo de Internet.Actualmente, en el campo de los SGBD, el t\u00e9rmino seguridad  se suele uti -\nlizar para hacer referencia a los tema s relativos a la confidencialidad, las \nautorizaciones, los derechos de acceso, etc.\n* Ley Org\u00e1nica 15/1999, de 13 \nde diciembre, de Protecci\u00f3n \nde Datos de Car\u00e1cter Personal. \n(BOE n\u00fam. 298, de 12/12/1999, \np\u00e1gs. 43088-43099).\nDerechos de acceso\nPor ejemplo, el usuario SECRE3 \npodr\u00eda tener autorizaci\u00f3n para consultar y modificar todas las entidades de la BD, excepto  \nel valor del atributo nota de los \nalumnos , y no estar autorizado \na hacer ning\u00fan tipo de supre-si\u00f3n o inserci\u00f3n.\nPara recordar las tendencias \nactuales sobre SGBD, pod\u00e9is  \nrevisar el subapartado 2.4.  \nde esta unidad did\u00e1ctica.\n\uf8e9 FUOC \u2022 71Z799014MO 22 Introducci\u00f3n a las bases de datos\n4. Arquitectura de los SGBD\n4.1. Esquemas y niveles\nPara trabajar con nuestras BD, los SGBD  necesitan conocer su estructura (qu\u00e9 \nentidades tipo habr\u00e1, qu\u00e9 atributos tendr\u00e1n, etc.).\nEl esquema de la BD es un elemento fundamental de la arquitectura de un \nSGBD que permite independizar el SGBD  de la BD; de este modo, se puede \ncambiar el dise\u00f1o de la BD (su esquem a) sin tener que hacer ning\u00fan cambio \nen el SGBD.\nAnteriormente, ya hemos ha blado de la distinci\u00f3n entre dos niveles de repre -\nsentaci\u00f3n inform\u00e1tica: el nivel l\u00f3gico y el f\u00edsico.\nEl nivel l\u00f3gico  nos oculta los detalles de c\u00f3mo se almacenan los datos, c\u00f3mo \nse mantienen y c\u00f3mo se acce de f\u00edsicamente a ellos. En este nivel s\u00f3lo se habla \nde entidades, atributos y reglas de integridad.\nPor cuestiones de rendim iento, nos podr\u00e1 interesar describir elementos de ni-\nvel f\u00edsico  como, por ejemplo, qu\u00e9 \u00edndices te ndremos y qu\u00e9 caracter\u00edsticas pre -\nsentar\u00e1n, c\u00f3mo y d\u00f3nde (en qu\u00e9 espaci o f\u00edsico) queremos que se agrupen \nf\u00edsicamente los registros, de qu\u00e9 tama\u00f1o deben ser las p\u00e1ginas, etc.\nEn el periodo 1975-1982, ANSI intentaba establecer las bases para crear est\u00e1n -\ndares en el campo de las BD. El comit\u00e9 conocido como ANSI/SPARC recomen -\nd\u00f3 que la arquitectura de los SGBD prev iese tres niveles de  descripci\u00f3n de la \nBD, no s\u00f3lo dos*.Los SGBD necesitan que les demos un a descripci\u00f3n o definici\u00f3n de la \nBD. Esta descripci\u00f3n re cibe el nombre de esquema de la BD , y los SGBD \nla tendr\u00e1n continua mente a su alcance.\nDe acuerdo con la arquit ectura ANSI/SPARC, deb\u00eda haber tres niveles de \nesquemas (tres niveles de abstracci\u00f3 n). La idea b\u00e1sica de ANSI/SPARC \nconsist\u00eda en descomponer el nivel l\u00f3gico en dos: el nivel externo  y el \nnivel conceptual . Denomin\u00e1bamos nivel interno  lo que aqu\u00ed hemos \ndenominado nivel f\u00edsico .* De hecho, en el a\u00f1o 1971, \nel comit\u00e9 CODASYL ya hab\u00eda \npropuesto los tres niveles\nde esquemas.\uf8e9 FUOC \u2022 71Z799014MO 23 Introducci\u00f3n a las bases de datos\nDe este modo, de acuerdo con ANSI/SPARC, habr\u00eda  los tres niveles de esque -\nmas que mencionamos a continuaci\u00f3n: \na)En el nivel externo se sit\u00faan las diferentes visiones l\u00f3gicas que los procesos \nusuarios (programas de aplicaci\u00f3n y usuari os directos) tendr\u00e1n de las partes de \nla BD que utilizar\u00e1n. Esta s visiones se denominan esquemas externos .\nb)En el nivel conceptual hay una sola descripci\u00f3n l\u00f3gica b\u00e1sica, \u00fanica y glo -\nbal, que denominamos esquema conceptual , y que sirve de referencia para el \nresto de los esquemas.\nc)En el nivel f\u00edsico hay una sola descripci\u00f3n f\u00edsica , que denominamos esque -\nma interno .\nFigura 4\nEl esquema conceptual corresponde a la s necesidades del conjunto de la em -\npresa o del SI, por lo que se escribir\u00e1 de forma centralizad a durante el denomi -\nnado dise\u00f1o l\u00f3gico  de la BD.\nSin embargo, cada aplicaci\u00f3n podr\u00e1 tene r su visi\u00f3n partic ular, y seguramente \nparcial, del esquema conceptual. Los usua rios (programas o usuarios directos) \nver\u00e1n la BD mediante esquemas externos apropiados a sus necesidades. Estos \nesquemas se pueden considerar redefi niciones del esquema conceptual, con \nlas partes y los t\u00e9rminos que convengan para las ne cesidades de las aplicacio -\nnes (o grupos de aplicaciones). Algunos sistemas los denominan subesquemas .En el esquema conceptual  se describir\u00e1n las entidades tipo, sus atribu -\ntos, las interrelaciones y las rest ricciones o reglas de integridad.Nota\nEs preciso ir con cuidado para \nno confundir los niveles que  \nse describen aqu\u00ed con los  \ndescritos en el caso de los  \nficheros, aunque reciban  \nel mismo nombre.\nEn el caso de las BD, el esquema \ninterno corresponde a la parte f\u00edsica, y el externo a la l\u00f3gica; en el caso de los ficheros,  \nsucede lo contrario.\n\uf8e9 FUOC \u2022 71Z799014MO 24 Introducci\u00f3n a las bases de datos\nEjemplo de esquema externo\nImaginemos una BD que en el esquema conceptu al tiene definida, entre muchas otras, una \nentidad alumno  con los siguientes atributos: numatri, nombre, apellido, numDNI, direccion, fe -\nchanac, telefono . Sin embargo, nos puede interesar que unos determinados programas o usua -\nrios vean la BD formada de acuerdo con un esquema externo que tenga definidas dos \nentidades, denominadas estudiante y persona .\na)La entidad estudiante  podr\u00eda tener definido el atributo numero-matricula  (definido como \nderivable directamente de numatri ), el atributo nombre-pila  (de nombre ), el atributo apellido  y \nel atributo DNI (de numDNI ).\nb)La entidad persona  podr\u00eda tener el atributo DNI (obtenido de numDNI ), el atributo nombre\n(formado por la concatenaci\u00f3n de nombre  y apellido ), el atributo direccion  y el atributo edad\n(que deriva din\u00e1micamente de fechanac ).\nEl esquema de nivel interno responde a las cuestiones de re ndimiento (espacio \ny tiempo) planteadas al hacer el dise\u00f1o f\u00edsico de la BD y al ajustarlo*  posterior -\nmente a las necesi dades cambiantes.\nDe acuerdo con la arquitectura ANSI/SPARC, para crear una BD hace falta de -\nfinir previamente su esquema conceptu al, definir como m\u00ednimo un esquema \nexterno y, de forma eventual, definir su esquema interno. Si este \u00faltimo esque -\nma no se define, el mismo SGBD tendr\u00e1 que decidir los detalles de la organi -\nzaci\u00f3n f\u00edsica. El SGBD se encargar\u00e1 de hacer las correspondencias ( mappings ) \nentre los tres niveles de esquemas.\nEsquemas y niveles en los SGBD relacionales\nEn los SGBD relacionales (es decir, en el mundo de SQL) se utiliza una terminolog\u00eda ligera -\nmente diferente. No se separan de forma clara tre s niveles de descripci\u00f3n. Se habla de un solo \nesquema \u2013 schema\u2013 , pero en su interior se incluyen desc ripciones de los tres niveles. En el \nschema  se describen los elementos de aquello que en la arquitectura ANSI/SPARC se denomi -\nna esquema conceptua l (entidades tipo, atributos y restricciones) y las vistas \u2013 view\u2013 , que corres -\nponden aproximadamente a los esquemas externos.\nEl modelo relacional en que est\u00e1 inspirado SQL se limita al mundo l\u00f3gico. Por ello, el es -\nt\u00e1ndar ANSI-ISO de SQL no habla en absoluto del mundo f\u00edsico o interno; lo deja en ma -\nnos de los SGBD relacionales del mercado.  Sin embargo, estos SGBD proporcionan la \nposibilidad de incluir dentro del schema  descripciones de estructuras y caracter\u00edsticas f\u00ed -\nsicas (\u00edndice, tablespace , cluster , espacios para excesos, etc.).Al definir un esquema externo , se citar\u00e1n s\u00f3lo aquellos atributos y \naquellas entidades que interesen; lo s podremos redenominar, podremos \ndefinir datos derivados o redefinir un a entidad para que las aplicaciones \nque utilizan este esquema externo crean que son dos, definir combina -\nciones de entidades para que parezcan una sola, etc.\nEl esquema interno  o f\u00edsico contendr\u00e1 la descripci\u00f3n de la organiza -\nci\u00f3n f\u00edsica de la BD: ca minos de acceso (\u00edndices, hashing , apuntado -\nres, etc.), codificaci\u00f3n de los datos,  gesti\u00f3n del espaci o, tama\u00f1o de la \np\u00e1gina, etc.\n* En ingl\u00e9s, el ajuste se conoce\ncon el nombre de tuning .\n\u00bfQu\u00e9 hay que hacer para crear \nuna BD?\uf8e9 FUOC \u2022 71Z799014MO 25 Introducci\u00f3n a las bases de datos\n4.2. Independencia de los datos\nEn este subapartado  veremos c\u00f3mo la arquitectura de tres niveles que acaba -\nmos de presentar nos proporciona los dos tipos de independencia de los datos: \nla f\u00edsica y la l\u00f3gica. \nDe acuerdo con la arquitectura ANSI/SPARC, habr\u00e1 independencia f\u00edsica cuan -\ndo los cambios en el esquema interno no  afecten al esquema conceptual ni a \nlos esquemas externos.\nFigura 5\nEs obvio que cuando cambiemos unos datos de un soporte a otro, o los cam -\nbiemos de lugar dentro de un soporte, no se ver\u00e1n afectados ni los programas \nde aplicaci\u00f3n ni los usuarios directos, ya que no se modificar\u00e1 el esquema con -\nceptual ni el externo. Sin embargo, ta mpoco tendr\u00edan que verse afectados si \ncambi\u00e1semos, por ejemplo, el m\u00e9todo de acceso a unos registros determina -\ndos*, el formato o la codificaci\u00f3n, etc. Ninguno de estos casos deber\u00eda afectar \nal mundo exterior, sino s\u00f3lo a la BD f\u00edsica, el esquema interno, etc.\nSi hay independencia f\u00edsica de los datos,  lo \u00fanico que variar\u00e1 al cambiar el es -\nquema interno son las correspondencias entre el esquema conceptual y el in -\nterno. Obviamente, la mayor\u00eda de los cambios del es quema interno obligar\u00e1n \na rehacer la BD real (la f\u00edsica). Hay independencia f\u00edsica  cuando los cambios en la organizaci\u00f3n f\u00edsica \nde la BD no afectan al mundo exteri or (es decir, los programas usuarios \no los usuarios directos).Los dos tipos de independencia  \nde los datos se han explicado  \nen el subapartado 3.2 de esta  \nunidad did\u00e1ctica.\n* Por ejemplo, eliminando un \u00edndice \nen \u00e1rbol-B o sustituy\u00e9ndolo\npor un hashing .\n\uf8e9 FUOC \u2022 71Z799014MO 26 Introducci\u00f3n a las bases de datos\nFigura 6\nDados los dos niveles l\u00f3gicos de la ar quitectura ANSI/SPA RC, diferenciaremos \nlas dos situaciones siguientes: \n1) Cambios en el esquema conceptual . Un cambio de este tipo no afectar\u00e1 \na los esquemas externos que no hagan re ferencia a las entidades o a los atribu -\ntos modificados.\n2) Cambios en los esquemas externos . Efectuar cambios en un esquema ex -\nterno afectar\u00e1 a los usuarios que utilic en los elementos modificados. Sin em -\nbargo, no deber\u00eda afectar a los dem\u00e1s usuarios ni al esquema conceptual, y \ntampoco, en consecuencia, al esquema interno y a la BD f\u00edsica.\nUsuarios no afectados por los cambios\nNotad que no todos los cambios de elementos de un esquema externo afectar\u00e1n a sus usua -\nrios. Veamos un ejemplo de ello: antes hemos visto que cuando elimin \u00e1bamos el atributo \napellido  del esquema conceptual, deb\u00edamos modifi car el esquema externo donde defin\u00edamos \nnombre , porque all\u00ed estaba definido como concatenaci\u00f3n de nombre  y apellido . Pues bien, un \nprograma que utilizase el atributo nombre  no se ver\u00eda afectado si modific\u00e1semos el esquema \nexterno de modo que nombre  fuese la concatenaci\u00f3n de nombre  y una cadena constante (por \nejemplo, toda en blanco). Como resultado, habr\u00eda desaparecido el apellido de nombre , sin que \nhubiera sido necesario modificar el programa.\nLos SGBD actuales proporcionan bastante  independencia l\u00f3gica, pero menos de \nla que har\u00eda falta, ya que las exigencias de cambios constantes en el SI piden gra -\ndos muy elevados de flexibilidad. Los sist emas de ficheros tradicionales, en cam -\nbio, no ofrecen ninguna independencia l\u00f3gica.Hay independencia l\u00f3gica  cuando los usuarios*  no se ven afectados \npor los cambios en el nivel l\u00f3gico.* Programas de aplicaci\u00f3n\no usuarios directos.\nSi eliminamos...\n... el atributo apellido , por \nejemplo, no se ver\u00e1n afectados los esquemas externos (ni los usuarios) que no hagan  \nreferencia a este atributo.  \nSi se alarga el atributo direcci\u00f3n  \nal esquema conceptual,  \nno ser\u00e1 necesa rio modificar  \nel esquema externo donde  \nse ha definido la direcci\u00f3n   \ny obviamente, tampoco  \nresultar\u00e1n afectados los  \nprogramas y los usuarios  \nque la utilicen.\uf8e9 FUOC \u2022 71Z799014MO 27 Introducci\u00f3n a las bases de datos\n4.3. Flujo de datos y de control\nPara entender el funcionamiento de un SGBD, a continuaci\u00f3n veremos los \nprincipales pasos de la ejecuci\u00f3n de un a consulta sometida al SGBD por un \nprograma de aplicaci\u00f3n. Explicaremos la s l\u00edneas generales del flujo de datos y \nde control entre el SGBD, los programas de usuario y la BD. \nRecordad que el SGBD, con la ayuda de l SO, lee p\u00e1ginas (bloques) de los so -\nportes donde est\u00e1 almace nada la BD f\u00edsica, y las lleva a un \u00e1rea de buffers  o me -\nmorias cach\u00e9 en la memoria principal.  El SGBD pasa registros desde los buffers\nhacia el \u00e1rea de trabajo del mismo programa.\nSupongamos que la consulta pide los datos del alumno que tiene un determi -\nnado DNI. Por lo tanto, la  respuesta que el programa obtendr\u00e1 ser\u00e1 un solo re -\ngistro y lo recibir\u00e1 dentro de un \u00e1rea de trabajo propia*.\nFigura 7\nEl proceso que se sigue es el siguiente: \na)Empieza con una llamada (1) del programa  al SGBD, en la que se le env\u00eda \nla operaci\u00f3n de consulta. El SGBD debe ve rificar que la sintaxis de la operaci\u00f3n \n* Por ejemplo, una variable \ncon estructura de tupla.\nEjecuci\u00f3n de una consulta\nEn la figura vemos representa-\nda la BD, los tres niveles  \nde esquemas, el \u00e1rea de los  \nbuffers , el SGBD y el programa \nde aplicaci\u00f3n que le hace  \nla consulta.\n\uf8e9 FUOC \u2022 71Z799014MO 28 Introducci\u00f3n a las bases de datos\nrecibida sea correcta, que el usuario de l programa est\u00e9 auto rizado a hacerla, \netc. Para poder llevar a cabo todo esto, el SGBD se basa (2) en el esquema ex -\nterno con el que trabaja el progra ma y en el esquema conceptual.\nb)Si la consulta es v\u00e1lida, el SGBD determina, consultando el esquema interno \n(3), qu\u00e9 mecanismo debe seguir para re sponderla. Ya sabemos que el programa \nusuario no dice nada respecto a c\u00f3mo se  debe hacer f\u00edsicamente la consulta. Es \nel SGBD el que lo debe determinar. Casi  siempre hay varias formas y diferentes \ncaminos para responder a una consulta*. Supongamos que ha elegido aplicar un \nhashing al valor del DNI, que es el par\u00e1metro de la consulta, y el resultado es la \ndirecci\u00f3n de la p\u00e1gina donde se encuentra (entre muchos otros) el registro del \nalumno buscado.\nc)Cuando ya se sabe cu\u00e1l es la p\u00e1gina, el SGBD comprobar\u00e1 (4) si por suerte \nesta p\u00e1gina ya se encuentra en aquel momento en el \u00e1rea de los  buffers  (tal vez \ncomo resultado de una consulta anterior de  este usuario o de otro). Si no est\u00e1, \nel SGBD, con la ayuda del SO, la busca en disco y la carga en los buffers  (5). Si \nya est\u00e1, se ahorra el acceso a disco.\nd)Ahora, la p\u00e1gina deseada ya est\u00e1 en la memoria principal. El SGBD extrae, \nde entre los distintos registros que la p\u00e1gina puede contener, el registro bus -\ncado, e interpreta la codificaci\u00f3n y el resultado seg\u00fan lo que diga el esquema \ninterno.\ne)El SGBD aplica a los datos las eventual es transformaciones l\u00f3gicas que im -\nplica el esquema externo (tal vez cortan do la direcci\u00f3n por la derecha) y las \nlleva al \u00e1rea de trabajo del programa (6).\nf)A continuaci\u00f3n, el SGBD retorna el co ntrol al programa (7) y da por termi -\nnada la ejecuci\u00f3n de la consulta.* Por ejemplo, siempre tiene\nla posibilidad de hacer una \nb\u00fasqueda secuencial.\nDiferencias entre SGBD\nAunque entre diferentes SGBD \npuede haber enormes diferen-cias de funcionamiento, suelen seguir el esquema general  \nque acabamos de explicar.\uf8e9 FUOC \u2022 71Z799014MO 29 Introducci\u00f3n a las bases de datos\n5. Modelos de BD\nUna BD es una representaci\u00f3n de la realid ad (de la parte de la realidad que nos \ninteresa en nuestro SI). Dicho de otro  modo, una BD se puede considerar un \nmodelo de la realidad. El componente fundamental utilizado para modelar en \nun SGBD relacional son las tablas (denominadas relaciones  en el mundo te\u00f3ri -\nco). Sin embargo, en ot ros tipos de SGBD se ut ilizan otros componentes.\nTodo modelo de BD nos proporciona tres tipos de herramientas: \na) Estructuras de datos  con las que se puede construi r la BD: tablas, \u00e1rboles, etc.\nb)Diferentes tipos de restricciones (o reglas) de integridad  que el SGBD ten -\ndr\u00e1 que hacer cumplir a los datos: dominios, claves, etc.\nc)Una serie de operaciones  para trabajar con los da tos. Un ejemplo de ello, \nen el modelo relacional, es la operaci\u00f3 n SELECT, que sirve para seleccionar (o \nleer) las filas que cumplen alguna condic i\u00f3n. Un ejemplo de operaci\u00f3n t\u00edpica \ndel modelo jer\u00e1rquico y del modelo en red podr\u00eda ser la que nos dice si un de -\nterminado registro tiene \u201chijos\u201d o no.\nEvoluci\u00f3n de lo s modelos de BD\nDe los cuatro modelos de BD que hemo s citado, el que apareci\u00f3 primero, a \nprincipios de los a\u00f1os sesenta, fue el modelo jer\u00e1rquico . Sus estructuras son \nregistros interrelacionados en forma de \u00e1rboles. El SGBD cl\u00e1sico de este mode -\nlo es el IMS/DL1 de IBM.\nA principios de los setenta surgieron SGBD basados en un modelo en red . \nComo en el modelo jer\u00e1rquico, hay regist ros e interrelaciones, pero un registro \nya no est\u00e1 limitado a ser \u201chijo\u201d de un solo registro tipo. El comit\u00e9 CODASYL-\nDBTG propuso un est\u00e1ndar basado en este modelo, que fue adoptado por mu -\nchos constructores de SGBD*.  Sin embargo, encontr\u00f3 la  oposici\u00f3n de IBM, la \nempresa entonces dominante. La prop uesta de CODASYL-DBTG ya defin\u00eda \ntres niveles de esquemas.El conjunto de componentes o herramientas conceptuales que un \nSGBD proporciona para mode lar recibe el nombre de modelo de BD . \nLos cuatro modelos de  BD m\u00e1s utilizados en los SI son el modelo rela -\ncional , el modelo jer\u00e1rquico , el modelo en red  y el modelo relacional \ncon objetos .Las tablas o relaciones se estudiar\u00e1n \nen la unidad did\u00e1ctica \u201cEl modelo relacional y el \u00e1lgebra relacional\u201d  \nde este curso.\n\u00a1Cuidado  \ncon las confusiones!\nPopularmente, en especial  \nen el campo de la inform\u00e1tica personal, se denomina BD a lo \nque aqu\u00ed denominamos SGBD . \nTampoco se debe confundir  \nla BD considerada como  \nmodelo de la realidad con lo que aqu\u00ed denominamos mode-\nlo de BD. El modelo de BD es el \nconjunto de herramientas  \nconceptuales (piezas) que se utilizan para construir el  \nmodelo de la realidad.\n* Por ejemplo, IDS de Bull, DMS \nde Univac y DBMS de Digital.\uf8e9 FUOC \u2022 71Z799014MO 30 Introducci\u00f3n a las bases de datos\nDurante los a\u00f1os ochenta apareci\u00f3 una gran cantidad de SGBD basados en el \nmodelo relacional  propuesto en 1969 por E.F. Codd, de IBM, y pr\u00e1cticamente \ntodos utilizaban como lenguaje nativo el SQL**. El modelo relacional se basa \nen el concepto matem\u00e1tico de relaci\u00f3n , que aqu\u00ed podemos considerar de mo -\nmento equivalente al t\u00e9rmino tabla  (formada por filas y columnas). La mayor \nparte de los SI que actualmente est\u00e1n en funcionamiento utilizan SGBD rela -\ncionales, pero algunos siguen utilizando  los jer\u00e1rquicos o en red (especialmen -\nte en SI antiguos muy grandes).\nFigura 8\nAs\u00ed como en los modelos prerrelacionales  (jer\u00e1rquico y en red), las estructuras \nde datos constan de dos elementos b\u00e1sicos (los registros y las interrelaciones), \nen el modelo relacional constan de un solo elemento: la ta bla, formada por fi -\nlas y columnas. Las interre laciones se deben modelizar utilizando las tablas.\nOtra diferencia importante entre los mo delos prerrelacionales y el modelo re -\nlacional es que el modelo relacional se  limita al nivel l\u00f3gico (no hace absolu -\ntamente ninguna consideraci\u00f3n sobre las representaciones f\u00edsicas). Es decir, \nnos da una independencia f\u00edsica de datos total. Esto es as\u00ed si hablamos del mo -\ndelo te\u00f3rico, pero los SGBD del mercado nos prop orcionan una independen -\ncia limitada.\nEstos \u00faltimos a\u00f1os se est\u00e1 extendiendo el modelo de BD re lacional con ob -\njetos . Se trata de ampliar el modelo rela cional, a\u00f1adi\u00e9ndole la posibilidad de \nque los tipos de datos sean tipos abstractos de datos, TAD. Esto acerca los sis -\ntemas relacionales al paradigma de la  OO. Los primeros SGBD relacionales ** Por ejemplo, Oracle, DB2 de IBM, \nInformix, Ingres, Allbase de HP \ny SQL-Server de Sybase.\nEl modelo relacional se estudia con detalle en la unidad did\u00e1ctica \u201cEl modelo relacional y el \u00e1lgebra relacional\u201d  \nde este curso.\n\uf8e9 FUOC \u2022 71Z799014MO 31 Introducci\u00f3n a las bases de datos\nque dieron esta posibilidad fueron Oracle  (versi\u00f3n 8), Informix (versi\u00f3n 9) e \nIBM/DB2/UDB (versi\u00f3n 5).\nHablamos de modelos de BD, pero de  hecho se acostumbran a denominar \nmodelos de datos , ya que permiten modelarlos. Sin embargo, hay modelos de \ndatos que no son utilizados por los SGBD del mercado: s\u00f3lo se usan durante el \nproceso de an\u00e1lisis y dise\u00f1o, pero no en las realizaciones.\nLos m\u00e1s conocidos de estos tipo s de modelos son los modelos sem\u00e1nticos  y \nlos funcionales . \u00c9stos nos proporcionan herramientas muy potentes para des -\ncribir las estructuras de la informaci\u00f3 n del mundo real, la sem\u00e1ntica y las in -\nterrelaciones, pero normalmente no disponen de operaciones para tratarlas. Se \nlimitan a ser herramientas de  descripci\u00f3n l\u00f3gica. Son muy utilizados en la eta -\npa del dise\u00f1o de BD y en herramientas CASE. El m\u00e1s extendido de estos mo -\ndelos es el conocido como modelo ER  (entity-relationship ), que estudiaremos \nm\u00e1s adelante. \nActualmente, la pr\u00e1ctica m\u00e1s extendid a en el mundo profesional de los desa -\nrrolladores de SI es la utilizaci\u00f3n del mo delo ER durante el an\u00e1lisis y las prime -\nras etapas del dise\u00f1o de lo s datos, y la utilizaci\u00f3n de l modelo relacional para \nacabar el dise\u00f1o y construir la BD con un SGBD.\nEn esta asignatura hablamos s\u00f3lo de BD con modelos de datos estructurados, \nque son los que normalmente se utilizan en los SI empresariales. Sin embargo, \nhay SGBD especializados en tipos de aplicaciones concretas que no siguen \nninguno de estos modelos. Por ejemplo,  los SGBD documentales o los de BD \ngeogr\u00e1ficas. La evoluci\u00f3n  \nde los modelos...\n... a lo largo de los a\u00f1os los  \nha ido alejando del mundo  \nf\u00edsico y los ha acercado al  \nmundo l\u00f3gico; es decir, se han alejado de las m\u00e1quinas y se han acercado a las personas.\n\uf8e9 FUOC \u2022 71Z799014MO 32 Introducci\u00f3n a las bases de datos\n6. Lenguajes y usuarios\nPara comunicarse con el SGBD, el usuario, ya sea un programa de aplicaci\u00f3n \no un usuario directo, se vale de un le nguaje. Hay muchos lenguajes diferentes, \nseg\u00fan el tipo de usuarios para los que es t\u00e1n pensados y el tipo de cosas que los \nusuarios deben poder expresar con ellos:\na)Habr\u00e1 usuarios inform\u00e1ticos muy expe rtos que querr\u00e1n escribir procesos \ncomplejos y que necesita r\u00e1n lenguajes complejos.\nb)Sin embargo, habr\u00e1 usuarios finales no inform\u00e1ticos, ocasionales (espor\u00e1 -\ndicos), que s\u00f3lo har\u00e1n consultas. Estos usuarios necesitar\u00e1n un lenguaje muy \nsencillo, aunque d\u00e9 un rendimient o bajo en tiempo de respuesta.\nc)Tambi\u00e9n podr\u00e1 haber usuarios finales no inform\u00e1ticos, dedicados o especia -\nlizados. Son usuarios cotidianos o, incl uso, dedicados exclusivamente a trabajar \ncon la BD*. Estos usuarios necesitar\u00e1n lengua jes muy eficientes y compactos, \naunque no sea f\u00e1cil aprenderlos. Tal vez ser\u00e1n lenguajes especializados en tipos \nconcretos de tareas.\nEl lenguaje SQL , que es el m\u00e1s utilizado en las BD relacionales, tiene verbos \u2013ins -\ntrucciones\u2013 de tres tipos diferentes:\n1) Verbos del tipo DML ; por ejemplo, SELECT  para hacer consultas, e INSERT , \nUPDATE  y DELETE  para hacer el mantenimiento de los datos.\n2) Verbos del tipo DDL ; por ejemplo, CREATE TABLE  para definir las tablas, \nsus columnas y las restricciones.\n3)Adem\u00e1s, SQL tiene verbos de control del entorno , como por ejemplo \nCOMMIT  y ROLLBACK  para delimitar transacciones.Hay lenguajes especializados en la escr itura de esquemas; es decir, en la \ndescripci\u00f3n de la BD. Se conocen gen\u00e9ricamente como DDL  o data de -\nfinition language . Incluso hay lenguajes espec\u00ed ficos para esquemas inter -\nnos, lenguajes para esqu emas conceptuales y lenguajes para esquemas \nexternos.\nOtros lenguajes est\u00e1n espe cializados en la utilizac i\u00f3n de la BD (consul -\ntas y mantenimiento) . Se conocen como DML  o data management lan -\nguage . Sin embargo, lo m\u00e1s frecuente es que el mismo lenguaje disponga \nde construcciones para la s dos funciones, DDL y DML.\u00bfQu\u00e9 deber\u00eda poder decir \nel usuario al SGBD?\nPor un lado, la persona que \nhace el dise\u00f1o debe tener  \nla posibilidad de  describir al \nSGBD la BD que ha dise\u00f1ado. Por otro lado, debe ser posible pedirle al sistema que rellene  \ny actualice la base de datos  \ncon los datos que se le den. Adem\u00e1s, y obviamente,  \nel usuario debe disponer de medios para hacerle consultas.\n* Por ejemplo, personas dedicadas \na introducir datos masivamente.\nEl lenguaje SQL se explicar\u00e1 en la unidad did\u00e1ctica \u201cEl lenguaje SQL\u201d de este curso.\n\uf8e9 FUOC \u2022 71Z799014MO 33 Introducci\u00f3n a las bases de datos\nEn cuanto a los aspectos DML , podemos diferenciar do s tipos de lenguajes:\na)Lenguajes muy declarativos  (o impl\u00edcitos), con los que se especifica qu\u00e9 se \nquiere hacer sin explicar  c\u00f3mo se debe hacer.\nb)Lenguajes m\u00e1s expl\u00edcitos o procedimentales , que nos exigen conocer m\u00e1s \ncuestiones del funcionamiento del SGBD para detallar paso a paso c\u00f3mo se de -\nben realizar las operacio nes (lo que se denomina navegar  por la BD).\nComo es obvio, los aspectos DDL  (las descripciones de los datos) son siempre \ndeclarativos por su propia naturaleza.\nLos lenguajes utilizados en los SGBD prer relacionales eran procedimentales. SQL \nes b\u00e1sicamente declarativo, pero tiene posibilidades procedimentales.\nTanto los 4GL como las herramientas visuales (con frecuencia unidas en una \nsola herramienta) traducen lo que hace  el usuario a instrucciones SQL por dis -\ntintas v\u00edas:\n\u2022 En el caso de los 4GL, la traducci\u00f3n se suele hacer mediante la compilaci\u00f3n.\n\u2022 En el caso de las herramientas visuales , se efect\u00faa por medio del int\u00e9rprete \nde SQL integrado en el SGBD.\nSi queremos escribir un programa de  aplicaci\u00f3n que trabaje con BD, segura -\nmente querremos utilizar nuestro lenguaje habitual de programaci\u00f3n*. Sin \nembargo, generalmente estos lenguajes no  tienen instrucciones para realizar \nel acceso a las BD. Entonces tene mos las dos opciones siguientes: Aunque casi todos los SGBD del mercado tienen SQL como lenguaje na -\ntivo, ofrecen otras posi bilidades, como por ejem plo 4GL y herramientas \nvisuales:\n1)  Lenguajes 4GL  (4th Generation Languages )* de muy alto nivel, que \nsuelen combinar elementos proced imentales con elementos declarati -\nvos. Pretenden facilitar no s\u00f3lo el tr atamiento de la BD , sino tambi\u00e9n la \ndefinici\u00f3n de men\u00fas, pantallas y di\u00e1logos.\n2) Herramientas o interfaces visuales ** muy f\u00e1ciles de utilizar, que \npermiten usar las BD siguiendo el esti lo de di\u00e1logos con ventanas, iconos \ny rat\u00f3n, puesto de moda por las apli caciones Windows. No s\u00f3lo son \u00fatiles \na los usuarios no inform\u00e1ticos, sino que facilitan mucho el trabajo a los \nusuarios inform\u00e1ticos: pe rmiten consultar y actualizar la BD, as\u00ed como \ndefinirla y actualizar su definici \u00f3n con mucha facilidad y claridad.Lenguajes declarativos  \ny procedimentales\nEl aprendizaje y la utilizaci\u00f3n \nde los lenguajes procedimen-tales acostumbran a ser m\u00e1s  \ndif\u00edciles que los declarativos,  \ny por ello s\u00f3lo los utilizan  \nusuarios inform\u00e1ticos. Con  \nlos procedimentales se pueden escribir procesos m\u00e1s eficientes que con los declarativos.\n* Empezaron a aparecer al final \nde los a\u00f1os ochenta.\n** Han proliferado en los a\u00f1os \nnoventa.\n* Pascal, C, Cobol, PL/I, Basic, \nMUMPS, Fortran, Java, etc.\n\uf8e9 FUOC \u2022 71Z799014MO 34 Introducci\u00f3n a las bases de datos\n1)Las llamadas a funciones : en el mercado hay librer\u00edas de funciones espe -\ncializadas en BD (por ejem plo, las librer\u00edas ODBC). S\u00f3lo es preciso incluir lla -\nmadas a las funciones deseadas dentro del programa escrit o con el lenguaje \nhabitual. Las funciones ser\u00e1n las que se encargar\u00e1n de enviar las instrucciones \n(generalmente en SQL) en ti empo de ejecuci\u00f3n al SGBD.\n2)El lenguaje hospedado : otra posibilidad consiste  en incluir directamente \nlas instrucciones del lengua je de BD en nuestro programa. Sin embargo, esto \nexige utilizar un precompilador especia lizado que acepte en nuestro lenguaje \nde programaci\u00f3n habitual las instruccio nes del lenguaje de  BD. Entonces se \ndice que este lenguaje (casi siempre SQ L) es el lenguaje hospedado o incorpo -\nrado ( embedded ), y nuestro lenguaje de programaci\u00f3n (Pascal, C, Cobol, etc.) \nes el lenguaje anfitri\u00f3n ( host).\uf8e9 FUOC \u2022 71Z799014MO 35 Introducci\u00f3n a las bases de datos\n7. Administraci\u00f3n de BD\nLos administradores de BD  son los responsables de l correcto funcionamiento \nde la BD y velan para que siempre se ma ntenga \u00fatil. Intervienen en situaciones \nproblem\u00e1ticas o de emergenc ia, pero su responsabilid ad fundamental es velar \npara que no se produzcan incidentes.\nA continuaci\u00f3n damos una lista de tareas t\u00edpicas del ABD: \n1)Mantenimiento, administraci\u00f3n y cont rol de los esquem as. Comunicaci\u00f3n \nde los cambios a los usuarios.\n2)Asegurar la m\u00e1xima disponibilidad de  los datos; por ejemplo, haciendo co -\npias ( back-ups ), administrando diarios ( journals  o logs), reconstruyendo la BD, etc.\n3)Resoluci\u00f3n de emergencias.\n4)Vigilancia de la integridad y de la calidad de los datos.\n5)Dise\u00f1o f\u00edsico, estrategia de camino s de acceso y reestructuraciones.\n6)Control del rendimiento y decisiones relativas a la s modificaciones en los \nesquemas y/o en los par\u00e1metros de l SGBD y del SO, para mejorarlo.\n7)Normativa y asesoramiento a los programadores y a los usuarios finales so -\nbre la utilizaci\u00f3n de la BD.\n8)Control y administraci\u00f3n de la segurida d: autorizaciones, restricciones, etc.\nLa tarea del ABD no es sencilla.\nLos SGBD del mercado procuran reducir al m\u00ednimo  el volumen de estas tareas, pero en siste -\nmas muy grandes y cr\u00edticos se llega a tener gr upos de ABD de m\u00e1s de diez personas. Buena \nparte del software  que acompa\u00f1a el SGBD est\u00e1 orientado a facilitar la gran diversidad de tareas \ncontroladas por el ABD: monitores del rendimient o, monitores de la se guridad, verificadores \nde la consistencia entre \u00edndices y datos, reorganizadore s, gestores de las copias de seguridad, \netc. La mayor\u00eda de estas herramie ntas tienen interfaces visuales para facilitar la tarea del ABD.Hay un tipo de usuario especial: el que realiza tareas de administraci\u00f3n \ny control de la BD. Una empresa o in stituci\u00f3n que tenga SI construidos \nen torno a BD necesita que alguien lleve a cabo una serie de funciones \ncentralizadas de gesti\u00f3n y administra ci\u00f3n, para asegurar que la explota -\nci\u00f3n de la BD es la correcta. Este conjunto de funcio nes se conoce con \nel nombre de administraci\u00f3n de BD (ABD) , y los usuarios que hacen \neste tipo especial de trabajo se denominan administradores de BD .\n\uf8e9 FUOC \u2022 71Z799014MO 36 Introducci\u00f3n a las bases de datos\nResumen\nEn esta unidad hemos hecho una introd ucci\u00f3n a los conceptos fundamentales \ndel mundo de las BD y de los SGBD. He mos explicado la ev oluci\u00f3n de los SG -\nBD, que ha conducido de una estructura centralizada y poco flexible a una dis -\ntribuida y flexible, y de una utilizaci\u00f3 n procedimental que requer\u00eda muchos \nconocimientos a un uso declarativo y sencillo.\nHemos revisado los objetivos de los SGBD actuales  y algunos de los servicios\nque nos dan para conseguirlos. Es espe cialmente importante el concepto de \ntransacci\u00f3n  y la forma en que se utiliza para velar por la integridad de los datos.\nLa arquitectura de tres niveles  aporta una gran flexibilidad a los cambios, \ntanto a los f\u00edsicos como a los l\u00f3gicos.  Hemos visto c\u00f3mo un SGBD puede fun -\ncionar utilizando los tres esquemas  propios de esta  arquitectura.\nHemos explicado que los componentes de un modelo de BD  son las estruc -\nturas, las restricciones y las operaciones.  Los diferentes modelos de BD se dife -\nrencian b\u00e1sicamente por sus estructura s. Hemos hablado de los modelos m\u00e1s \nconocidos, especialmente del modelo relacional, que est\u00e1 basado en tablas y que estudiaremos m\u00e1s adelante.\nCada tipo de usuario del SGBD puede utilizar un leng uaje apropiado para su \ntrabajo. Unos usuarios con una tarea importante y dif\u00edcil son los administra -\ndores de las BD .El modelo relacional se estudiar\u00e1 en \nla unidad\u201cEl modelo relacional y el \u00e1lgebra relacional\u201d de este curso.\n\uf8e9 FUOC \u2022 71Z799014MO 37 Introducci\u00f3n a las bases de datos\nActividades\n1.Comparad  la lista de los objetivos de los SGBD qu e hemos dado aqu\u00ed con la que se da en \notros libros, y haced otra lista co n las diferencias que encontr\u00e9is.\n2.Buscad informaci\u00f3n t\u00e9cnica y comercial de lo s fabricantes de SGBD sobre sus productos y \na partir de aqu\u00ed intentad reconocer los conc eptos que hemos introducido en esta unidad.\n3.Leed alg\u00fan informe \u201cEstado de l arte\u201d sobre SGBD de los que se publican (normalmente \ncada a\u00f1o) en la revista Byte y en Datamation .\nEjercicios de autoevaluaci\u00f3n\n1.\u00bfQu\u00e9 ventajas aportaron los SGBD relacion ales con respecto a los prerrelacionales?\n2.Para mejorar la disponibilidad y el coste, hemos decidido que una cierta parte de una BD \nque est\u00e1 situada en el ordenador central de la  empresa estar\u00e1 duplicada (replicada) en un or -\ndenador situado en una oficina alejada (conecta do permanentemente por v\u00eda telef\u00f3nica). Los \nprogramas que actualizan la BD, \u00bftendr\u00edan que preocuparse de ac tualizar tambi\u00e9n la r\u00e9plica? \n\u00bfPor qu\u00e9?\n3.Hemos programado una transacci\u00f3n para consultar cu\u00e1ntos alumnos cursan una asigna -\ntura. Si este n\u00famero es inferior a quince, se nos informar\u00e1 de cu\u00e1ntos hay y en una lista, en \nuna hoja de papel o en la pantalla nos aparecer \u00e1n todos ellos. Sin embargo, si es superior o \nigual a quince, simplemente dir\u00e1 cu\u00e1ntos hay. Supongamos que de forma concurrente con esta transacci\u00f3n se podr\u00e1n esta r ejecutando otras que inserten  nuevos alumnos o que los su\n-\npriman. \u00bfQu\u00e9 problema se  podr\u00e1 producir si el SGBD no a\u00edsla totalmente las transacciones?\n4.De las siguientes afirmaciones, decid cu\u00e1les son ciertas y cu\u00e1les son falsas:\na)El modelo ER es m\u00e1s conocido como modelo relacional .\nb)Los SGBD no permiten la redundancia.\nc)El DML es un lenguaje declarativo.\nd)El DDL es un lenguaje pensado para escribir programas de consulta y actualizaci\u00f3n de BD.\ne)En un ordenador que act\u00faa como servidor de BD, con dos RAID y tres discos duros y con \nun SGBD actual, no es necesario que los encarg ados de realizar los programas para consultar \nesta BD sepan en qu\u00e9 discos est\u00e1.\nf)Cuando un programa quiere acceder a unos dato s mediante un \u00edndice, lo debe decir al SGBD.Lectura recomendada\nConsultad las obras de la \nbibliograf\u00eda que encontrar\u00e9is al final de esta unidad.\uf8e9 FUOC \u2022 71Z799014MO 38 Introducci\u00f3n a las bases de datos\nSolucionario\nEjercicios de autoevaluaci\u00f3n\n1.Los SGBD relacionales aporta ron una programaci\u00f3n m\u00e1s sencilla: los lenguajes son m\u00e1s \nsencillos y no dependen tanto de las caracter\u00edsticas f\u00edsicas de la BD. Se da m\u00e1s flexibilidad a los cambios (m\u00e1s independencia f\u00edsica de los datos). El programador se debe preocupar mu\n-\ncho menos de las cuestiones de rendimiento, pues  de ello ya se ocupa el SGBD. Incluyen len -\nguajes declarativos de consulta para usuarios no inform\u00e1ticos.\n2.Si la actualizaci\u00f3n no se hace  en los dos lugares, la redundancia nos puede comportar proble -\nmas de consistencia de los datos.  El administrador de la BD de ber\u00eda poder describir qu\u00e9 quiere \nque est\u00e9 replicado y c\u00f3mo quiere que se haga el  mantenimiento de la r\u00e9 plica. El SGBD deber\u00eda \nencargarse de mantener la r\u00e9plica actualizada corre ctamente. Si la actualizaci\u00f3n de la r\u00e9plica la \ntuviesen que hacer los programas de aplicaci\u00f3n, podr\u00eda suceder que alguno de ellos no lo hiciese, o incluso que la actualizaci\u00f3n la hiciese (mal) un usuario directo, sin escribir un programa.\nY todav\u00eda m\u00e1s, los programas de aplicaci\u00f3n y los us uarios directos deber\u00edan  ser totalmente ajenos \na estos temas f\u00edsicos (rendimiento, disponibilidad, etc.), ya que de este modo se podr\u00edan cambiar \nlas decisiones, como por ejemplo variar la pol\u00edtica  de r\u00e9plicas, sin que se tuviesen que modificar \nlos programas ni avisar a nadie. Simplemente debe  intervenir el ABD mediante el lenguaje de \ndescripci\u00f3n del nivel f\u00edsico. Actualmente, los SG BD del mercado ya dan este nivel de indepen -\ndencia.\n3.Supongamos que la transacci\u00f3n consulta al SG BD cu\u00e1ntos alumnos hay, y el SGBD cuenta \ntrece. El programa preparar\u00e1 una l\u00ednea de cabecera de list a que indique que hay trece alum -\nnos, y a continuaci\u00f3n los most rar\u00e1. Sin embargo, entre el mo mento en que fabrica esta cabe -\ncera y el momento de empezar a leer a los alumnos uno por uno para mostrarlos, otras \ntransacciones (que se ejecutan concurrentemente con \u00e9sta) eliminan a dos alumnos. Enton -\nces, el programa nos mostrar\u00e1 s\u00f3lo a on ce, a pesar de que hab\u00eda anunciado trece.\nY si las transacciones concurrentes que hacen actualizaciones hubiesen insertado tres alum -\nnos, la cabecera dir\u00eda que hay trece, y mostrar\u00ed a en realidad diecis\u00e9is (\u00a1y no tendr\u00eda que mos -\ntrar nunca m\u00e1s de quince!).\nEstos problemas de concurrencia pueden surgir si el SGBD no lleva un control que evite las \ninterferencias.\n4. a)  Falsa, b) Falsa, c) Falsa, d) Falsa, e) Cierta, f) Falsa.\nGlosario\nadministrador de BD\nTipo de usuario especial que realiza funciones de  administraci\u00f3n y control de la BD, que ase -\nguran que la explotaci\u00f3n de la BD es correcta.\nbase de datos \nConjunto estructurado de datos que representa  entidades y sus interrelaciones. La represen -\ntaci\u00f3n ser\u00e1 \u00fanica e integrada, a pesar de que debe permitir diversas utilizaciones.\nsigla:  BD\nBD\nVed: base de datos .\ncliente/servidor \nTecnolog\u00eda habitual para distribu ir datos. La idea es que dos procesos diferentes, que se pue -\nden ejecutar en un mismo sistema o en sistem as separados, act\u00faan de modo que uno act\u00faa \nde cliente o peticionario de un servicio y el  otro, como servidor. Un proceso cliente puede \npedir servicios a distintos servidores. Un servid or puede recibir petici ones de muchos clien -\ntes. En general, un proceso A que act\u00faa como cliente pidiendo  un servicio a otro proceso B\npuede hacer tambi\u00e9n de servidor de un  servicio que le pida otro proceso C.\nsigla:  C/S\nC/S\nVed:  cliente/servidor .\ndata definition language\nLenguaje especializado en la escritura de esquemas; es deci r, en la descripci\u00f3n de BD.\nSigla:  DDL\ndata manipulation language\nLenguaje especializado en la utilizaci\u00f3n de BD (consultas y mantenimiento).\nSigla:  DML\uf8e9 FUOC \u2022 71Z799014MO 39 Introducci\u00f3n a las bases de datos\nDDL\nVed:  data definition language.\nDML\nVed:  data manipulation language .\nesquema\nDescripci\u00f3n o definici\u00f3n de la BD. Esta descripci\u00f3 n est\u00e1 separada de los programas y es utilizada \npor el SGBD para saber c\u00f3mo es la BD con la que debe trabajar. La ar quitectura ANSI/SPARC \nrecomienda tres niveles de esquem as: el externo (visi\u00f3n de los us uarios), el conceptual (visi\u00f3n \nglobal) y el f\u00edsico (descripci\u00f3n de caracter\u00edsticas f\u00edsicas).\nSGBD\nVed:  sistema de gesti\u00f3n de BD .\nsistema de gesti\u00f3n de BD\nSoftware que gestiona y controla BD. Sus principales funciones son facilitar la utilizaci\u00f3n de \nla BD a muchos usuarios simult\u00e1neos y de tipos  diferentes, independiz ar al usuario del mun -\ndo f\u00edsico y mantener la integridad de los datos.\nsigla:  SGBD\nSQL\nVed:  structured query language .\nstructured query language\nLenguaje especializado en la descripci\u00f3n (DDL) y la utilizaci\u00f3n (DML) de BD relacionales. \nCreado por IBM al final de los a\u00f1os setenta y estandarizado por ANSI-ISO  en 1985 (el \u00faltimo \nest\u00e1ndar de SQL es de 1999). En la actualidad  lo utilizan pr\u00e1cticamente todos los SGBD del \nmercado.\nsigla:  SQL\ntransacci\u00f3n\nConjunto de operaciones (de BD) que queremos que se ejecuten como un todo (todas o ninguna) \ny de forma aislada (sin interferencias) de otros conjuntos de operaciones que se ejecuten concu -\nrrentemente.\nBibliograf\u00eda\nBibliograf\u00eda b\u00e1sica\nDate, C.J. (2001). Introducci\u00f3n a los sistemas de bases de datos (7\u00aa ed.). Prentice Hall.\nSilberschatz, A; Korth, H.F; Sudarshan, S.  (1998). Fundamentos de bases de datos  (3.a ed.). \nMadrid: McGraw-Hill.\nLa introducci\u00f3n de este libro es similar a la que hemos hecho aqu\u00ed.\nBibliograf\u00eda complementaria\nPara actualizar vuestra visi\u00f3n global de los SGBD del mercado, pod\u00e9is consultar en Internet \nlas p\u00e1ginas de los fabricantes de SGBD; por ejemplo:\n\u2022I n f o r m i x : http://www.informix.com \n\u2022O r a c l e : http://www.oracle.com \n\u2022I B M : http://www.ibm.com \n\u2022 Computer Associates : http://www.ca.com \n\u2022M i c r o s o f t : http://www.microsoft.com \n\u2022N C R : http://www.ncr.com El modelo \nrelacional \ny el \u00e1lgebra \nrelacional\nDolors Costal Costa\n\uf8e9 FUOC \u2022 71Z799014MO El modelo relacional y el \u00e1lgebra relacional\n\u00cdndice\nIntroducci\u00f3n ............................................................................................... 5\nObjetivos ...................................................................................................... 6\n1. Introducci\u00f3n al modelo relacional .................................................. 7\n2. Estructura de los datos ....................................................................... 9\n2.1. Visi\u00f3n informal de una relaci\u00f3n........................................................ 92.2. Visi\u00f3n formal de una relaci\u00f3n........................................................... 10\n2.3. Diferencias entre relaciones y ficheros.............................................. 12\n2.4. Clave candidata, clave primaria y clave alternativa \nde las relaciones................................................................................. 14\n2.5. Claves for\u00e1neas de las relaciones....................................................... 152.6. Creaci\u00f3n de las relaciones de una base de datos............................... 18\n3. Operaciones del modelo relacional ................................................. 19\n4. Reglas de integridad ............................................................................ 21\n4.1. Regla de integridad de unicidad de la clave primaria ....................... 22\n4.2. Regla de integridad de entidad de la clave primaria ......................... 234.3. Regla de integridad referencial .......................................................... 24\n4.3.1. Restricci\u00f3n.............................................................................. 264.3.2. Actualizaci\u00f3n en cascada........................................................ 274.3.3. Anulaci\u00f3n............................................................................... 29\n4.3.4. Selecci\u00f3n de la po l\u00edtica de mantenimiento \nde la integridad referencial .................................................... 30\n4.4. Regla de integridad de dominio ........................................................ 31\n5. El \u00e1lgebra relacional ........................................................................... 33\n5.1. Operaciones conjuntistas .................................................................. 36\n5.1.1. Uni\u00f3n ..................................................................................... 365.1.2. Intersecci\u00f3n............................................................................ 38\n5.1.3. Diferencia ............................................................................... 39\n5.1.4. Producto cartesiano................................................................ 40\n5.2. Operaciones espec\u00edficamente relacionales ........................................ 41\n5.2.1. Selecci\u00f3n................................................................................. 415.2.2. Proyecci\u00f3n.............................................................................. 425.2.3. Combinaci\u00f3n ......................................................................... 43\n5.3. Secuencias de operaciones del \u00e1lgebra relacional ............................. 46\n5.4. Extensiones: combinaciones externas............................................... 47\uf8e9 FUOC \u2022 71Z799014MO El modelo relacional y el \u00e1lgebra relacional\nResumen ....................................................................................................... 51\nEjercicios de autoevaluaci\u00f3n .................................................................. 53\nSolucionario ................................................................................................ 55\nGlosario ........................................................................................................ 56\nBibliograf\u00eda ................................................................................................. 58\uf8e9 FUOC \u2022 71Z799014MO 5 El modelo relacional y el \u00e1lgebra relacional\nIntroducci\u00f3n\nEsta unidad did\u00e1ctica est\u00e1 dedicada al estudio del modelo de datos relacional\ny del \u00e1lgebra relacional.\nEl concepto de modelo de datos  se ha presentado en otra unidad did\u00e1ctica. En\n\u00e9sta se profundiza en un modelo de datos concreto: el modelo relacional , que\nactualmente tiene una gran relevancia . Sus conceptos fundamentales est\u00e1n\nbien asentados y, adem\u00e1s, los sistemas de gesti\u00f3n de bases de datos relaciona-\nles son los m\u00e1s extendidos en su utiliz aci\u00f3n pr\u00e1ctica. Por estos motivos pensa-\nmos que es importante conocerlo.\nEl estudio del modelo relacional sirve, adem\u00e1s, de base para los contenidos de\notra unidad, dedicada al lenguaje SQL.  Este lenguaje permite definir y mani-\npular bases de datos relacionales. Los fundamentos del modelo relacional re-\nsultan imprescindibles para cons eguir un buen dominio del SQL.\nEn esta unidad se analizan tambi\u00e9n las operaciones del \u00e1lgebra relacional ,\nque sirven para hacer consultas a una base de datos. Es preciso conocer estasoperaciones porque nos permiten saber qu \u00e9 servicios de consulta debe propor-\ncionar un lenguaje relacional. Otra apor taci\u00f3n del \u00e1lgebra relacional es que fa-\ncilita la comprensi\u00f3n de algunas de las construccion es del lenguaje SQL que\nse estudiar\u00e1n en otra unidad did\u00e1ctica de este curso. Adem\u00e1s, constituye la\nbase para el estudio del tratamiento de las consultas que efec t\u00faan los SGBD in-\nternamente (especialmente en lo que resp ecta a la optimizaci\u00f3n de consultas).\nEste \u00faltimo tema queda fuera del \u00e1mbito del presente curso, pero es relevante\npara estudios m\u00e1s avanzados sobre bases de datos.Consultad el concepto\nde modelo de datos  en la unidad \ndid\u00e1ctica \u201cIntroducci\u00f3n a las bases de datos\u201d de este curso.\nLas construcciones del SQL se estudian en la unidaddid\u00e1ctica \u201cEl lenguaje SQL\u201d.\n\uf8e9 FUOC \u2022 71Z799014MO 6 El modelo relacional y el \u00e1lgebra relacional\nObjetivos\nEn los materiales did\u00e1cticos de esta unidad encontrar\u00e9is las herramientas in-\ndispensables para alcanzar los siguientes objetivos:\n1.Conocer los fundamentos del mo delo de datos relacional.\n2.Saber distinguir las caract er\u00edsticas que debe tener un sistema de gesti\u00f3n de\nbases de datos relacional para que sea coherente con los fundamentos del\nmodelo relacional.\n3.Comprender las ventajas del modelo re lacional que derivan del alto grado\nde independencia de los datos que pr oporciona, y de la simplicidad y la\nuniformidad del modelo.\n4.Conocer las operaciones del \u00e1lgebra relacional.\n5.Saber utilizar las operacio nes del \u00e1lgebra relacional  para consultar una base\nde datos.\uf8e9 FUOC \u2022 71Z799014MO 7 El modelo relacional y el \u00e1lgebra relacional\n1. Introducci\u00f3n al modelo relacional\nUn sistema de gesti\u00f3n de ba ses de datos relacional (SGBDR) da apoyo a la\ndefinici\u00f3n de datos mediante la estructura de los datos del modelo relacional,as\u00ed como a la manipulaci\u00f3n de estos datos con las operaciones del modelo;\nadem\u00e1s, asegura que se satisfacen las regl as de integridad que el modelo rela-\ncional establece.\nLos principios del modelo de datos relaci onal fueron establecidos por E.F. Codd\nen los a\u00f1os 1969 y 1970. De todos modos, hasta la d\u00e9cada de los ochenta no se\nempezaron a comercializar los primeros  SGBD relacionales con rendimientos\naceptables. Cabe se\u00f1alar que los SGBD re lacionales que se comercializan actual-\nmente todav\u00eda no soportan todo lo que esta blece la teor\u00eda relacional hasta el \u00fal-\ntimo detalle.\nEl principal objetivo del modelo de datos relacional es facilitar que la base de\ndatos sea percibida o vista por el usuario como una estructura l\u00f3gica que consis-\nte en un conjunto de relaciones y no como una estructura f\u00edsica de implemen-\ntaci\u00f3n. Esto ayuda a conseguir un alto  grado de independencia de los datos.\nUn objetivo adicional de l modelo es conseguir que esta estructura l\u00f3gica\ncon la que se percibe la base de datos  sea simple y uniforme. Con el fin de\nproporcionar simplicidad y uniformidad , toda la informaci\u00f3n se representa\nde una \u00fanica manera: mediante valore s expl\u00edcitos que contienen las rela-\nciones (no se utilizan conceptos como  por ejemplo apuntadores entre las\nrelaciones). Con el mismo prop\u00f3sito, todos los valo res de datos se conside-\nran at\u00f3micos; es decir, no es posible descomponerlos.\nHay que precisar que un SGBD relacional, en el nivel f\u00edsico, puede emplear\ncualquier estructura de da tos para implementar la es tructura l\u00f3gica formadaEl modelo relacional  es un modelo de datos y, como tal, tiene en cuen-\nta los tres aspectos si guientes de  los datos:\n1)La estructura , que debe permitir represen tar la informaci\u00f3n que nos\ninteresa del mundo real.\n2)La manipulaci\u00f3n , a la que da apoyo mediante las operaciones de ac-\ntualizaci\u00f3n y consul ta de los datos.\n3)La integridad , que es facilitada mediante el establecimiento de re-\nglas de integridad; es decir, cond iciones que los da tos deben cumplir.El concepto de modelo de datos  \nse ha explicado en la unidad did\u00e1ctica \u201cIntroducci\u00f3n a las basesde datos\u201dde este curso.\nEl concepto de SGBD  ha sido \npresentado en la unidad did\u00e1ctica \u201cIntroducci\u00f3n a las bases de datos\u201d de este curso.\n\uf8e9 FUOC \u2022 71Z799014MO 8 El modelo relacional y el \u00e1lgebra relacional\npor las relaciones. En part icular, a nivel f\u00edsico, el sistema puede utilizar apun-\ntadores, \u00edndices, etc. Sin embargo, esta implementaci \u00f3n f\u00edsica queda oculta al\nusuario.\nEn los siguientes apartados estudiaremos la  estructura de los datos, las operacio-\nnes y las reglas de integridad del modelo  relacional. Hay dos formas posibles de\nenfocar el estudio de los contenidos de este m\u00f3dulo. La primera consiste en se-guirlos en orden de exposici\u00f3n. De este modo, se van tratando todos los elemen-\ntos de la teor\u00eda del modelo relacional  de forma muy precisa y en un orden\nl\u00f3gico. Otra posibilidad, sin embargo, es  empezar con la lectura del resumen fi-\nnal del m\u00f3dulo y leer despu\u00e9s todo el re sto de los contenidos en el orden nor-\nmal. El resumen describe los aspectos m\u00e1s relevantes de la te or\u00eda relacional que\nse explican y, de este modo, proporci ona una visi\u00f3n global de los contenidos\ndel m\u00f3dulo que, para algunos estudiante s, puede ser \u00fatil comprender antes de\niniciar un estudio detallado. \n\uf8e9 FUOC \u2022 71Z799014MO 9 El modelo relacional y el \u00e1lgebra relacional\n2. Estructura de los datos\nLa estructura de los datos del modelo re lacional se basa, pues, en el concepto\nde relaci\u00f3n .\n2.1. Visi\u00f3n informal de una relaci\u00f3n\nEn primer lugar, presentaremos el concepto de relaci\u00f3n  de manera informal. Se\npuede obtener una buena idea intuitiva de lo que es una relaci\u00f3n si la visuali-\nzamos como una tabla o un fichero. En la figura 1 se muestra la visualizaci\u00f3ntabular de una relaci\u00f3n que contiene datos de empleados.  Cada fila de la tabla\ncontiene una colecci\u00f3n de valores de da tos relacionados entre s\u00ed; en nuestro\nejemplo, son los datos correspondientes a un mismo empleado. La tabla tieneun nombre ( EMPLEADOS ) y tambi\u00e9n tiene un nombre cada una de sus colum-\nnas (DNI, nombre, apellido  y sueldo ). El nombre de la ta bla y los de las columnas\nayudan a entender el significado de los valores que contiene la tabla. Cada co-\nlumna contiene valores de un cierto  dominio; por ejemplo, la columna DNI\ncontiene valores del dominio n\u00famerosDNI .\nFigura1El modelo relacional proporciona una estructura de los datos que con-\nsiste en un conjunto de relaciones con objeto de representar la informa-\nci\u00f3n que nos interesa del mundo real.\nConjunto de relaciones \nUna base de datos relacional \nconsta de un conjunto de relaciones, cada una de las cuales se puede visualizar de este modo tan sencillo. La estructura de los datos del modelo relacional resulta f\u00e1cil de entender para el usuario.\uf8e9 FUOC \u2022 71Z799014MO 10 El modelo relacional y el \u00e1lgebra relacional\nSi definimos las relaciones de forma m\u00e1 s precisa, nos daremos cuenta de que\npresentan algunas caracter\u00edsticas importan tes que, en la visi\u00f3n superficial que\nhemos presentado, quedan ocultas. Esta s caracter\u00edsticas son las que motivan\nque el concepto de relaci\u00f3n  sea totalmente diferente del de ficher o, a pesar de\nque, a primera vista, relaciones y ficheros puedan parecer similares.\n2.2. Visi\u00f3n formal de una relaci\u00f3n\nA continuaci\u00f3n definimos formalmente las relaciones y otros conceptos que\nest\u00e1n vinculados a ellas, como por ejemplo dominio, esquema de relaci\u00f3n , etc.\nLos dominios pueden ser de dos tipos: \n1) Dominios predefinidos , que corresponde a los tipos de datos que normal-\nmente proporcionan los lenguajes de bases de datos, como por ejemplo los en-teros, las cadenas de caracteres, los reales, etc.\n2) Dominios definido s por el usuario , que pueden ser m\u00e1 s espec\u00edficos. Toda\ndefinici\u00f3n de un dominio debe consta r, como m\u00ednimo, del nombre del domi-\nnio y de la descripci\u00f3n de los va lores que forman parte de \u00e9ste.\nSi consideramos la representaci\u00f3n tabu lar anterior (figura 1), el esquema co-\nrresponder\u00eda a la cabecera de la tabla y la extensi\u00f3n corresponder\u00eda al cuerpo:\nFigura 2Un dominio D es un conjunto de valores at\u00f3micos. Por lo que respecta\nal modelo relacional, at\u00f3mico significa indivisible; es decir, que por muy\ncomplejo o largo que sea un valor at\u00f3mico, no tiene una estructuraci\u00f3ninterna para un SGBD relacional.\nUn relaci\u00f3n  se compone del esquema  (o intensi\u00f3n de la relaci\u00f3n) y de\nla extensi\u00f3n .\nDominio definido\npor el usuario\nPor ejemplo, el usuario puede \ndefinir un dominio para las edades de los empleados que se denomine dom_edad  \ny que contenga los valores enteros que est\u00e1n entre 16 y 65.\nEmpleados\nDNI nombre apellido sueldo\n40.444.255 Juan Garc\u00eda 2.00033.567.711 Marta Roca 2.50055.898.425 Carlos Buend\u00eda 1.500Esquema\nExtensi\u00f3n\nEl esquema de la relaci\u00f3n  consiste en un nombre de relaci\u00f3n R y un\nconjunto de atributos { A1, A2, ..., An}.\uf8e9 FUOC \u2022 71Z799014MO 11 El modelo relacional y el \u00e1lgebra relacional\nNombre y conjunto de at ributos de la relaci\u00f3n EMPLEADOS\nSi tomamos como ejemplo la figura 1, el nombre de la relaci\u00f3n es EMPLEADOS  y el conjunto\nde atributos es { DNI, nombre, apellido, sueldo }.\nTomaremos la convenci\u00f3n de denotar el esquema de la relaci\u00f3n de la forma\nsiguiente: R( A1, A2, ..., An), donde R es el nombre la relaci\u00f3n y A1, A2, ..., An\nes una ordenaci\u00f3n cualquiera de los atributos que pertenecen al conjunto\n{A1, A2, ..., An}. \nDenotaci\u00f3n del esquema de la relaci\u00f3n EMPLEADOS\nEl esquema de la relaci\u00f3n de la figura 1 se pod r\u00eda denotar, por ejemplo, como EMPLEA-\nDOS(DNI, nombre, apellido, sueldo ), o tambi\u00e9n, EMPLEADOS (nombre, apellido, DNI, sueldo ),\nporque cualquier ordenaci\u00f3n de sus atributos se considera v\u00e1li da para denotar el esquema de\nuna relaci\u00f3n.\nDominio del atributo DNI\nSeg\u00fan la figura 1, el atributo DNI corresponde al papel que ejerce el dominio n\u00famerosDNI  en\nel esquema de la relaci\u00f3n EMPLEADOS  y, entonces, dominio( DNI) = n\u00famerosDNI .\nConviene observar que cada atributo es  \u00fanico en un esquema de relaci\u00f3n, por-\nque no tiene sentido que un mismo domi nio ejerza dos veces el mismo papel\nen un mismo esquema. Por consiguiente , no puede ocurrir que en un esquema\nde relaci\u00f3n haya dos atributos con el  mismo nombre. En cambio, s\u00ed que se\npuede repetir un nombre de atributo en  relaciones diferentes. Los dominios de\nlos atributos, por el contrario, no de ben ser necesariamen te todos diferentes\nen una relaci\u00f3n. \nEjemplo de atributos diferentes con el mismo dominio\nSi tomamos como ejemplo el esquema de relaci\u00f3n PERSONAS(DNI, nombre, apellido, telcasa,\nteltrabajo ), los atributos  telcasa  y teltrabajo  pueden tener el mismo dominio: dominio( telcasa )=\n= tel\u00e9fono y dominio( teltrabajo ) = tel\u00e9fono .\nEn este caso, el dominio tel\u00e9fono  ejerce dos papeles diferentes en el esquema de relaci\u00f3n: el\nde indicar el tel\u00e9fono particular de un a persona y el de indicar el del trabajo.\nPara simplificar, tomare mos la convenci\u00f3n de referirnos a una tupla ti = {<A1:vi1>,\n<A2:vi2>, ..., <An:vin>} que pertenece a la extensi\u00f3 n del esquema denotado como\nR(A1, A2, ..., An), de la forma siguiente: ti = <vi1, vi2, ..., vin>. Un atributo Ai es el nombre del papel que ejerce un dominio D en un es-\nquema de relaci\u00f3n. D es el dominio de Ai y se denota como dominio ( Ai).\nLa extensi\u00f3n de la relaci\u00f3n de esquema R( A1, A2, ..., An) es un con-\njunto de tuplas  ti (i = 1, 2, ..., m ), donde cada tupla  ti es, a su vez un con-\njunto de pares ti = {<A1:vi1>, <A2:vi2> ... >An:vin>} y, para cada par\n<Aj:vij>, se cumple que vij es un valor de dominio( Aj), o bien un valor\nespecial que denominaremos nulo.\nAlgunos autores...\n... denominan  tablas , columnas  \ny filas a las relaciones, los\natributos y las tuplas, respectivamente.\n\uf8e9 FUOC \u2022 71Z799014MO 12 El modelo relacional y el \u00e1lgebra relacional\nSi denotamos el esquema de la relaci\u00f3n representada en la figura 1 como EM-\nPLEADOS( DNI, nombre, apellido, sueldo ), el conjunto de tuplas de su extensi\u00f3n\nser\u00e1 el de la figura siguiente:\nFigura 3\nSi en una tupla ti = <vi1, vi2, ..., vin>, el valor vij es un valor nulo , entonces el\nvalor del atributo Aj es desconocido para la tupla ti de la relaci\u00f3n, o bien no es\naplicable a esta tupla.\nEjemplo de valor nulo\nPodr\u00edamos tener un atributo  telcasa  en la relaci\u00f3n EMPLEADOS  y se podr\u00eda dar el caso de que\nun empleado no tuviese tel\u00e9fono en su casa, o bien que lo tuviese, pero no se conociese su\nn\u00famero. En las dos situaciones, el valor del atributo telcasa  para la tupla correspondiente al\nempleado ser\u00eda el valor nulo.\nGrado de la relaci\u00f3n  EMPLEADOS\nEl grado de la relaci\u00f3n de esquema EMPLEADOS( DNI, nombre, apellido, sueldo ), es 4.\nCardinalidad de la relaci\u00f3n EMPLEADOS\nObservando la figura 3 se deduce que la cardin alidad de la relaci\u00f3n EMPLEADOS  es 3.\n2.3. Diferencias entre relaciones y ficheros\nA primera vista, relaciones y ficheros resultan similares. Los registros y los\ncampos que forman los ficheros se parecen a las tuplas y a los atributos de lasrelaciones, respectivamente.El grado de una relaci\u00f3n es el n\u00famero de atributos que pertenecen a\nsu esquema.\nLa cardinalidad  de una relaci\u00f3n es el n\u00famero de tuplas que pertenecen\na su extensi\u00f3n.\nEsta figura...\n... nos muestra la extensi\u00f3n \nde EMPLEADOS  en forma de \nconjunto, mientras que las figuras anteriores nos la mostraban en forma de filasde una tabla. La representa-ci\u00f3n tabular es m\u00e1s c\u00f3moda, pero no refleja la definici\u00f3n de extensi\u00f3n con tanta exactitud.\uf8e9 FUOC \u2022 71Z799014MO 13 El modelo relacional y el \u00e1lgebra relacional\nA pesar de esta similitud superficial, la visi\u00f3n formal de relaci\u00f3n que hemos pre-\nsentado establece algunas caracter\u00edsticas de las relaciones que las hacen diferen-tes de los ficheros cl\u00e1sicos. A continua ci\u00f3n describimos estas caracter\u00edsticas: \n1) Atomicidad de los valores de los atributos : los valores de los atributos de\nuna relaci\u00f3n deben ser at\u00f3micos; es deci r, no deben tener estructura interna.\nEsta caracter\u00edstica provie ne del hecho de que los atributos siempre deben to-\nmar un valor de su dominio o bien un valor nulo, y de que se ha establecido\nque los valores de los dominios deben se r at\u00f3micos en el modelo relacional.\nEl objetivo de la atomicidad de los va lores es dar simplicidad y uniformidad al\nmodelo relacional.\n2) No-repetici\u00f3n de las tuplas : en un fichero cl\u00e1sico puede ocurrir que dos de\nlos registros sean exactamente iguales; es decir, que contengan los mismos da-\ntos. En el caso del modelo relacional, en cambio, no es posible que una relaci\u00f3n\ncontenga tuplas repetidas. Esta caracter \u00edstica se deduce de  la misma definici\u00f3n\nde la extensi\u00f3n de una relaci\u00f3n. La extens i\u00f3n es un conjunto de tuplas y, en un\nconjunto, no puede haber elementos repetidos.\n3) No-ordenaci\u00f3n de las tuplas:  de la definici\u00f3n de la  extensi\u00f3n de una rela-\nci\u00f3n como un conjunto de tuplas se deduce tambi\u00e9n que estas tuplas no esta-r\u00e1n ordenadas, teniendo en  cuenta que no es posible que haya una ordenaci\u00f3n\nentre los elementos de un conjunto.\nLa finalidad de esta caracter\u00edstica es conseguir que, mediante el modelo rela-\ncional, se puedan representar los hechos en un nivel abstracto que sea inde-pendiente de su estructura f\u00edsica de implementaci\u00f3n. M\u00e1s concretamente,\naunque los SGBD relacionales deban proporcionar una implementaci\u00f3n f\u00edsicaque almacenar\u00e1 las tuplas de las relaciones en un orden concreto, esta ordena-\nci\u00f3n no es visible si nos situamos en el nivel conceptual.\nEjemplo de no-ordenaci\u00f3n de las tuplas\nEn una base de datos relacional , por ejemplo, no tiene sentid o consultar la \u201cprimera tupla\u201d\nde la relaci\u00f3n EMPLEADOS .\n4) No-ordenaci\u00f3n  de los atributos : el esquema de una relaci\u00f3n consta de un\nnombre de relaci\u00f3n R y un conjunto de atributos { A1, A2, ..., An}. As\u00ed pues, no\nhay un orden entre los atributos de un esquema de relaci\u00f3n, teniendo encuenta que estos atributo s forman un conjunto.\nComo en el caso anterior, el objetivo de esta caracter\u00edstica es representar los he-\nchos en un nivel abstracto, independie ntemente de su implementaci\u00f3n f\u00edsica.\nEjemplo de no-ordenaci\u00f3n de los atributos\nEl esquema de relaci\u00f3n EMPLEADOS( DNI, nombre, apellido, sueldo ) denota el mismo esquema\nde relaci\u00f3n que EMPLEADOS( nombre, apellido, DNI, sueldo ).\nEl concepto de extensi\u00f3n \nde una relaci\u00f3n  se ha explicado \nen el subapartado 2.2. de esta\nunidad did\u00e1ctica.\nEl concepto de esquema \nde una relaci\u00f3n  se ha explicado \nen el subapartado 2.2. de esta unidad did\u00e1ctica.\n\uf8e9 FUOC \u2022 71Z799014MO 14 El modelo relacional y el \u00e1lgebra relacional\n2.4. Clave candidata, clave primaria y clave alternativa \nde las relaciones\nToda la informaci\u00f3n que contiene una base de datos debe poderse identificar\nde alguna forma. En el caso particular de las bases de datos que siguen el mo-\ndelo relacional, para identi ficar los datos que la base de datos contiene, se pue-\nden utilizar las claves cand idatas de las relaciones. A continuaci\u00f3n definimos\nqu\u00e9 se entiende por clave candidata , clave primaria  y clave alternativa  de una re-\nlaci\u00f3n. Para hacerlo, ser\u00e1 nece sario definir el concepto de superclave .\nUna superclave, por lo tanto, nos permit e identificar todas las tuplas que con-\ntiene la relaci\u00f3n.\nAlgunas superclaves de la relaci\u00f3n EMPLEADOS\nEn la relaci\u00f3n de esquema EMPLEADOS( DNI, NSS, nombre, apellido, tel\u00e9fono ), algunas de las\nsuperclaves de la relaci\u00f3n ser\u00edan los siguientes subconjuntos de atributos: { DNI, NSS, nombre,\napellido, tel\u00e9fono }, {DNI, apellido }, {DNI} y {NSS}.\nEs decir, C cumple que la eliminac i\u00f3n de cualquiera de sus atributos da un\nconjunto de atributos que no es supercla ve de la relaci\u00f3n. Intuitivamente, una\nclave candidata permite identificar cual quier tupla de una relaci\u00f3n, de manera\nque no sobre ning\u00fan atributo para hacer la identificaci\u00f3n.\nClaves candidatas de EMPLEADOS\nEn la relaci\u00f3n de esquema EMPLEADOS( DNI, NSS, nombre, apellido, tel\u00e9fono ), s\u00f3lo hay dos cla-\nves candidatas: { DNI} y {NSS}.\nEl dise\u00f1ador de la base de datos es qu ien elige la clave primaria de entre las\nclaves candidatas.Una s uperclave de una relaci\u00f3n de esquema R( A1, A2, ..., An) es un\nsubconjunto de los atributos del es quema tal que no puede haber dos\ntuplas en la extensi\u00f3n de la relaci\u00f3n que tengan la misma combinaci\u00f3n\nde valores para los atributos del subconjunto.\nUna clave candidata de una relaci\u00f3n  es una superclave C de la rela-\nci\u00f3n que cumple que ning\u00fan subconjunto propio de C es superclave.\nHabitualmente, una de las claves candidatas de una relaci\u00f3n se designa\nclave primaria de la relaci\u00f3n. La clave primaria  es la clave candidata cu-\nyos valores se utilizar\u00e1n para identi ficar las tuplas de la relaci\u00f3n.Por ejemplo, ...\n... si se almacena informaci\u00f3n \nsobre los empleados de una empresa, es preciso tener la posibilidad de distinguir qu\u00e9 datos corresponden a cada uno de los diferentes empleados.\nObservad que...\n... toda relaci\u00f3n tiene, por lo \nmenos, una superclave, quees la formada por todos los atributos de su esquema. Esto se debe a la propiedad que cumple toda relaci\u00f3n de no tener tuplas repetidas.\nEn el ejemplo de EMPLEA-\nDOS( DNI, NSS, nombre , \napellido , tel\u00e9fono ) esta super-\nclave ser\u00eda: { DNI, NSS, nombre , \napellido , tel\u00e9fono }.\nNotad que, ...\n... puesto que toda relaci\u00f3n\ntiene por lo menos una super-clave, podemos garantizarque toda relaci\u00f3n tiene como m\u00ednimo una clave candidata.\nRelaci\u00f3n con una clave candidata\nSi una relaci\u00f3n s\u00f3lo tiene una \nclave candidata, entonces esta clave candidata debe ser tambi\u00e9n su clave primaria. Ya que todas las relacionestienen como m\u00ednimo una clave candidata, podemos garanti-zar que, para toda relaci\u00f3n, ser\u00e1 posible designar una clave primaria.\uf8e9 FUOC \u2022 71Z799014MO 15 El modelo relacional y el \u00e1lgebra relacional\nUtilizaremos la convenci\u00f3n de subrayar  los atributos que forman parte de la\nclave primaria en el esquema de la relaci\u00f3n. As\u00ed pues, R( A1, A2, ..., Ai, ..., An)\nindica que los atributos A1, A2, ..., Ai forman la clave primaria de R. \nElecci\u00f3n de la clave primaria de EMPLEADOS\nEn la relaci\u00f3n de  esquema EMPLEADOS (DNI, NSS, nombre, apellido, tel\u00e9fono ), donde hay dos\nclaves candidatas, { DNI} y {NSS}, se puede elegir co mo clave primaria { DNI}. Lo indicaremos\nsubrayando el atributo DNI en el esquema de la relaci\u00f3n EMPLEADOS( DNI, NSS, nombre, ape-\nllido, tel\u00e9fono ). En este caso, la clave { NSS} ser\u00e1 una clave alternativa de EMPLEADOS .\nEs posible que una clave candidata o una clave primaria conste de m\u00e1s de un\natributo.\nClave primaria de la relaci\u00f3n DESPACHOS\nEn la relaci\u00f3n de esquema DESPACHOS( edificio , n\u00famero , superficie ), la clave primaria est\u00e1 for-\nmada por los atributos edificio  y n\u00famero . En este caso, podr\u00e1 ocurrir que dos despachos dife-\nrentes est\u00e9n en el mismo edificio, o bien qu e tengan el mismo n\u00famero, pero nunca pasar\u00e1\nque tengan la misma combinaci\u00f3n de valores para edificio  y n\u00famero .\n2.5. Claves for\u00e1neas de las relaciones\nHasta ahora hemos estudiado las relacion es de forma individual, pero debe-\nmos tener en cuenta que una base de datos relacional normalmente contiene\nm\u00e1s de una relaci\u00f3n, para poder representar distintos tipos de hechos que su-\nceden en el mundo real. Por ejemplo,  podr\u00edamos tener una peque\u00f1a base de\ndatos que contuviese dos relaciones: una denominada EMPLEADOS , que alma-\ncenar\u00eda datos de los empleados de una empresa, y otra con el nombre DESPA-\nCHOS , que almacenar\u00eda los datos de lo s despachos que tiene la empresa.\nDebemos considerar tambi\u00e9n que entre los distintos hechos que se dan en el\nmundo real pueden existir lazos o v\u00edncul os. Por ejemplo, los empleados que tra-\nbajan para una empresa pueden estar vinc ulados con los despachos de la empre-\nsa, porque a cada empleado se le asigna  un despacho concreto para trabajar.\nEn el modelo relacional, para reflejar es te tipo de v\u00ednculos, tenemos la posibi-\nlidad de expresar conexiones entre las distintas tuplas de las relaciones. Por\nejemplo, en la base de datos anterior, que tiene las relaciones EMPLEADOS  y\nDESPACHOS , puede ser necesario conectar tuplas de EMPLEADOS  con tuplas\nde DESPACHOS  para indicar qu\u00e9 despacho ti ene asignado ca da empleado.\nEn ocasiones, incluso puede ser necesario reflejar lazos entre tuplas que pertene-\ncen a una misma relaci\u00f3n. Por ejemplo, en la misma base de datos anterior puedeLas claves candidatas no elegid as como primaria se denominan claves\nalternativas .\n\uf8e9 FUOC \u2022 71Z799014MO 16 El modelo relacional y el \u00e1lgebra relacional\nser necesario conectar de terminadas tuplas de EMPLEADOS  con otras tuplas de\nEMPLEADOS  para indicar, para cada empleado, qui\u00e9n act\u00faa como su jefe.\nEl mecanismo que proporcion an las bases de datos relacionales para conectar\ntuplas son las claves for\u00e1neas de las relaciones. Las claves for\u00e1neas  permiten es-\ntablecer conexiones entre las tuplas de las relaciones. Para hacer la conexi\u00f3n,\nuna clave for\u00e1nea tiene el conjunto de atributos de una relaci\u00f3n que referencianla clave primaria de otra relaci\u00f3n  (o incluso de la misma relaci\u00f3n).\nClaves for\u00e1neas de la relaci\u00f3n EMPLEADOS\nEn la figura siguiente, la relaci\u00f3n EMPLEADOS( DNI, nombre, apellid o, tel\u00e9fono, DNIjefe , edi-\nficiodesp , n\u00famerodesp ), tiene una clave for\u00e1nea formada por los atributos edificiodesp  y n\u00fame-\nrodesp  que se refiere a la clave prim aria de la relaci\u00f3n DESPACHOS( edificio , n\u00famero , superficie ).\nEsta clave for\u00e1nea indica, para cada empleado, el despacho donde trabaj a. Adem\u00e1s, el atribu-\nto DNIjefe  es otra clave for\u00e1nea que referencia la  clave primaria de la misma relaci\u00f3n EMPLEA-\nDOS, e indica, para cada empl eado, quien es su jefe.\nLas claves for\u00e1neas tienen por objetivo  establecer una conexi\u00f3n con la clave\nprimaria que referencian. Por lo tanto, los valores de una cl ave for\u00e1nea deben\nestar presentes en la clave primaria co rrespondiente, o bien deben ser valores\nnulos. En caso contrario,  la clave for\u00e1nea represen tar\u00eda una referencia o co-\nnexi\u00f3n incorrecta.\nEjemplo\nEn la relaci\u00f3n de esquema EMPLEADOS( DNI, nombre, apellido, DNIjef e, edificiodesp, n\u00famero-\ndesp), la clave for\u00e1nea { edificiodesp, n\u00famerodesp } referencia la relaci\u00f3n DESPACHOS( edificio ,\nn\u00famero , superficie ). De este modo, se cumple que todo s los valores que no son nulos de los\natributos edificiodesp  y n\u00famerodesp  son valores que existen para los atributos edificio  y n\u00famero\nde DESPACHOS , tal y como se puede ver a continuaci\u00f3n:\n\u2022R e l a c i \u00f3 n  DESPACHOS :\nDESPACHOS\nedificio n\u00famero superficie\nMarina 120 10Marina 122 15Marina 230 20\nDiagonal 120 10\n\uf8e9 FUOC \u2022 71Z799014MO 17 El modelo relacional y el \u00e1lgebra relacional\n\u2022R e l a c i \u00f3 n  EMPLEADOS\nSupongamos que hubiese un empleado con lo s valores <55.555.555, Mar\u00eda, Casagran, NU-\nLO, Par\u00eds, 400>. Puesto que no hay ning\u00fan despacho con los valores Par\u00eds y 400 para edificio\ny n\u00famero , la tupla de este empleado hace una refere ncia incorrecta; es de cir, indica un despa-\ncho para el empleado que, de hecho, no existe.\nEs preciso se\u00f1alar que en la relaci\u00f3n  EMPLEADOS hay otra clave for\u00e1nea, { DNIjefe }, que refe-\nrencia la misma relaci\u00f3n EMPLEADOS , y entonces se cumple que todos los valores que no\nson nulos del atributo DNIjefe  son valores que existen para el atributo DNI de la misma rela-\nci\u00f3n EMPLEADOS .\nA continuaci\u00f3n estableceremos de fo rma m\u00e1s precisa qu\u00e9 se entiende por clave\nfor\u00e1nea .\nDe la noci\u00f3n que hemos dado de clave for\u00e1nea se pueden extraer varias con-\nsecuencias: \n1)Si una clave for\u00e1nea CF referencia una clave primaria CP, el n\u00famero de atri-\nbutos de CF y de CP debe coincidir.\nEjemplo de coincidencia del n\u00famero de atributos de CF y CP\nEn el ejemplo anterior, tanto la clave for\u00e1nea { edificiodesp, n\u00famerodesp } como la clave primaria\nque referencia { edificio, n\u00famero } tienen dos atributos. Si no sucediese as\u00ed, no ser\u00eda posible que\nlos valores de CF existieran en CP.\n2)Por el mismo motivo, se puede establ ecer una correspondencia (en concre-\nto, una biyecci\u00f3n) entre los atributos de la clave for\u00e1nea y los atributos de la\nclave primaria que referencia.EMPLEADOS\nDNI nombre apellido DNIjefe edificiodesp n\u00famerodesp\n40.444.255 Juan Garc\u00eda NULO Marina 12033.567.711 Marta Roca 40.444.255 Marina 12055.898.425 Carlos Buend\u00eda 40.444.255 Diagonal 12077.232.144 Elena Pla 40.444.255 NULO NULO\nUna clave for\u00e1nea de una relaci\u00f3n R es un subconjunto de atributos\ndel esquema de la relaci\u00f3n, que denominamos CF y que cumple las si-\nguientes condiciones:\n1)Existe una relaci\u00f3n S (S no debe ser necesariamente diferente de R)\nque tiene por clave primaria CP.\n2)Se cumple que, para toda tupla t de la extensi\u00f3n de R, los valores para\nCF de t son valores nulos o bien valore s que coinciden con los valores\npara CP de alguna tupla s de S.\nY entonces, se dice que la clave for\u00e1nea  CF referencia la clave primaria\nCP de la relaci\u00f3n S, y tambi\u00e9n que la clave for\u00e1nea CF referencia la rela-\nci\u00f3n S.Conviene subrayar que, ...\n... tal y como ya hemos \nmencionado, el modelo relacional permite representar toda la informaci\u00f3n mediante valores expl\u00edcitos que contie-nen las relaciones, y no le hace falta nada m\u00e1s. De este modo, las conexiones entre tuplas de las relaciones se expresan con los valores expl\u00edcitos de las claves for\u00e1neas de las re-laciones, y no son necesarios conceptos adicionales (por ejemplo, apuntadoresentre tuplas), para establecer estas conexiones. Esta caracte-r\u00edstica da simplicidad y unifor-midad al modelo.\n\uf8e9 FUOC \u2022 71Z799014MO 18 El modelo relacional y el \u00e1lgebra relacional\nEjemplo de correspondencia entre los atributos de CF y los de CP\nEn el ejemplo anterior, a edificiodesp  le corresponde el atributo edificio , y a n\u00famerodesp  le co-\nrresponde el atributo n\u00famero .\n3)Tambi\u00e9n se deduce de la noci\u00f3n de clave for\u00e1nea  que los dominios de sus\natributos deben coincidir con los domini os de los atributos correspondientes\na la clave primaria que referencia. Esta coincidencia de dominios hace que sea\nposible que los valores de la clave for\u00e1 nea coincidan con valores de la clave\nprimaria referenciada.\nEjemplo de coincidencia de los dominios\nEn el ejemplo anterior, se  debe cumplir que dominio( edificiodesp ) = dominio( edificio ) y tam-\nbi\u00e9n que dominio( n\u00famerodesp ) = dominio( n\u00famero ).\nObservad que, de hecho, es ta condici\u00f3n se podr\u00eda rela jar, y se podr\u00eda permitir\nque los dominios no fuesen exactament e iguales, sino que s\u00f3lo fuesen, y de\nalguna forma que convendr\u00eda precisar, dominios \u201ccompatibles\u201d. Para simpli-\nficarlo, nosotros supondremos que los do minios deben ser iguales en todos los\ncasos en que, seg\u00fan Date (2001), se aceptar\u00edan dominios \u201ccompatibles\u201d. \nEjemplo de atributo que forma parte de  la clave primaria y de una clave\nfor\u00e1nea\nPuede suceder que alg\u00fan atributo de una rela ci\u00f3n forme parte tanto de la clave primaria\ncomo de una clave for\u00e1nea de la relaci\u00f3n. Esto  se da en las relaciones siguientes: EDIFI-\nCIOS( nombreedificio , direcci\u00f3n ), y DESPACHOS( edificio , n\u00famero , superficie ), donde { edificio }\nes una clave for\u00e1nea que referencia EDIFICIOS .\nEn este ejemplo, el atributo edificio forma parte tanto de la clave primaria como de la clave\nfor\u00e1nea de la relaci\u00f3n DESPACHOS .\n2.6. Creaci\u00f3n de las relacion es de una base de datos\nHemos visto que una base de datos relacional consta de varias relaciones. Cada\nrelaci\u00f3n tiene varios atributos que to man valores de unos ciertos dominios;\ntambi\u00e9n tiene una clave primaria y pued e tener una o m\u00e1s claves for\u00e1neas. Los\nlenguajes de los SGBD relacionales  deben proporcionar la forma de definir\ntodos estos elementos para crear una base de datos.\nM\u00e1s adelante se ver\u00e1 con detalle la sintaxis  y el significado de las sentencias de de-\nfinici\u00f3n de la base de datos para el caso concreto del lenguaje SQL. Lectura recomendada\nEncontrar\u00e9is explicaciones \ndetalladas sobre la coincidencia de dominios en la obra siguiente: \nC.J. Date  (2001). \nIntroducci\u00f3n a los sistemas de \nbases de datos (7\u00aa ed., cap. 19). \nPrentice Hall.\nEl lenguaje SQL se explica en la \nunidad did\u00e1ctica \u201cEl lenguaje SQL\u201d de este curso.\n\uf8e9 FUOC \u2022 71Z799014MO 19 El modelo relacional y el \u00e1lgebra relacional\n3. Operaciones del modelo relacional\nLas operaciones del modelo relacional deben permitir manipular datos alma-\ncenados en una base de datos relacional y, por lo tanto, es tructurados en for-\nma de relaciones. La manipulaci\u00f3n de datos incluye b\u00e1sicamente dos aspectos:\nla actualizaci\u00f3n y la consulta.\nEjemplo de actualizaci\u00f3n\nSi una base de datos contiene, por ejemplo, informaci\u00f3n de los empleados de una empresa,\ny la empresa contrata a un empleado, ser\u00e1 nece sario reflejar este cambio a\u00f1adiendo los datos\ndel nuevo empleado a la base de datos.\nExisten tres operaciones b\u00e1 sicas de actualizaci\u00f3n: \na) Inserci\u00f3n , que sirve para a\u00f1adir una o m\u00e1s tuplas a una relaci\u00f3n.\nb) Borrado , que sirve para eliminar una o m\u00e1s tuplas de una relaci\u00f3n.\nc) Modificaci\u00f3n , que sirve para alterar los va lores que tienen una o m\u00e1s tu-\nplas de una relaci\u00f3n para uno o m\u00e1s de sus atributos.\nEjemplo de consulta\nSi una base de datos contiene, por ejemplo, informaci\u00f3n de los empleados de una empresa,\npuede interesar consultar el nombre y apellid o de todos los empleados que trabajan en un\ndespacho situado en un edif icio que tiene por nombre Marina .\nLa obtenci\u00f3n de los datos que responden a una consulta puede requerir el an\u00e1-\nlisis y la extracci\u00f3n de datos de una o m\u00e1s de las relaciones que mantiene la\nbase de datos.\nSeg\u00fan la forma como se especifican las co nsultas, podemos clasificar los lengua-\njes relacionales en dos tipos: \n1) Lenguajes basados en el \u00e1lgebra relacional . El \u00e1lgebra relacional se inspi-\nra en la teor\u00eda de conjuntos. Si querem os especificar una consulta, es necesarioLa actualizaci\u00f3n de los datos  consiste en hacer que los cambios que se\nproducen en la realidad queden reflejados en las relaciones de la base\nde datos.\nLa consulta de los datos  consiste en la obtenc i\u00f3n de datos deducibles\na partir de las relaciones qu e contiene la base de datos.La sintaxis y el funcionamiento \nde las operaciones de actualizaci\u00f3n y consulta, en el caso concreto del lenguaje relacional  SQL, se estudian \ncon detalle en la unidad \u201cEl lenguaje SQL\u201d de este curso.\n\uf8e9 FUOC \u2022 71Z799014MO 20 El modelo relacional y el \u00e1lgebra relacional\nseguir uno o m\u00e1s pasos que sirven para ir construyendo, mediante operaciones\ndel \u00e1lgebra relacional, una nueva relaci\u00f3n que contenga los datos que respon-\nden a la consulta a partir de las relaciones almacenadas. Los lenguajes basados\nen el \u00e1lgebra relacional son lenguajes procedimentales , ya que los pasos que\nforman la consulta desc riben un procedimiento.\n2) Lenguajes basados en el c\u00e1lculo relacional . El c\u00e1lculo relacional tiene su\nfundamento te\u00f3rico en el c\u00e1lculo de pr edicados de la l\u00f3gica matem\u00e1tica. Pro-\nporciona una notaci\u00f3n que permite formular la defini ci\u00f3n de la relaci\u00f3n don-\nde est\u00e1n los datos que responden la co nsulta en t\u00e9rminos de las relaciones\nalmacenadas. Esta definici\u00f3n no describe un procedimiento; por lo tanto, se\ndice que los lenguajes basados en el c\u00e1lculo relacional son lenguajes declara-\ntivos  (no procedimentales).\nEl lenguaje SQL , en las sentencias de consulta, combina construcciones del \u00e1lge-\nbra relacional y del c\u00e1lculo relacional con un predominio de  las construcciones\ndel c\u00e1lculo. Este predominio determin a que SQL sea un lenguaje declarativo.\nEl estudio del \u00e1lgebra relacional presenta un inter\u00e9s espe cial, pues ayuda a en-\ntender qu\u00e9 servicios de consulta debe pr oporcionar un lenguaje relacional, faci-\nlita la comprensi\u00f3n de algunas de las construcciones del lenguaje SQL y tambi\u00e9n\nsirve de base para el tratamiento de la s consultas que efect\u00faan los SGBD inter-\nnamente. Este \u00faltimo tema queda fuera del \u00e1mbito del presente curso, pero es\nnecesario para estudios m\u00e1s avanzados sobre bases de datos. El \u00e1lgebra relacional se explica\nen el apartado 5 de estaunidad did\u00e1ctica.\n\uf8e9 FUOC \u2022 71Z799014MO 21 El modelo relacional y el \u00e1lgebra relacional\n4. Reglas de integridad\nUna base de datos contiene unos datos que, en cada momento, deben reflejar\nla realidad o, m\u00e1s concretamente, la si tuaci\u00f3n de una porci\u00f3n del mundo real.\nEn el caso de las bases de datos relaci onales, esto significa que la extensi\u00f3n de\nlas relaciones (es decir, las tuplas que contienen las relacion es) deben tener va-\nlores que reflejen la realidad correctamente. \nSuele ser bastante frecuente que determ inadas configuraciones de valores para\nlas tuplas de las relaciones  no tengan sentido, porq ue no representan ninguna\nsituaci\u00f3n posible del mundo real. \nUn sueldo negativo\nEn la relaci\u00f3n de esquema EMPLEADOS( DNI, nombre , apellido , sueldo ), una tupla que tiene\nun valor de \u20131.000 para el sueldo probablement e no tiene sentido, porque los sueldos no pue-\nden ser negativos.\nComo es evidente, para que los datos sean \u00edntegros, es preciso que cumplan\nvarias condiciones.\nEl hecho de que los sueldos no puedan ser ne gativos es una condici\u00f3n que se deber\u00eda cumplir\nen la relaci\u00f3n EMPLEADOS .\nEn general, las condicione s que garantizan la integr idad de los datos pueden\nser de dos tipos: \n1)Las restricciones de integridad de usuario  son condiciones espec\u00edficas de\nuna base de datos concreta; es decir, son las que se deben cumplir en una basede datos particular con unos usuarios concretos, pero qu e no son necesaria-\nmente relevantes en otra base de datos.\nRestricci\u00f3n de integridad de usuario en EMPLEADOS\n\u00c9ste ser\u00eda el caso de la condici\u00f3n anterior, se g\u00fan la cual los sueldos no pod\u00edan ser negativos.\nObservad que esta condici\u00f3n era necesaria en la  base de datos concreta  de este ejemplo por-\nque aparec\u00eda el atributo sueldo , al que se quer\u00eda dar un significado; sin embargo, podr\u00eda no ser\nnecesaria en otra base de datos diferente donde, por ejemplo, no hubiese sueldos.\n2)Las reglas de integridad de modelo , en cambio, son co ndiciones m\u00e1s ge-\nnerales, propias de un modelo de dato s, y se deben cumplir en toda base de\ndatos que siga dicho modelo.\nEjemplo de regla de integridad del modelo de datos relacional\nEn el caso del modelo de datos relacional, habr\u00e1 una regla de integridad para garantizar\nque los valores de una clave primaria de una relaci\u00f3n no se repitan en tuplas diferentesDenominamos integridad  la propiedad de los datos de corresponder a\nrepresentaciones plausibles del mundo real.\n\uf8e9 FUOC \u2022 71Z799014MO 22 El modelo relacional y el \u00e1lgebra relacional\nde la relaci\u00f3n. Toda base de datos relacional debe cumplir esta regla que, por lo tanto, es\nuna regla de integridad del modelo. \nLos SGBD deben proporcionar la forma de  definir las restricciones de integri-\ndad de usuario de una base de datos; una vez definidas, deben velar por su\ncumplimiento.\nLas reglas de integridad del modelo, en  cambio, no se deben definir para cada\nbase de datos concreta, porque se consideran preestablecidas para todas las base\nde datos de un modelo. Un SGBD de un  modelo determinado debe velar por el\ncumplimiento de las reglas de integr idad preestablecidas por su modelo.\nA continuaci\u00f3n estudiar emos con detalle las reglas de integridad del modelo\nrelacional , reglas que todo SGBD relaci onal debe obligar a cumplir. \n4.1. Regla de integridad de unicidad de la clave primaria\nLa regla de integridad de unicidad est\u00e1  relacionada con la definici\u00f3n de clave\nprimaria. Concretamente, establece que toda clave primaria  que se elija para\nuna relaci\u00f3n no debe tener valores repetidos.\nEjemplo\nTenemos la siguiente relaci\u00f3n:\nEn esta relaci\u00f3n, dado que la clave primaria est\u00e1 formada por edificio  y n\u00famero , no hay ning\u00fan\ndespacho que repita tanto edificio  como n\u00famero de otro despacho. Sin em bargo, s\u00ed se repiten\nvalores de edificio  (por ejemplo, Marina); y ta mbi\u00e9n se repiten valores de n\u00famero (120). A pe-\nsar de ello, el edificio  y el n\u00famero  no se repiten nunca al mismo tiempo.\nA continuaci\u00f3n explicamos esta  regla de forma m\u00e1s precisa.\nUn SGBD relacional deber\u00e1 garantizar el cumplimiento de esta regla de inte-\ngridad en todas las insercio nes, as\u00ed como en todas la s modificaciones que afec-\nten a atributos que pertenecen a la  clave primaria de la relaci\u00f3n.DESPACHOS\nedificio n\u00famero superficie\nMarina 120 10Marina 122 15Marina 230 20\nDiagonal 120 10\nLa regla de integridad de unicidad de la clave primaria  establece que\nsi el conjunto de atributos CP es la clave primaria de una relaci\u00f3n R, en-\ntonces la extensi\u00f3n de R no puede tener en ni ng\u00fan momento dos tuplas\ncon la misma combinaci\u00f3n de va lores para los atributos de CP.La forma de definir estas \nrestricciones con el lenguaje SQL se explica en la unidad\u201cEl lenguaje SQL\u201d de este curso.\nEs preciso destacar que el mismo concepto de clave primaria  implica \nesta condici\u00f3n. El concepto de clave \nprimaria  se ha explicado en el \nsubapartado 2.4. de estaunidad did\u00e1ctica.\n\uf8e9 FUOC \u2022 71Z799014MO 23 El modelo relacional y el \u00e1lgebra relacional\nEjemplo\nTenemos la siguiente relaci\u00f3n:\nEn esta relaci\u00f3n no se deber\u00eda poder insertar la tupla <Diagonal, 120, 30>, ni modificar la tu-\npla <Marina, 122, 15>, de modo que pasara a ser <Marina, 120, 15>.\n4.2. Regla de integridad de entidad de la clave primaria\nLa regla de integridad de entidad de la clave primaria dispone que los atributos\nde la clave primaria de una relaci \u00f3n no pueden te ner valores nulos.\nEjemplo\nTenemos la siguiente relaci\u00f3n:\nEn esta relaci\u00f3n, puesto que la clave primaria est\u00e1 formada por edificio  y n\u00famero , no hay nin-\ng\u00fan despacho que tenga un valor nulo para edificio , ni tampoco para n\u00famero .\nEsta regla es necesaria para que los valo res de las claves primarias puedan iden-\ntificar las tuplas individuales de las re laciones. Si las claves primarias tuviesen\nvalores nulos, es posible que algunas tuplas no se pudieran distinguir.\nEjemplo de clave primaria incorrecta con valores nulos\nEn el ejemplo anterior, si un desp acho tuviese un valor nulo para edificio porque en un mo-\nmento dado el nombre de este edificio no se  conoce, por ejemplo <NULO, 120, 30>, la clave\nprimaria no nos permitir\u00eda distinguirlo de l despacho <Marina, 120, 10> ni del despacho\n<Diagonal, 120,10>. No podr\u00eda mos estar seguros de que el valor desconocido de edificio no\nes ni Marina ni Diagonal.\nA continuaci\u00f3n definimos esta  regla de forma m\u00e1s precisa.DESPACHOS\nedificio n\u00famero superficie\nMarina 120 10Marina 122 15Marina 230 20\nDiagonal 120 10\nDESPACHOS\nedificio n\u00famero superficie\nMarina 120 10Marina 122 15Marina 230 20\nDiagonal 120 10\nLa regla de integridad de en tidad de la clave primaria  establece que\nsi el conjunto de atributos CP es la clave primaria de una relaci\u00f3n R, la\nextensi\u00f3n de R no puede tener ninguna tupl a con alg\u00fan valor nulo para\nalguno de los atributos de CP.\uf8e9 FUOC \u2022 71Z799014MO 24 El modelo relacional y el \u00e1lgebra relacional\nUn SGBD relacional tendr\u00e1 que garantizar el cumplimie nto de esta regla de in-\ntegridad en todas las inserciones y, ta mbi\u00e9n, en todas las modificaciones que\nafecten a atributos que pertenecen a la clave primaria de la relaci\u00f3n.\nEjemplo\nEn la relaci\u00f3n DESPACHOS  anterior, no se deber\u00eda inserta r la tupla <Diagonal, NULO, 15>.\nTampoco deber\u00eda ser posible modificar la tupla <Marina, 120, 10> de modo que pasara a ser\n<NULO, 120, 10>.\n4.3. Regla de integridad referencial\nLa regla de integridad referencial es t\u00e1 relacionada con el concepto de clave fo-\nr\u00e1nea . Concretamente, determina que todos los valores que toma una clave fo-\nr\u00e1nea deben ser valores nulos o valores que existen en la clave primaria que\nreferencia.\nEjemplo\nSi tenemos las siguientes relaciones:\n\u2022R e l a c i \u00f3 n  DESPACHOS :\n\u2022R e l a c i \u00f3 n  EMPLEADOS :\ndonde edificiodesp  y n\u00famerodesp de la relaci\u00f3n EMPLEADOS  forman una clave for\u00e1nea que re-\nferencia la relaci\u00f3n DESPACHOS . Debe ocurrir que los valores no nulos de edificiodesp  y n\u00fa-\nmerodesp  de la relaci\u00f3n EMPLEADOS  est\u00e9n en la relaci\u00f3n DESPACHOS  como valores de edificio\ny n\u00famero . Por ejemplo, el empleado <40.444.255, Juan Garc\u00eda, Marina, 120> tiene el valor\nMarina para edificiodesp , y el valor 120 para n\u00famerodesp , de modo que en la relaci\u00f3n DESPA-\nCHOS  hay un despacho con valor Marina para edificio  y con valor 120 para n\u00famero .\nLa necesidad de la regla de integridad relacional proviene del hecho de que las\nclaves for\u00e1neas tienen por objetivo es tablecer una conexi\u00f3n con la clave pri-\nmaria que referencian. Si un valor de una clave for\u00e1nea no estuviese presenteDESPACHOS\nedificio n\u00famero superficie\nMarina 120 10Marina 122 15Marina 230 20\nDiagonal 120 10\nEMPLEADOS\nDNI nombre apellido edificiodesp n\u00famerodesp\n40.444.255 Juan Garc\u00eda Marina 12033.567.711 Marta Roca Marina 12055.898.425 Carlos Buend\u00eda Diagonal 12077.232.144 Elena Pla NULO NULOObservad que todo lo que impone \nla regla de integridad referencial viene implicado por la misma noci\u00f3n de clave for\u00e1nea  que se ha explicado en \nel subapartado 2.5 de esta unidad.\n\uf8e9 FUOC \u2022 71Z799014MO 25 El modelo relacional y el \u00e1lgebra relacional\nen la clave primaria corr espondiente, representar\u00eda una referencia o una co-\nnexi\u00f3n incorrecta.\nReferencia incorrecta\nSupongamos que en el ejemplo anterior hu biese un empleado con los valores <56.666.789,\nPedro, L\u00f3pez, Valencia, 325>. Ya que no hay un  despacho con los valores Valencia y 325 para\nedificio  y n\u00famero , la tupla de este empleado hace una re ferencia incorrecta; es decir, indica un\ndespacho para el empleado que, de hecho, no existe.\nA continuaci\u00f3n explicamos la regla de modo m\u00e1s preciso.\nUn SGBD relacional tendr\u00e1  que hacer cumplir esta re gla de integridad. Deber\u00e1\nefectuar comprobaciones cuando se produzcan las siguientes operaciones:\na)Inserciones en una relaci\u00f3n que tenga una clave for\u00e1nea.\nb)Modificaciones que afecten a atributos que pertenecen a la clave for\u00e1nea\nde una relaci\u00f3n.\nc)Borrados en relaciones refere nciadas por otras relaciones.\nd)Modificaciones que afecten a atributo s que pertenecen a la clave primaria\nde una relaci\u00f3n referenc iada por otra relaci\u00f3n.\nEjemplo\nRetomamos el ejemplo anterior, donde edificiodesp  y n\u00famerodesp  de la relaci\u00f3n EMPLEADOS\nforman una clave for\u00e1nea que referencia la relaci\u00f3n DESPACHOS :\n\u2022R e l a c i \u00f3 n  DESPACHOS :La regla de integridad referencial  establece que si el conjunto de atribu-\ntos CF es una clave for\u00e1nea de una relaci\u00f3n R que referencia una relaci\u00f3n\nS (no necesariamente diferente de R), que tiene por clave primaria CP, en-\ntonces, para toda tupla t de la extensi\u00f3n de R, los valores para el conjunto\nde atributos CF de t son valores nulos, o bien valores que coinciden con\nlos valores para CP de alguna tupla s de S.\nEn el caso de que una tupla t de la extensi\u00f3n de R tenga valores para CF\nque coincidan con los valores para CP de una tupla s de S, decimos que\nt es una tupla que referencia s y que s es una tupla que tiene una clave\nprimaria referenciada por t.\nDESPACHOS\nedificio n\u00famero superficie\nMarina 120 10Marina 122 15Marina 230 20\nDiagonal 120 10\uf8e9 FUOC \u2022 71Z799014MO 26 El modelo relacional y el \u00e1lgebra relacional\n\u2022R e l a c i \u00f3 n  EMPLEADOS :\nLas siguientes operaciones pr ovocar\u00edan el incumplimiento de la regla de integridad\nreferencial:\n\u2022 Inserci\u00f3n de <12.764.411, Jorge, Puig, Diagonal, 220> en EMPLEADOS .\n\u2022 Modificaci\u00f3n de <40.444.255, Juan, Garc\u00eda, Marina, 120> de EMPLEADOS  por\n<40.444.255, Juan, Garc\u00eda, Marina, 400>.\n\u2022 Borrado de <Marina, 120, 10> de DESPACHOS .\n\u2022 Modificaci\u00f3n de <Diagonal, 120, 10> de DESPACHOS  por <Par\u00eds, 120, 10>.\nUn SGBD relacional debe procurar que se  cumplan las reglas de integridad del\nmodelo. Una forma habitual de mantener estas reglas consiste en rechazartoda operaci\u00f3n de actualizaci\u00f3n que deje la base de datos en un estado en el\nque alguna regla no se cumpla. En algu nos casos, sin embargo, el SGBD tiene\nla posibilidad de aceptar la operaci\u00f3n y efectuar a cciones adicionales compen-\nsatorias, de modo que el estado que se obtenga satisfaga las reglas de integri-dad, a pesar de haber ejecutado la operaci\u00f3n.\nEsta \u00faltima pol\u00edtica se puede aplicar en  las siguientes operaciones de actuali-\nzaci\u00f3n que violar\u00edan la regla de integridad:\na)Borrado de una tupla que tiene un a clave primaria referenciada.\nb)Modificaci\u00f3n de los valores de los atri butos de la clave primaria de una tu-\npla que tiene una clave primaria referenciada.\nEn los casos anteriores, algunas de las po l\u00edticas que se podr\u00e1n aplicar ser\u00e1n las\nsiguientes: restricci\u00f3n , actualizaci\u00f3n en cascada  y anulaci\u00f3n . A continua-\nci\u00f3n explicamos el significado de las tres posibilidad es mencionadas. \n4.3.1. Restricci\u00f3n\nLa pol\u00edtica de restri cci\u00f3n consiste en no aceptar la operaci\u00f3n de  actualizaci\u00f3n.EMPLEADOS\nDNI nombre apellido edificiodesp n\u00famerodesp\n40.444.255 Juan Garc\u00eda Marina 12033.567.711 Marta Roca Marina 12055.898.425 Carlos Buend\u00eda Diagonal 12077.232.144 Elena Pla NULO NULO\nM\u00e1s concretamente, la restricci\u00f3n en caso de borrado , consiste en no\npermitir borrar una tupla si tiene una clave primaria referenciada por al-\nguna clave for\u00e1nea.\n\uf8e9 FUOC \u2022 71Z799014MO 27 El modelo relacional y el \u00e1lgebra relacional\nEjemplo de aplicaci\u00f3n de la restricci\u00f3n\nSupongamos que tenemos las siguientes relaciones:\n\u2022R e l a c i \u00f3 n  CLIENTES :\n\u2022R e l a c i \u00f3 n  PEDIDOS_PENDIENTES\n* {numcliente } referencia CLIENTES .\na)Si aplicamos la restricci\u00f3n en caso de borrado  y, por ejemplo, querem os borrar al cliente\nn\u00famero 10, no podremos hacerlo porque tiene pedidos pendientes que lo referencian.\nb)Si aplicamos la restricci\u00f3n en caso de modi ficaci\u00f3n y queremos modificar el n\u00famero del\ncliente 15, no ser\u00e1 posible hacerlo porque ta mbi\u00e9n tiene pedidos pendientes que lo referen-\ncian.\n4.3.2. Actualizaci\u00f3n en cascada\nLa pol\u00edtica de actua lizaci\u00f3n en cascada co nsiste en permitir la operaci\u00f3n de ac-\ntualizaci\u00f3n de la tupla, y en efectuar  operaciones compensatorias que propa-\nguen en cascada la actualizaci\u00f3n a las tu plas que la referenc iaban; se act\u00faa de\neste modo para mantener la integridad referencial.De forma similar, la restricci\u00f3n en caso de modificaci\u00f3n  consiste en\nno permitir modificar ning\u00fan atributo de la clave primaria de una tuplasi tiene una clave primaria refere nciada por alguna  clave for\u00e1nea.\nCLIENTES\nnumcliente ...\n10 \u201315 \u201318 \u2013\nPEDIDOS_PENDIENTES\nnumped ... numcliente*\n1.234 \u2013 101.235 \u2013 101.236 \u2013 15\nM\u00e1s concretamente, la actualizaci\u00f3n en cascada en caso de borrado\nconsiste en permitir el borrado de una tupla t que tiene una clave pri-\nmaria referenciada, y borrar tambi\u00e9 n todas las tuplas  que referencian t.\nDe forma similar, la actualizaci\u00f3n en cascada en caso de modifica-\nci\u00f3n  consiste en permitir la modificaci \u00f3n de atributos de la clave prima-\nria de una tupla t que tiene una clave primaria  referenciada, y modificar\ndel mismo modo todas las tuplas que referencian t.\uf8e9 FUOC \u2022 71Z799014MO 28 El modelo relacional y el \u00e1lgebra relacional\nEjemplo de aplicaci\u00f3n de la actualizaci\u00f3n en cascada\nSupongamos que tenemos las siguientes relaciones:\n\u2022R e l a c i \u00f3 n  EDIFICIOS :\n\u2022R e l a c i \u00f3 n  DESPACHOS :\n* {edificio } referencia EDIFICIOS .\na)Si aplicamos la actualizaci\u00f3n en cascada en caso de borrado y, por ejemplo, queremos bo-\nrrar el edificio Diagonal, se borrar\u00e1 tambi\u00e9n el  despacho Diagonal 120 que hay en el edificio,\ny nos quedar\u00e1:\n\u2022R e l a c i \u00f3 n  EDIFICIOS :\n\u2022R e l a c i \u00f3 n  DESPACHOS :\n* {edificio } referencia EDIFICIOS .\nb)Si aplicamos la actualizaci\u00f3n en cascada en caso de modificaci\u00f3n, y queremos modificar\nel nombre del edificio Marina por Mar, tamb i\u00e9n se cambiar\u00e1 Marina por Mar en los despa-\nchos Marina 120, Marina 122 y Marina 230, y nos quedar\u00e1:\n\u2022R e l a c i \u00f3 n  EDIFICIOS :\n\u2022R e l a c i \u00f3 n  DESPACHOS :\n* {edificio } referencia EDIFICIOS .EDIFICIOS\nnombreedificio ...\nMarina \u2013\nDiagonal \u2013\nDESPACHOS\nedificio* n\u00famero superficie\nMarina 120 10\nMarina 122 15Marina 230 20\nDiagonal 120 10\nEDIFICIOS\nnombreedificio ...\nMarina \u2013\nDESPACHOS\nedificio* n\u00famero superficie\nMarina 120 10Marina 122 15\nMarina 230 20\nEDIFICIOS\nnombreedificio ...\nMar \u2013\nDESPACHOS\nedificio* n\u00famero superficie\nMar 120 10\nMar 122 15\nMar 230 20\uf8e9 FUOC \u2022 71Z799014MO 29 El modelo relacional y el \u00e1lgebra relacional\n4.3.3. Anulaci\u00f3n\nEsta pol\u00edtica consiste en pe rmitir la operaci\u00f3n de actu alizaci\u00f3n de la tupla y en\nefectuar operaciones compensatorias qu e pongan valores nu los a los atributos\nde la clave for\u00e1nea de las tuplas que la referencian; esta acci\u00f3n se lleva a cabo\npara mantener la in tegridad referencial.\nPuesto que generalmente los SGBD rela cionales permiten establecer que un\ndeterminado atributo de una relaci\u00f3n no admite valores nulos, s\u00f3lo se puedeaplicar la pol\u00edtica de anulaci\u00f3n si los atributos de la clave for\u00e1nea s\u00ed los ad-\nmiten.\nEjemplo de aplicaci\u00f3n de la anulaci\u00f3n\nEl mejor modo de entender en qu\u00e9 consiste la  anulaci\u00f3n es mediante un ejemplo. Tenemos\nlas siguientes relaciones:\n\u2022R e l a c i \u00f3 n  VENDEDORES :\n\u2022R e l a c i \u00f3 n  CLIENTES :\n* {vendedorasig } referencia VENDEDORES .M\u00e1s concretamente, la anulaci\u00f3n en caso de borrado  consiste en per-\nmitir el borrado de una tupla t que tiene una clave referenciada y, ade-\nm\u00e1s, modificar todas las tuplas que referencian t, de modo que los\natributos de la clave for\u00e1nea co rrespondiente tomen valores nulos.\nDe forma similar, la anulaci\u00f3n en cas o de modificaci\u00f3n  consiste en\npermitir la modificaci\u00f3n de atributo s de la clave primaria de una tupla\nt que tiene una clave referenciada y,  adem\u00e1s, modificar todas las tuplas\nque referencian t, de modo que los atributos de la clave for\u00e1nea corres-\npondiente tomen valores nulos.\nVENDEDORES\nnumvendedor ...\n1\u20132\u20133\u2013\nCLIENTES\nnumcliente ... vendedorasig*\n23 \u2013 135 \u2013 138 \u2013 242 \u2013 250 \u2013 3\uf8e9 FUOC \u2022 71Z799014MO 30 El modelo relacional y el \u00e1lgebra relacional\na)Si aplicamos la anulaci\u00f3n en caso de borrado y, por ejemplo, querem os borrar al vendedor\nn\u00famero 1, se modificar\u00e1n todos los clientes que lo ten\u00edan asig nado, y pasar\u00e1n a tener un va-\nlor nulo en vendedorasig . Nos quedar\u00e1:\n\u2022R e l a c i \u00f3 n  VENDEDORES :\n\u2022R e l a c i \u00f3 n  CLIENTES :\n* {vendedorasig } referencia VENDEDORES .\nb)Si aplicamos la anulaci\u00f3n en caso de modi ficaci\u00f3n, y ahora queremos cambiar el n\u00famero\ndel vendedor 2 por 5, se modifi car\u00e1n todos los clientes que lo ten\u00edan asignado y pasar\u00e1n a\ntener un valor nulo en vendedorasig . Nos quedar\u00e1:\n\u2022R e l a c i \u00f3 n  VENDEDORES :\n\u2022R e l a c i \u00f3 n  CLIENTES :\n* {vendedorasig } referencia VENDEDORES .\n4.3.4. Selecci\u00f3n de la pol\u00edtica de mantenimiento\nde la integridad referencial\nHemos visto que en caso de borrado o mo dificaci\u00f3n de una clave primaria re-\nferenciada por alguna clav e for\u00e1nea hay varias pol\u00edt icas de mant enimiento de\nla regla de integridad referencial.VENDEDORES\nnumvendedor ...\n2\u20133\u2013\nCLIENTES\nnumcliente ... vendedorasig*\n23 \u2013 NULO\n35 \u2013 NULO\n38 \u2013 242 \u2013 2\n50 \u2013 3\nVENDEDORES\nnumvendedor ...\n5\u20133\u2013\nCLIENTES\nnumcliente ... vendedorasig*\n23 \u2013 NULO35 \u2013 NULO\n38 \u2013 NULO\n42 \u2013 NULO50 \u2013 3\nLa forma de definir estas pol\u00edticas de \nmantenimiento de la integridad con el lenguaje SQL se explica en la unidad\u201cEl lenguaje SQL\u201d de este curso.\n\uf8e9 FUOC \u2022 71Z799014MO 31 El modelo relacional y el \u00e1lgebra relacional\nEl dise\u00f1ador puede elegir para cada clave for\u00e1nea qu\u00e9 pol\u00edtica se aplicar\u00e1 en\ncaso de borrado de la clave primaria re ferenciada, y cu\u00e1l en caso de modifica-\nci\u00f3n de \u00e9sta. El dise\u00f1ador deber\u00e1 tener en cuenta el significado de cada clave\nfor\u00e1nea concreta para pode r elegir adecuadamente. \n4.4. Regla de integridad de dominio\nLa regla de integridad de dominio est\u00e1 relacionada, como su nombre indica,\ncon la noci\u00f3n de dominio . Esta regla establece dos condiciones.\nEsta condici\u00f3n implica que todos los valores no nulos que contiene la base de\ndatos para un determinado atributo deben ser del dominio declarado para di-\ncho atributo.\nEjemplo\nSi en la relaci\u00f3n EMPLEADOS( DNI, nombre, apellido, edademp ) hemos declarado que domi-\nnio(DNI) es el dominio predefinido de los enteros,  entonces no podremos insertar, por ejem-\nplo, ning\u00fan empleado que tenga por DNI el valor \u201cLuis\u201d, que no es un entero.\nRecordemos que los dominios pueden ser de dos tipos: predefinidos o defini-\ndos por el usuario. Observad que los do minios definidos por el usuario resul-\ntan muy \u00fatiles, porque no s permiten determinar de forma m\u00e1s espec\u00edfica\ncu\u00e1les ser\u00e1n los valores admitidos por los atributos.\nEjemplo\nSupongamos ahora que en la relaci\u00f3n EMPLEADOS( DNI, nombre, apellido, edademp ) hemos\ndeclarado que dominio( edademp ) es el dominio definido por el usuario edad. Supongamos\ntambi\u00e9n que el dominio edad se ha definido como el conjunto de los enteros que est\u00e1n entre\n16 y 65. En este caso, por ejemplo, no ser\u00e1 posible insertar un empleado con un valor de 90para edademp .\nLa segunda condici\u00f3n de la regla de integridad de dominio es m\u00e1s compleja,\nespecialmente en el caso de dominios definidos por el usua rio; los SGBD ac-\ntuales no la soportan para estos \u00faltimos dominios. Por estos motivos s\u00f3lo la\npresentaremos superficialmente. La primera condici\u00f3n  consiste en que un valor no nulo de un atributo\nAi debe pertenecer al dominio del atributo Ai; es decir, debe pertenecer\na dominio( Ai).\nEsta segunda condici\u00f3n  sirve para establecer que los operadores que\npueden aplicarse sobre los valores de penden de los dominios de estos\nvalores; es decir, un operador dete rminado s\u00f3lo se puede aplicar sobre\nvalores que tengan dominios que le sean adecuados.Aplicaci\u00f3n de pol\u00edticas \ndiferentes\nPuede ocurrir que, para una \ndeterminada clave for\u00e1nea, la pol\u00edtica adecuada en casode borrado sea diferente de la adecuada en caso de modifica-ci\u00f3n. Por ejemplo, puede ser necesario aplicar la restricci\u00f3n en caso de borrado y la actua-lizaci\u00f3n en cascada en caso de modificaci\u00f3n.\nRecordad que los conceptos\nde dominio predefinido  y dominio \ndefinido por el usuario  se han explicado\nen el subapartado 2.2 de esta unidad did\u00e1ctica.\nLectura complementaria\nPara estudiar con m\u00e1s detalle \nla segunda condici\u00f3n de la regla de integridad de dominio, pod\u00e9is consultar la siguiente obra:\nC.J. Date  (2001). \nIntroducci\u00f3n a los sistemas\nde bases de datos (7\u00aa ed.,\ncap. 19). Prentice Hall.\n\uf8e9 FUOC \u2022 71Z799014MO 32 El modelo relacional y el \u00e1lgebra relacional\nEjemplo\nAnalizaremos esta segunda condici\u00f3n de la re gla de integridad de dominio con un ejemplo\nconcreto. Si en la relaci\u00f3n EMPLEADOS( DNI, nombre, apellido, edademp ) se ha declarado que\ndominio( DNI) es el dominio predefinido de los enteros, entonces no se permitir\u00e1 consultar\ntodos aquellos empleados cuyo DNI sea igual a \u2018Elena\u2019 ( DNI = \u2018Elena\u2019). El motivo es que no\ntiene sentido que el operador de comparaci\u00f3n = se aplique entre un DNI que tiene por domi-\nnio los enteros, y el valor \u2018Elena\u2019,  que es una serie de caracteres.\nDe este modo, el hecho de que los oper adores que se pueden aplicar sobre los\nvalores dependan del dominio de estos valores permite detectar errores que se\npodr\u00edan cometer cuando se consulta o se actualiza la base de datos. Los domi-nios definidos por el usuario son muy \u00fatiles, porque nos permitir\u00e1n determi-\nnar de forma m\u00e1s espec\u00edfica cu\u00e1les ser\u00e1 n los operadores que se podr\u00e1n aplicar\nsobre los valores.\nEjemplo\nVeamos otro ejemplo con dominios definidos po r el usuario. Supongamos que en la conoci-\nda relaci\u00f3n EMPLEADOS( DNI, nombre, apellido, edademp ) se ha declarado que dominio( DNI)\nes el dominio definido por el usuario n\u00famerosDNI  y que dominio( edademp ) es el dominio de-\nfinido por el usuario edad. Supongamos que n\u00famerosDNI  corresponde a los enteros positivos\ny que edad corresponde a los enteros que est\u00e1n entre 16 y 65. En este caso, ser\u00e1 incorrecto,\npor ejemplo, consultar los empl eados que tienen el valor de DNI igual al valor de edademp .\nEl motivo es que, aunque tanto los valores de DNI como los de edademp  sean enteros, sus do-\nminios son diferentes; por ello, seg\u00fan el significado que el usuario les da, no tiene sentido\ncompararlos.\nSin embargo, los actuales SGBD relaci onales no dan apoyo a la segunda con-\ndici\u00f3n de la regla de integridad de dominio para dominios definidos por elusuario. Si se quisiera hacer, ser\u00eda necesario que el dise\u00f1ador tuviese alguna\nforma de especificar, para cada operad or que se desease ut ilizar, para qu\u00e9 com-\nbinaciones de dominios definidos por el  usuario tiene sentido que se aplique.\nEl lenguaje est\u00e1ndar SQL no incl uye actualmente esta posibilidad. \n\uf8e9 FUOC \u2022 71Z799014MO 33 El modelo relacional y el \u00e1lgebra relacional\n5. El \u00e1lgebra relacional\nComo ya hemos comentado en el apartado dedicado a las operaciones del mo-\ndelo relacional, el \u00e1lgebra relacional se  inspira en la teor\u00eda de conjuntos para\nespecificar consultas en una base de datos relacional.\nPara especificar una consulta  en \u00e1lgebra relacional, es preciso definir uno o\nm\u00e1s pasos que sirven para ir construyendo, mediante operaciones de \u00e1lgebra\nrelacional, una nueva relaci\u00f3n que contenga los datos que responden a la con-\nsulta a partir de las relaci ones almacenadas. Los lenguajes basados en el \u00e1lge-\nbra relacional son procedimentales, dado que los pasos que forman la consultadescriben un procedimiento.\nLa visi\u00f3n que presentaremos es la de un le nguaje te\u00f3rico y, por lo tanto, incluire-\nmos s\u00f3lo sus operaciones fu ndamentales, y no las construcciones que se podr\u00edan\na\u00f1adir a un lenguaje comercial para fac ilitar cuestiones como por ejemplo el or-\nden de presentaci\u00f3n del resultado, el c\u00e1lculo de datos agregados, etc. \nLas operaciones del \u00e1lgebra relacional han sido clasificadas seg\u00fan distintos cri-\nterios; de todos ellos indicamos los tres siguientes: \n1)Seg\u00fan se pueden expresar o no en  t\u00e9rminos de otras operaciones.\na) Operaciones primitivas:  son aquellas operaciones a partir de las cuales po-\ndemos definir el resto. Esta s operaciones son la uni\u00f3n, la diferencia, el produc-\nto cartesiano, la sele cci\u00f3n y la proyecci\u00f3n.\nb) Operaciones no primitivas:  el resto de las operaciones del \u00e1lgebra relacio-\nnal que no son estric tamente necesarias, porque se pueden expresar en t\u00e9rmi-\nnos de las primitivas; sin embargo, la s operaciones no primitivas permiten\nformular algunas consultas de forma m\u00e1 s c\u00f3moda. Existen distintas versiones\ndel \u00e1lgebra relacional, seg\u00fan las operaciones no primitivas que se incluyen. No-\nsotros estudiaremos las operaciones no pr imitivas que se utilizan con mayor fre-\ncuencia: la intersecci\u00f3n y la combinaci\u00f3n.\n2)Seg\u00fan el n\u00famero de relaciones que tienen como operandos:\na) Operaciones binarias: son las que tienen dos re laciones como operandos.\nSon binarias todas las operaciones, ex cepto la selecci\u00f3n y la proyecci\u00f3n.Una caracter\u00edstica destacable de todas las operaciones del \u00e1lgebra rela-\ncional es que tanto los operandos como el resultado son relaciones. Estapropiedad se denomina cierre relacional .Consultad el apartado 3 \nde esta unidad did\u00e1ctica.\nImplicaciones del cierre \nrelacional\nEl hecho de que el resultado \nde una operaci\u00f3n del \u00e1lgebra relacional sea una nuevarelaci\u00f3n tiene implicaciones importantes:\n1.El resultado de una opera-\nci\u00f3n puede actuar comooperando de otra operaci\u00f3n.\n2.El resultado de una \noperaci\u00f3n cumplir\u00e1 todas las caracter\u00edsticas que ya conocemos de las relaciones: no-ordenaci\u00f3n de las tuplas, ausencia de tuplas repetidas, etc.\n\uf8e9 FUOC \u2022 71Z799014MO 34 El modelo relacional y el \u00e1lgebra relacional\nb) Operaciones unarias:  son las que tienen una sola relaci\u00f3n como operan-\ndo. La selecci\u00f3n y la proyecci\u00f3n son unarias.\n3)Seg\u00fan se parecen o no a las operac iones de la teor \u00eda de conjuntos:\na) Operaciones conjuntistas: son las que se parecen a las de la teor\u00eda de\nconjuntos. Se trata de la uni\u00f3n, la intersecci\u00f3n, la diferencia y el productocartesiano.\nb) Operaciones espec\u00edficamente relacionales:  son el resto de las operaciones;\nes decir, la selecci\u00f3n, la proyecci\u00f3n y la combinaci\u00f3n.\nComo ya hemos comentado anteriormente,  las operaciones del \u00e1lgebra relacional\nobtienen como resultado un a nueva relaci\u00f3n. Es decir que si hacemos una opera-\nci\u00f3n del \u00e1lgebra como por ejemplo  EMPLEADOS_ADM  \u222a \u222a\n EMPLEADOS_PROD\npara obtener la uni\u00f3n de las relaciones EMPLEADOS_ADM  y EMPLEADOS_PROD ,\nel resultado de la operaci\u00f3n es una nueva relaci\u00f3n que tiene la uni\u00f3n de las tuplas\nde las relaciones de partida.\nEsta nueva relaci\u00f3n debe tener un nomb re. En principio, consideramos que su\nnombre es la misma expres i\u00f3n del \u00e1lgebra relacional que la obtiene; es decir,\nla misma expresi\u00f3n EMPLEADOS_ADM  \u222a EMPLEADOS_PROD . Puesto que este\nnombre es largo, en ocasiones puede ser interesante camb iarlo por uno m\u00e1s\nsimple. Esto nos facilitar\u00e1 las referencia s a la nueva relaci\u00f3n, y ser\u00e1 especial-\nmente \u00fatil en los casos en los que quer amos utilizarla como operando de otra\noperaci\u00f3n. Usaremos la operaci\u00f3n auxiliar redenominar con este objetivo.\nEn el ejemplo, para dar el nombre EMPLEADOS  a la relaci\u00f3n resultante de la\noperaci\u00f3n EMPLEADOS_ADM  \u222a EMPLEADOS_PROD , har\u00edamos:\nEMPLEADOS := EMPLEADOS_ADM \u222a EMPLEADOS_PROD.\nCada operaci\u00f3n del \u00e1lgebra relacional da unos nombres por defecto a los atri-\nbutos del esquema de la re laci\u00f3n resultante, tal y como veremos m\u00e1s adelante.\nEn algunos casos, puede ser necesario cambiar estos nombres por defecto por\notros nombres. Por este motivo, tambi\u00e9n permitiremos cambiar el nombre de\nla relaci\u00f3n y de sus atribu tos mediante la operaci\u00f3n redenominar .La operaci\u00f3n redenominar , que denotaremos con el s\u00edmbolo : =, permi-\nte asignar un nombre R a la relaci\u00f3n que resu lta de una operaci\u00f3n del\n\u00e1lgebra relacional; lo hace  de la forma siguiente:\nR := E,\nsiendo E la expresi\u00f3n de una operac i\u00f3n del \u00e1lgebra relacional.Las operaciones del \u00e1lgebra \nrelacional clasificadas seg\u00fan sean conjuntistas o espec\u00edficamente relacionales se estudian en los subapartados 5.1 y 5.2 de esta unidad.\n\uf8e9 FUOC \u2022 71Z799014MO 35 El modelo relacional y el \u00e1lgebra relacional\nA continuaci\u00f3n presentaremos un ejempl o que utilizaremos para ilustrar las\noperaciones del \u00e1lgebra relacional. De spu\u00e9s veremos con detalle las opera-\nciones. \nSupongamos que tenemos una base de datos relacional con las cuatro rela-\nciones siguientes:\n1)La relaci\u00f3n  EDIFICIOS_EMP , que contiene datos de di stintos edificios de los\nque una empresa dispone para  desarrollar sus actividades.\n2)La relaci\u00f3n DESPACHOS , que contiene datos de cada uno de los despachos\nque hay en los edificios anteriores.\n3)La relaci\u00f3n  EMPLEADOS_ADM , que contiene los datos de los empleados de\nla empresa que llevan a cabo  tareas administrativas.\n4)La relaci\u00f3n EMPLEADOS_PROD , que almacena los da tos de los empleados\nde la empresa que se ocupan de tareas de producci\u00f3n.\nA continuaci\u00f3n describimos los esquemas de las relaciones anteriores y sus ex-\ntensiones en un mo mento determinado:\n\u2022 Esquema y extensi\u00f3n de EDIFICIOS_EMP :\n\u2022 Esquema y extensi\u00f3n de DESPACHOS :Utilizaremos tambi\u00e9n la operaci\u00f3n redenominar  para cambiar el esquema\nde una relaci\u00f3n. Si una re laci\u00f3n tiene el esquema S( B1, B2, ..., Bn) y que-\nremos cambiarlo por R( A1, A2, ..., An), lo haremos de la siguiente forma:\nR(A1, A2, ..., An) := S( B1, B2, ..., Bn).\nEDIFICIOS_EMP\nedificio supmediadesp\nMarina 15\nDiagonal 10\nDESPACHOS\nedificio n\u00famero superficie\nMarina 120 10Marina 230 20\nDiagonal 120 10\nDiagonal 440 10\n\uf8e9 FUOC \u2022 71Z799014MO 36 El modelo relacional y el \u00e1lgebra relacional\n\u2022 Esquema y extensi\u00f3n de EMPLEADOS_ADM :\n\u2022 Esquema y extensi\u00f3n de EMPLEADOS_PROD :\nSe considera que los valores nulos de los atributos edificiodesp  y n\u00famerodesp  de\nlas relaciones EMPLEADOS_PROD  y EMPLEADOS_ADM  indican que el emplea-\ndo correspondiente no tiene despacho.\n5.1. Operaciones conjuntistas\nLas operaciones conjuntistas del \u00e1lgebra relacional son la uni\u00f3n , la intersecci\u00f3n ,\nla diferencia  y el producto cartesiano .\n5.1.1. Uni\u00f3n\nLa uni\u00f3n de las relaciones EMPLEADOS_ADM  y EMPLEADOS_PROD  proporciona una nueva\nrelaci\u00f3n que contiene tanto a los empleados de  administraci\u00f3n como los empleados de pro-\nducci\u00f3n; se indicar\u00eda as\u00ed: EMPLEADOS_ADM  \u222a EMPLEADOS_PROD .\nS\u00f3lo tiene sentido aplicar la uni\u00f3n a re laciones que tengan tuplas similares.\nPor ejemplo, se puede hacer la uni\u00f3n de la s relaciones EMPLEADO S_ADM y EMPLEADOS_PROD\nporque sus tuplas se parecen. En cambio, no se podr\u00e1 hacer la uni\u00f3n de las relaciones\nEMPLEADOS_ADM y DESPACHOS porque, como hab\u00e9is podido observar en las tablas,\nlas tuplas respectivas son de tipo diferente.EMPLEADOS_ADM\nDNI nombre apellido edificiodesp n\u00famerodesp\n40.444.255 Juan Garc\u00eda Marina 12033.567.711 Marta Roca Marina 120\nEMPLEADOS_PROD\nDNI nombreemp apellidoemp edificiodesp n\u00famerodesp\n33.567.711 Marta Roca Marina 12055.898.425 Carlos Buend\u00eda Diagonal 12077.232.144 Elena Pla Marina 23021.335.245 Jorge Soler NULO NULO88.999.210 Pedro Gonz\u00e1lez NULO NULO\nLa uni\u00f3n es una operaci\u00f3n que, a pa rtir de dos relaciones, obtiene una\nnueva relaci\u00f3n formada por todas las tuplas que est\u00e1n en alguna de las\nrelaciones de partida.\nLa uni\u00f3n es una operaci\u00f3n binaria,  y la uni\u00f3n de dos relaciones T y S se\nindica T \u222a S.\uf8e9 FUOC \u2022 71Z799014MO 37 El modelo relacional y el \u00e1lgebra relacional\nM\u00e1s concretamente, para poder aplicar la uni\u00f3n a dos relaciones, es preciso\nque las dos relaciones sean compat ibles. Decimos que dos relaciones T y S son\nrelaciones compatibles si: \n\u2022 Tienen el mismo grado.\u2022 Se puede establecer una biye cci\u00f3n entre los atributos de T y los atributos de\nS que hace corresponder a cada atributo A\ni de T un atributo Aj de S, de\nmodo que se cumple que dominio( Ai) = dominio( Aj).\nEjemplo de relaciones compatibles\nLas relaciones EMPLEADOS_ADM  y EMPLEADOS_PROD  tienen grado 5. Podemos establecer\nla siguiente biyecci\u00f3n entre sus atributos:\n\u2022A  DNI de EMPLEADOS_ADM  le corresponde DNIemp  de EMPLEADOS_PROD .\n\u2022A  nombre de EMPLEADOS_ADM  le corresponde nombreemp  de EMPLEADOS_PROD .\n\u2022A  apellido  de EMPLEADOS_ADM  le corresponde apellidoemp  de EMPLEADOS_PROD .\n\u2022A  edificiodesp  de EMPLEADOS_ADM  le corresponde edificiodesp  de EMPLEADOS_PROD .\n\u2022A  n\u00famerodesp  de EMPLEADOS_ADM  le corresponde edificiodesp  de EMPLEADOS_PROD .\nAdem\u00e1s, supondremos que los dominios de sus atributos se han declarado de forma que se\ncumple que el dominio de cada atributo de EMPLEADOS_ADM  sea el mismo que el dominio\nde su atributo correspondiente en EMPLEADOS_PROD .\nPor todos estos factores , podemos llegar a la conclusi\u00f3n de que EMPLEADOS_ADM  y\nEMPLEADOS_PROD  son relaciones compatibles.\nA continuaci\u00f3n, pasaremos a definir los at ributos y la extens i\u00f3n de la relaci\u00f3n\nresultante de una uni\u00f3n.\nEjemplo de uni\u00f3n\nSi queremos obtener una relaci\u00f3n R que tenga a todos los empleados de la empresa\ndel ejemplo anterior, lle varemos a cabo la uni\u00f3 n de las relaciones EMPLEADOS_ADM\ny EMPLEADOS_PROD  de la forma siguiente:\nR := EMPLEADOS_ADM \u222a EMPLEADOS_PROD.\nEntonces la relaci\u00f3n R resultante ser\u00e1 la reflejada en la tabla siguiente:Los atributos del esquema de la relaci\u00f3n resultante de T \u222a S coinci-\nden con los atributos del esquema de la relaci\u00f3n T.\nLa extensi\u00f3n de la rel aci\u00f3n resultante de T \u222a S es el conjunto de tu-\nplas que pertenecen a la extensi\u00f3n de T, a la extensi\u00f3n de S o a la exten-\nsi\u00f3n de ambas relaciones.\nR\nDNI nombre apellido edificiodesp n\u00famerodesp\n40.444.255 Juan Garc\u00eda Marina 12033.567.711 Marta Roca Marina 120\n55.898.425 Carlos Buend\u00eda Diagonal 120\nNo-repetici\u00f3n de tuplas\nNotad que en caso de que \nuna misma tupla est\u00e9 en las dos relaciones que se unen, el resultado de la uni\u00f3n no la tendr\u00e1 repetida. El resultado de la uni\u00f3n es una nueva rela-ci\u00f3n por lo que no puede tener repeticiones de tuplas.\uf8e9 FUOC \u2022 71Z799014MO 38 El modelo relacional y el \u00e1lgebra relacional\nEl hecho de que los atributos de la rela ci\u00f3n resultante coincidan con los atri-\nbutos de la relaci\u00f3n que figura en prim er lugar en la uni\u00f3n es una convenci\u00f3n;\nte\u00f3ricamente, tambi\u00e9n habr\u00eda  sido posible convenir que coincidiesen con los\nde la relaci\u00f3n que figu ra en segundo lugar. \n5.1.2. Intersecci\u00f3n\nLa intersecci\u00f3n de las relaciones EMPLEADOS_ADM  y EMPLEADOS_PROD  obtiene una nueva\nrelaci\u00f3n que incluye a los empleados que son al mismo tiempo de administraci\u00f3n y de pro-\nducci\u00f3n: se indicar\u00eda como EMPLEADOS_ADM  \u2229 EMPLEADOS_PROD .\nLa intersecci\u00f3n, como la uni\u00f3n, s\u00f3lo se puede aplicar a relaciones que tengan\ntuplas similares. Para pode r hacer la intersecci\u00f3n de dos relaciones, es preciso,\npues, que las relacion es sean compatibles.\nA continuaci\u00f3n definiremos los atributos y la extensi\u00f3n de la relaci\u00f3n resul-\ntante de una intersecci\u00f3n.\nEjemplo de intersecci\u00f3n\nSi queremos obtener una relaci\u00f3n R que incluya a todos los empleados de la empresa del\nejemplo que trabajan tanto en administraci\u00f3n como en producci\u00f3n, realizaremos la inter-\nsecci\u00f3n de las relaciones EMPLEADOS_ADM  y EMPLEADOS_PROD  de la forma siguiente:\nR : = EMPLEADOS_ADM \u2229 EMPLEADOS_PROD.R\nDNI nombre apellido edificiodesp n\u00famerodesp\n77.232.144 Elena Pla Marina 230\n21.335.245 Jorge Soler NULO NULO\n88.999.210 Pedro Gonz\u00e1lez NULO NULO\nLa intersecci\u00f3n es una operaci\u00f3n que,  a partir de dos relaciones, obtiene\nuna nueva relaci\u00f3n formada por las tu plas que pertenecen a las dos re-\nlaciones de partida.\nLa intersecci\u00f3n es una operaci\u00f3n bina ria; la intersecci\u00f3n de dos relacio-\nnes T y S se indica T \u2229 S.\nLos atributos  del esquema de la relaci\u00f3n resultante de T \u2229 S coinci-\nden con los atributos del esquema de la relaci\u00f3n T.\nLa extensi\u00f3n de la relaci\u00f3n resultante de T \u2229 S es el conjunto de tu-\nplas que pertenecen a la ex tensi\u00f3n de ambas relaciones.\n\uf8e9 FUOC \u2022 71Z799014MO 39 El modelo relacional y el \u00e1lgebra relacional\nEntonces, la relaci\u00f3n R resultante ser\u00e1:\nObservad que se ha tomado la convenci\u00f3n de que los atributos de la relaci\u00f3n\nque resulta coincidan con los atributos de la relaci\u00f3n que figura en primer lugar.\n5.1.3. Diferencia\nLa diferencia EMPLEADOS_ADM  menos EMPLEADOS_PROD  da como resultado una nueva re-\nlaci\u00f3n que contiene a los empleados de admini straci\u00f3n que no son empleados de producci\u00f3n,\ny se indicar\u00eda de este modo: EMPLEADOS_ADM \u2013 EMPLEADOS_PROD .\nLa diferencia, como ocurr\u00eda en la uni\u00f3n y la intersecci\u00f3n, s\u00f3lo tiene sentido si\nse aplica a relaciones que tengan tuplas similares. Para pode r realizar la dife-\nrencia de dos relaciones es necesari o que las relaciones sean compatibles.\nA continuaci\u00f3n definimos los atributos y la extensi\u00f3n de la relaci\u00f3n resultante\nde una diferencia.\nEjemplo de diferencia\nSi queremos obtener una relaci\u00f3n R con todos los empleados de la empresa del ejemplo que\ntrabajan en administraci\u00f3n, pero no en produ cci\u00f3n, haremos la difere ncia de las relaciones\nEMPLEADOS_ADM  y EMPLEADOS_PROD  de la forma siguiente:\nR := EMPLEADOS_ADM \u2013 EMPLEADOS_PROD\nEntonces la relaci\u00f3n R resultante ser\u00e1:\nSe ha tomado la convenci\u00f3n de que los atributos de la rela ci\u00f3n resultante co-\nincidan con los atributos de la rela ci\u00f3n que figura en primer lugar.R\nDNI nombre apellido edificiodesp n\u00famerodesp\n33.567.711 Marta Roca Marina 120\nLa diferencia es una oper aci\u00f3n que, a partir de dos relaciones, obtiene una\nnueva relaci\u00f3n formada por todas las tuplas que est\u00e1n en la primera rela-ci\u00f3n y, en cambio, no est\u00e1n en la segunda. La diferencia es una operaci\u00f3nbinaria, y la diferencia entre las relaciones T y S se indica como T \u2013 S.\nLos atributos del esquema de la relaci\u00f3n resultante de T \u2013 S  coinci-\nden con los atributos del esquema de la relaci\u00f3n T.\nLa extensi\u00f3n de la relaci\u00f3n resultante de T \u2013 S  es el conjunto de tuplas\nque pertenecen a la extensi\u00f3n de T, pero no a la de S.\nR\nDNI nombre apellido edificiodesp n\u00famerodesp\n40.444.255 Juan Garc\u00eda Marina 120\uf8e9 FUOC \u2022 71Z799014MO 40 El modelo relacional y el \u00e1lgebra relacional\n5.1.4. Producto cartesiano\nSi calculamos el producto cartesiano de  EDIFICIOS_EMP  y DESPACHOS , obtendremos una\nnueva relaci\u00f3n que contiene todas las co ncatenaciones posibles de tuplas de EDIFICIOS_EMP\ncon tuplas de DESPACHOS .\nSi se quiere calcular el producto cartes iano de dos relaciones que tienen alg\u00fan\nnombre de atributo com\u00fan, s\u00f3lo hace falta redenominar pr eviamente los atri-\nbutos adecuados de una de las dos relaciones. \nA continuaci\u00f3n definimos los atributos y la extensi\u00f3n de la relaci\u00f3n resultante\nde un producto cartesiano.\nEjemplo de producto cartesiano\nEl producto cartesiano de las relaciones DESPACHOS  y EDIFICIOS_EMP  del ejemplo se puede\nhacer como se indica (es necesario redenominar atributos previamente):\nEDIFICIOS( nombreedificio , supmediadesp ) := EDICIOS_EMP( edificio , supmediadesp ).\nR := EDIFICIOS \u00d7 DESPACHOS.\nEntonces, la relaci\u00f3n R resultante ser\u00e1:El producto cartesiano es una operac i\u00f3n que, a partir de dos relaciones,\nobtiene una nueva relaci\u00f3n formada por todas las tuplas que resultan\nde concatenar tuplas de la primera relaci\u00f3n con tuplas de la segunda.\nEl producto cartesiano es un a operaci\u00f3n binaria. Siendo T y S dos rela-\nciones que cumplen que sus esquemas no tienen ning\u00fan nombre deatributo com\u00fan, el producto cartesiano de T y S se indica como T \u00d7 S.\nLos atributos del esquema de la  relaci\u00f3n resultante de T \u00d7 S son todos\nlos atributos de T y todos los atributos de S*.\nLa extensi\u00f3n de la relaci\u00f3n resultante de T \u00d7 S es el conjunto de todas\nlas tuplas de la forma < v1, v2, ..., vn, w1, w2, ..., wm> para las que se cum-\nple que < v1, v2, ..., vn> pertenece a la extensi\u00f3n de T y que < w1, w2, ...,\nwm> pertenece a la extensi\u00f3n de S.\nR\nnombreedificio supmediadesp edificio n\u00famero superficie\nMarina 15 Marina 120 10Marina 15 Marina 230 20Marina 15 Diagonal 120 10Marina 15 Diagonal 440 10\nDiagonal 10 Marina 120 10\n* Recordad que T y S no tienen \nning\u00fan nombre de atributo com\u00fan.\uf8e9 FUOC \u2022 71Z799014MO 41 El modelo relacional y el \u00e1lgebra relacional\nConviene se\u00f1alar que el pr oducto cartesiano es un a operaci\u00f3n que raramente\nse utiliza de forma expl\u00edcit a, porque el resultado qu e da no suele ser \u00fatil para\nresolver las consultas habituales.\nA pesar de ello, el producto cartesiano se incluye en el \u00e1lgebra relacional por-\nque es una operaci\u00f3n primitiv a; a partir de la cual se define otra operaci\u00f3n del\n\u00e1lgebra, la combinaci\u00f3n, que se utiliza con mucha frecuencia. \n5.2. Operaciones espec\u00edficamente relacionales\nLas operaciones espec\u00edficame nte relacionales son la selecci\u00f3n , la proyecci\u00f3n\ny la combinaci\u00f3n .\n5.2.1. Selecci\u00f3n\nPara obtener una relaci\u00f3n que tenga todos los despachos del ed ificio Marina que tienen m\u00e1s\nde 12 metros cuadrados, podemos ap licar una selecci\u00f3n a la relaci\u00f3n  DESPACHOS  con una\ncondici\u00f3n de selecci\u00f3n que sea edificio  = Marina y  superficie > 12; se indicar\u00eda DESPA-\nCHOS( edificio  = Marina y superficie  > 12).\nEn general, la condici\u00f3n de selecci\u00f3n C est\u00e1 formad a por una o m\u00e1s cl\u00e1usulas\nde la forma:\nAi \u03b8 v,\no bien:\nAi \u03b8 Aj, R\nnombreedificio supmediadesp edificio n\u00famero superficie\nDiagonal 10 Marina 230 20Diagonal 10 Diagonal 120 10Diagonal 10 Diagonal 440 10\nPodemos ver la selecci\u00f3n como una op eraci\u00f3n que sirve para elegir al-\ngunas tuplas de una relaci\u00f3n y elimin ar el resto. M\u00e1s concretamente, la\nselecci\u00f3n es una operaci\u00f3 n que, a partir de una relaci\u00f3n, obtiene una\nnueva relaci\u00f3n formada po r todas las tuplas de la  relaci\u00f3n de partida\nque cumplen una condici\u00f3n de selecci\u00f3n especificada.\nLa selecci\u00f3n es una operaci\u00f3n unaria. Siendo C una condici\u00f3n de se-\nlecci\u00f3n, la selecci\u00f3n de T con la condici\u00f3n C se indica como T( C).\n\uf8e9 FUOC \u2022 71Z799014MO 42 El modelo relacional y el \u00e1lgebra relacional\ndonde Ai y Aj son atributos de la relaci\u00f3n T, \u03b8 es un operador de comparaci\u00f3n*\ny v es un valor. Adem\u00e1s, se cumple que:\n\u2022 En las cl\u00e1usulas de la forma Ai \u03b8 v, v es un valor del dominio de Ai.\n\u2022 En las cl\u00e1usulas de la forma Ai, \u03b8 Aj, Ai y Aj tienen el mismo dominio.\nLas cl\u00e1usulas que forman una condici\u00f3n de selecci\u00f3n se conectan con los si-\nguientes operadores booleanos: \u201cy\u201d ( \u2227) y \u201co\u201d ( \u2228).\nA continuaci\u00f3n definimos los atributos y la extensi\u00f3n de la relaci\u00f3n resultante\nde una selecci\u00f3n.\nEjemplo de selecci\u00f3n\nSi queremos obtener una relaci\u00f3n R con los despachos de la ba se de datos del ejemplo que\nest\u00e1n en el edificio Marina y que tienen una superficie de m\u00e1s de 12 metros cuadrados, ha-\nremos la siguiente selecci\u00f3n:\nR := DESPACHOS(edificio = Marina  y superficie >  12).\nLa relaci\u00f3n R resultante ser\u00e1:\n5.2.2. Proyecci\u00f3nLos atributos del esquema de la relaci\u00f3n resultante de T( C) coinciden\ncon los atributos del es quema de la relaci\u00f3n T.\nLa extensi\u00f3n de la relaci\u00f3n resultante de T( C) es el conjunto de tuplas\nque pertenecen a la extensi\u00f3n de T y que satisfacen la condici\u00f3n de se-\nlecci\u00f3n C. Una tupla t satisface una condici\u00f3n de selecci\u00f3n C si, despu\u00e9s\nde sustituir cada atributo qu e hay en C por su valor en t, la condici\u00f3n C\nse eval\u00faa en el valor cierto.\nR\nedificio n\u00famero superficie\nMarina 230 20\nPodemos considerar la proyecci\u00f3n como una operaci\u00f3n que sirve para\nelegir algunos atributos de una relaci \u00f3n y eliminar el resto. M\u00e1s concre-\ntamente, la proyecci\u00f3n es una operac i\u00f3n que, a partir de una relaci\u00f3n,\nobtiene una nueva relaci\u00f3n formada po r todas las (sub)t uplas de la re-\nlaci\u00f3n de partida que resultan de e liminar unos atributos especificados.* Es decir, =, \u2260, <, \u2264, >, o \u2265.\uf8e9 FUOC \u2022 71Z799014MO 43 El modelo relacional y el \u00e1lgebra relacional\nPara obtener una relaci\u00f3n que tenga s\u00f3lo los atributos nombre y apellido  de los empleados de\nadministraci\u00f3n, podemos hacer un a proyecci\u00f3n en la relaci\u00f3n EMPLEADOS_ADM  sobre estos\ndos atributos. Se indicar\u00ed a de la forma siguiente: EMPLEADOS_ADM  [nombre, apellido ].\nA continuaci\u00f3n definiremos los atributos y la extensi\u00f3n de la relaci\u00f3n resul-\ntante de una proyecci\u00f3n.\nEjemplo de proyecci\u00f3n\nSi queremos obtener una relaci\u00f3n R con el nombre y el apellido de todos los empleados de\nadministraci\u00f3n de la base de datos del ejemplo, haremos la siguiente proyecci\u00f3n:\nR := EMPLEADOS_ADM[ nombre, apellido ].\nEntonces, la relaci\u00f3n R resultante ser\u00e1:\n5.2.3. Combinaci\u00f3nLa proyecci\u00f3n es una operaci\u00f3n unaria. Siendo { Ai, Aj, ..., Ak} un subcon-\njunto de los atributos del esquema de la relaci\u00f3n T, la proyecci\u00f3n de T\nsobre { Ai, Aj, ..., Ak} se indica como T[ Ai, Aj, ..., Ak].\nLos atributos del esquema de la  relaci\u00f3n resultante de T[ Ai, Aj, ..., Ak]\nson los atributos { Ai, Aj, ..., Ak}.\nLa extensi\u00f3n de la relaci\u00f3n resultante de T[ Ai, Aj, ..., Ak] es el conjun-\nto de todas las tuplas de la forma < t.Ai, t.Aj, ..., t.Ak>, donde se cumple\nque t es una tupla de la extensi\u00f3n de T y donde t.Ap denota el valor para\nel atributo Ap de la tupla t.\nR\nnombre apellido\nJuan Garc\u00eda\nMarta Roca\nLa combinaci\u00f3n es una operaci\u00f3n que,  a partir de dos relaciones, obtie-\nne una nueva relaci\u00f3n formada por to das las tuplas que resultan de con-\ncadenar tuplas de la primera relaci\u00f3n  con tuplas de la segunda, y que\ncumplen una condici\u00f3n de combinaci\u00f3n especificada.\nLa combinaci\u00f3n es una operaci\u00f3n binaria. Siendo T y S dos relaciones\ncuyos esquemas no tienen ning\u00fan no mbre de atributo com\u00fan, y siendo\nB una condici\u00f3n de combinac i\u00f3n, la combinaci\u00f3n de T y S seg\u00fan la con-\ndici\u00f3n B se indica T[B]S.Eliminaci\u00f3n de las tuplas \nrepetidas\nNotad que la proyecci\u00f3n \nelimina impl\u00edcitamente todas las tuplas repetidas. El resulta-do de una proyecci\u00f3n es una relaci\u00f3n v\u00e1lida y no puede tener repeticiones de tuplas.\uf8e9 FUOC \u2022 71Z799014MO 44 El modelo relacional y el \u00e1lgebra relacional\nPara conseguir una relaci\u00f3n que tenga los da tos de cada uno de los empleados de admi-\nnistraci\u00f3n junto con los datos de los despachos donde trabajan, podemos hacer una com-binaci\u00f3n de las relaciones EMPLEADOS_ADM  y DESPACHOS , donde la condici\u00f3n de\ncombinaci\u00f3n indique lo siguiente: edificiodesp = edificio  y n\u00famerodesp = n\u00famero . La condi-\nci\u00f3n de combinaci\u00f3n hace que el resultado s\u00f3lo combine los datos de un empleado con\nlos datos de un despacho si el edificiodesp  y el n\u00famerodesp  del empleado son iguales que\nel edificio y el n\u00famero del despacho, respecti vamente. Es decir, la condici\u00f3n hace que los\ndatos de un empleado se combinen con los datos del despacho donde trabaja, pero no\ncon datos de otros despachos.\nLa combinaci\u00f3n del ejemplo anterior se indicar\u00eda de la forma siguiente:\nEMPLEADOS_ADM [edificiodesp  = edificio, n\u00famerodesp = n\u00famero ]DESPACHOS .\nSi se quiere combinar dos relaciones que tienen alg\u00fan nombre de atributo co-\nm\u00fan, s\u00f3lo hace falta redenominar prev iamente los atributo s repetidos de una\nde las dos.\nEn general, la condici\u00f3n B  de una combinaci\u00f3n T[B]S est\u00e1 formada por una o\nm\u00e1s comparaciones de la forma\nAi \u03b8 Aj,\ndonde Ai es un atributo de la relaci\u00f3n T, Aj es un atributo de la relaci\u00f3n S, \u03b8 es\nun operador de comparaci\u00f3n ( =, \u2260, <, \u2264, >, \u2265), y se cumple que Ai y Aj tienen\nel mismo dominio. Las comparaciones de una condici\u00f3n de combinaci\u00f3n se\nseparan mediante comas.\nA continuaci\u00f3n definimos los atributos y la extensi\u00f3n de la relaci\u00f3n resultante\nde una combinaci\u00f3n.\nEjemplo de combinaci\u00f3n\nSupongamos que se desea encontrar los datos de los despachos que tienen una superficie ma-\nyor o igual que la superficie media de los despachos del edificio donde est\u00e1n situados. La si-\nguiente combinaci\u00f3n nos proporcionar\u00e1 los dato s de estos despachos junto con los datos de\nsu edificio (observad que es preciso redenominar previamente los atributos):\nEDIFICIOS( nombreeedficio,supmediadesp ) := EDIFICIOS_EMP(e dificio, supmediadesp ),Los atributos del esquema de la relaci\u00f3n resultante de T[B]S son to-\ndos los atributos de T y todos los atributos de S*.\nLa extensi\u00f3n de la relaci\u00f3n resultante de T[B]S es el conjunto de tu-\nplas que pertenecen a la extensi\u00f3n del producto cartesiano T \u00d7 S y que\nsatisfacen todas las comparaciones que forman la condici\u00f3n de combi-\nnaci\u00f3n B. Una tupla t satisface una comparaci\u00f3n si, despu\u00e9s de sustituir\ncada atributo que figura en la comparaci\u00f3n por su valor en  t, la compa-\nraci\u00f3n se eval\u00faa al valor cierto.* Recordad que T y S no tienen \nning\u00fan nombre de atributo com\u00fan.\uf8e9 FUOC \u2022 71Z799014MO 45 El modelo relacional y el \u00e1lgebra relacional\nR := EDIFICIOS [nombreedificio = edificio, supmediadesp \u2264 superficie ] DESPACHOS.\nEntonces, la relaci\u00f3n R resultante ser\u00e1:\nSupongamos ahora que para obtener los datos de  cada uno de los empleados de administra-\nci\u00f3n, junto con los datos del despacho donde trabajan, utilizamos la siguiente combinaci\u00f3n:\nR := EMPLEADOS_ADM[edificiodesp = edificio, n\u00famerodesp = n\u00famero]DESPACHOS .\nLa relaci\u00f3n R resultante ser\u00e1:\nLa relaci\u00f3n R combina los datos de cada emplea do con los datos de su despacho.\nEn ocasiones, la combinac i\u00f3n recibe el nombre de \u03b8-combinaci\u00f3n , y cuando\ntodas las comparaciones de la condici\u00f3n de la combinaci\u00f3n tienen el operador\n\u201c=\u201d, se denomina equicombinaci\u00f3n . \nSeg\u00fan esto, la combinaci\u00f3n del \u00faltimo ejemplo es una equicombinaci\u00f3n.\nObservad que el resultado de una equicombinaci\u00f3n siempre incluye una o\nm\u00e1s parejas de atributos que tienen va lores id\u00e9nticos en todas las tuplas.\nEn el ejemplo anterior, los valores de edificiodesp  coinciden con los de edificio , y los valores de\nn\u00famerodesp  coinciden con los de n\u00famero .\nPuesto que uno de cada par de atributos es superfluo, se ha establecido una\nvariante de combinaci\u00f3n denominada combinaci\u00f3n natural , con el fin de\neliminarlos.\nEjemplo de combinaci\u00f3n natural\nSi hacemos:\nR := EDIFICIOS_EMP * DESPACHOS,R\nnombreedificio supmediadesp edificio n\u00famero superficie\nMarina 15 Marina 230 20\nDiagonal 10 Diagonal 120 10\nDiagonal 10 Diagonal 440 10\nR\nDNI nombre apellido edificiodesp n\u00famerodesp edificio n\u00famero superficie\n40.444.255 Juan Garc\u00eda Marina 120 Marina 120 1033.567.711 Marta Roca Marina 120 Marina 120 10\nLa combinaci\u00f3n natural  de dos relaciones T y S se denota como T * S\ny consiste b\u00e1sicamente en una equi combinaci\u00f3n seguida de la elimina-\nci\u00f3n de los atributos superfluos; adem\u00e1s, se considera por defecto quela condici\u00f3n de combinaci\u00f3n iguala todas las parejas de atributos que\ntienen el mismo nombre en T y en S.\nObservad que, a diferencia de la equicombinaci\u00f3n, la combinaci\u00f3n na-\ntural se aplica a relaciones que ti enen nombres de atributos comunes.\uf8e9 FUOC \u2022 71Z799014MO 46 El modelo relacional y el \u00e1lgebra relacional\nse considera que la condici\u00f3n es edificio = edificio  porque edificio  es el \u00fanico nombre de atri-\nbuto que figura tanto en el esquema de EDIFICIOS_EMP  como en el esquema de DESPACHOS .\nEl resultado de esta combinaci\u00f3n natural es:\nNotad que se ha eliminado uno de los atributos de nombre edificio .\nEn ocasiones, antes de la combinaci\u00f3n natural es necesari o aplicar la opera-\nci\u00f3n redenominar  para hacer coincidir los nombre s de los atributos que nos in-\nteresa igualar.\nEjemplo de combinaci\u00f3n natural con redenominaci\u00f3n\nPor ejemplo, si queremos obtener los datos de  cada uno de los empleados de administraci\u00f3n\njunto con los datos del despacho donde trabajan pero sin repetir valores de atributos super-fluos, haremos la siguiente combinaci\u00f3n natura l, que requiere una re denominaci\u00f3n previa:\nD(edificiodesp, n\u00fame rodesp, superficie ) := DESPACHOS( edificio, n\u00famero, superficie ), \nR := EMPLEADOS_ADM * D.\nEntonces, la relaci\u00f3n R resultante ser\u00e1:\n5.3. Secuencias de operaciones del \u00e1lgebra relacionalR\nedificio supmediadesp n\u00famero superficie\nMarina 15 120 10Marina 15 230 20\nDiagonal 10 120 10Diagonal 10 440 10\nR\nDNI nombre apellido edificiodesp n\u00famerodesp superficie\n40.444.255 Juan Garc\u00eda Marina 120 1033.567.711 Marta Roca Marina 120 10\nEn muchos casos, para formular un a consulta en \u00e1lgebra relacional es\npreciso utilizar varias operaciones, que se aplican en un cierto orden.\nPara hacerlo, hay dos posibilidades:\n1)Utilizar una sola expresi\u00f3n del \u00e1l gebra que incluya todas las opera-\nciones con los par\u00e9ntesis necesarios para indicar el orden de aplicaci\u00f3n.\n2)Descomponer la expresi\u00f3n en vari os pasos donde cada paso aplique\nuna sola operaci\u00f3n y obtenga una relaci\u00f3n intermedia que se pueda uti-lizar en los pasos subsiguientes.\uf8e9 FUOC \u2022 71Z799014MO 47 El modelo relacional y el \u00e1lgebra relacional\nEjemplo de utilizaci\u00f3n de secuencias de operaciones\nPara obtener el nombre y el ap ellido de los empleados, tanto de administraci\u00f3n como de pro-\nducci\u00f3n, es necesario hacer una uni\u00f3n de EMPLEADOS_ADM  y EMPLEADOS_PROD , y des-\npu\u00e9s hacer una proyecci\u00f3n sobre los atributos nombre  y apellido . La operaci\u00f3n se puede\nexpresar de las formas siguientes:\na)Se puede utilizar una sola expresi\u00f3n:\nR := (EMPLEADOS_ADM \u222a EMPLEADOS_PROD ) [nombre, apellido ].\nb)O bien podemos expresarlo en dos pasos:\n\u2022 EMPS := EMPLEADOS_ADM \u222a EMPLEADOS_PROD;\n\u2022R := EMPS[ nombre, apellido ]\nEn los casos en que una consulta requiere efectuar muchas operaciones, resul-\nta m\u00e1s sencilla la segund a alternativa, porque evita expresiones complejas. \nOtros ejemplos de consultas formuladas con secuencias de operaciones\nVeamos algunos ejemplos de consultas en la ba se de datos formuladas con secuencias de ope-\nraciones del \u00e1lgebra relacional.\n1)Para obtener el nombre del edif icio y el n\u00famero de los despachos situados en edificios en\nlos que la superficie media de estos despachos es mayor que 12, podemos utilizar la siguiente\nsecuencia de operaciones:\n\u2022A := EDIFICIOS_EMP( supmediadesp  > 12);\n\u2022B  : =  D E S P A C H O S  * A;\n\u2022R  : =  B [edificio, n\u00famero ]\n2)Supongamos ahora que se desea obtener el nombre y el apellido de todos los empleados\n(tanto de administraci\u00f3n como de producci\u00f3n ) que est\u00e1n asignados al despacho 120 del edi-\nficio Marina. En este caso, podemo s utilizar la siguiente secuencia:\n\u2022A := EMPLEADOS_ADM \u222a EMPLEADOS_PROD ;\n\u2022B := A( edificiodesp  = Marina y  n\u00famerodesp  = 120);\n\u2022R := B[ nombre, apellido ].\n3)Si queremos consultar el nombre del edificio y el n\u00famero de los despachos que ning\u00fan\nempleado de administraci\u00f3n tiene asig nado, podemos utilizar esta secuencia:\n\u2022A := DESPACHOS [ edificio, n\u00famero ];\n\u2022B := EMPLEADOS_ADM[ edificiodesp, n\u00famerodesp ];\n\u2022R := A \u2013 B .\n4)Para obtener el DNI, el nombre y el apellido  de todos los empleados de administraci\u00f3n que\ntienen despacho, junto con la superficie de su despacho, podemos hacer lo siguiente:\n\u2022A [ DNI, nombre, apellido, edificio, n\u00famero ] := EMPLEADOS_ADM[ DNI, nombre, apellido, edi-\nficiodesp, n\u00famerodesp ];\n\u2022B  : =  A  * DESPACHOS ;\n\u2022 R := B[DNI, nombre, apellido, superficie] .\n5.4. Extensiones: co mbinaciones externas\nPara finalizar el tema del \u00e1lgebra rela cional, analizaremos algunas extensiones\n\u00fatiles de la combinaci\u00f3n.\nLas combinaciones que se han descrito obti enen las tuplas del producto cartesia-\nno de dos relaciones que satisfacen una condici\u00f3n de combinaci\u00f3n. Las tuplas de\nRecordad que la base de datos\nque se utiliza en los ejemplos se ha descrito en la introducci\u00f3n del apartado 5 de esta unidad did\u00e1ctica.\n\uf8e9 FUOC \u2022 71Z799014MO 48 El modelo relacional y el \u00e1lgebra relacional\nuna de las dos relaciones que no tienen en la otra relaci\u00f3n una tupla como m\u00ed-\nnimo con la cual, una vez concatenadas , satisfagan la condici\u00f3n de combina-\nci\u00f3n, no aparecen en el resultado de la  combinaci\u00f3n, y podr\u00edamos decir que sus\ndatos se pierden.\nPor ejemplo, si hacemos la siguiente combinac i\u00f3n natural (con una redenominaci\u00f3n previa):\nD(edificiodesp, n\u00fame rodesp, superficie ) := DESPACHOS ( edificio, n\u00famero, superficie ), \nR := EMPLEADOS_PROD * D .\nPuesto que se trata de una combinaci\u00f3n natura l, se considera que la condici\u00f3n de combina-\nci\u00f3n es edificio = edificio  y n\u00famero = n\u00famero , y la relaci\u00f3n R resultante ser\u00e1:\nNotad que en esta relaci\u00f3n R no est\u00e1n los empleados de producci\u00f3n que no tienen despacho\nasignado (con valores nulos en edificiodesp  y n\u00famerodesp ), y tampoco los despachos que no\ntienen ning\u00fan empleado de producci\u00f3n, porque no cumplen la condici\u00f3n de combinaci\u00f3n.\nConviene destacar que las tuplas que tienen un valor nulo para alguno de los atri-\nbutos que figuran en la condici\u00f3n de co mbinaci\u00f3n se pierden siempre, porque en\nestos casos la condici\u00f3 n de combinaci\u00f3n siempre se eval\u00faa a falso.\nEn algunos casos, puede interesar hacer combinaciones de los datos de dos re-\nlaciones sin que haya p\u00e9rdid a de datos de las relaciones de partida. Entonces,\nse utilizan las comb inaciones externas.R\nDNIemp nombreemp apellidoemp edificiodesp n\u00famerodesp superficie\n33.567.711 Marta Roca Marina 120 1055.898.425 Carlos Buend\u00eda Diagonal 120 1077.232.144 Elena Pla Marina 230 20\nLas combinaciones externas  entre dos relaciones T y S consisten en va-\nriantes de combinaci\u00f3n que conserva n en el resultado todas las tuplas\nde T, de S o de ambas relaciones. Pueden ser de los tipos siguientes:\n1)La combinaci\u00f3n externa izquierda  entre dos relaciones T y S, que\ndenotamos como T[C]IS, conserva en el resultado todas las tuplas de la\nrelaci\u00f3n T.\n2)La combinaci\u00f3n externa derecha  entre dos relaciones T y S, que\ndenotamos como T[C]DS, conserva en el resultado todas las tuplas de\nla relaci\u00f3n S.\n3)Finalmente, la combinaci\u00f3n externa plena  entre dos relaciones T\ny S, que denotamos como T[C]pS, conserva en el re sultado todas las tu-\nplas de T y todas las tuplas de S.Las combinaciones se han \nexplicado en el subapartado 5.3.3 de esta unidad did\u00e1ctica.\n\uf8e9 FUOC \u2022 71Z799014MO 49 El modelo relacional y el \u00e1lgebra relacional\nEstas extensiones tambi\u00e9n se aplican al caso de la combin aci\u00f3n natural entre\ndos relaciones, T * S, concretamente: \na)La combinaci\u00f3n natural externa izquierda entre dos relaciones T y S, que\nse indica como T *I S, conserva en el resultado todas las tuplas de la relaci\u00f3n T.\nb)La combinaci\u00f3n natural externa derecha entre dos relaciones T y S, que se\nindica como T *D S, conserva en el resultado toda s las tuplas de la relaci\u00f3n S.\nc)Finalmente, la combinaci\u00f3n natural externa plena entre dos relaciones T y S,\nque se indica como T *P S, conserva en el resultado todas las tuplas de T y todas\nlas tuplas de S.\nLas tuplas de una relaci\u00f3n T que se conservan en el resultado R de una combi-\nnaci\u00f3n externa con otra relaci\u00f3n S, a pesar de que no satisfacen la condici\u00f3n\nde combinaci\u00f3n, tienen valores nulos en el resultado R para todos los atributos\nque provienen de la relaci\u00f3n S. \nEjemplos de combinaciones naturales externas\n1)Si hacemos la siguiente combinaci\u00f3n natura l derecha (con una redenominaci\u00f3n previa):\nD(edificiodesp, n\u00fame rodesp, superficie ) := DESPACHOS ( edificio, n\u00famero, superficie ),\nR := EMPLADOS_PROD *D D,\nla relaci\u00f3n R resultante ser\u00e1:  \nAhora obtenemos todos los despachos en la rela ci\u00f3n resultante, tanto si tienen un empleado\nde producci\u00f3n asignado como si no. Notad que los atributos DNI, nombre y apellido  para los\ndespachos que no tienen empl eado reciben valores nulos.\n2)Si hacemos la siguiente combinaci\u00f3n natural izquierda (con una redenominaci\u00f3n previa):\nD(edificiodesp, n\u00famerodesp, superficie ) := DESPACHOS( edificio, n\u00famero, superficie ), \nR := EMPLEADOS_PROD *I D,\nentonces la relaci\u00f3n R resultante ser\u00e1:R\nDNIemp nombreemp apellidoemp edificiodesp n\u00famerodesp superficie\n33.567.711 Marta Roca Marina 120 1055.898.425 Carlos Buend\u00eda Diagonal 120 1077.232.144 Elena Pla Marina 230 20\nNULO NULO NULO Diagonal 440 10\nR\nDNIemp nombreemp apellidoemp edificiodesp n\u00famerodesp superficie\n33.567.711 Marta Roca Marina 120 1055.898.425 Carlos Buend\u00eda Diagonal 120 10\n77.232.144 Elena Pla Marina23020\n21.335.245 Jorge Soler NULO NULO NULO\n88.999.210 Pedro Gon z\u00e1lez NULO NULO NULO\n\uf8e9 FUOC \u2022 71Z799014MO 50 El modelo relacional y el \u00e1lgebra relacional\nEsta combinaci\u00f3n externa nos pe rmite obtener en la relaci\u00f3n resultante a todos los emplea-\ndos de producci\u00f3n, tanto si tienen despacho co mo si no. Observad que el atributo superficie\npara los empleados que no tienen despacho contiene un valor nulo.\n3)Finalmente, si hacemos la siguiente combin aci\u00f3n natural plena (con una redenominaci\u00f3n\nprevia):\nD(edificiodesp, n\u00fame rodesp, superficie ) := DESPACHOS( edificio, n\u00famero, superficie ), \nR:= EMPLEADOS_PROD *P D,\nentonces la relaci\u00f3n R resultante ser\u00e1:\nEn este caso, en la relaci\u00f3n resultante obtenemos a todos los empleados de producci\u00f3n y tam-\nbi\u00e9n todos los despachos.R\nDNIemp nombreemp apellidoemp edificiodesp n\u00famerodesp superficie\n33.567.711 Marta Roca Marina 120 1055.898.425 Carlos Buend\u00eda Diagonal 120 1077.232.144 Elena Pla Marina 230 2021.335.245 Jorge Soler NULO NULO NULO88.999.210 Pedro Gonz\u00e1lez NULO NULO NULO\nNULO NULO NULO Diagonal 440 10\uf8e9 FUOC \u2022 71Z799014MO 51 El modelo relacional y el \u00e1lgebra relacional\nResumen\nEn esta unidad did\u00e1ctica hemos presentado los conceptos fundamentales del\nmodelo relacional de datos  y, a continuaci\u00f3n, hemos explicado las opera-\nciones del \u00e1lgebra relacional :\n1)Los aspectos m\u00e1s relevant es del modelo relacional  que hemos descrito son\nlos siguientes:\na)En lo que respecta a la estructura de los datos :\n\u2022 Consiste en un conjunto de relaciones.\u2022 Una relaci\u00f3n permite almacena r datos relacionados entre s\u00ed.\n\u2022 La clave primaria de una relaci \u00f3n permite identificar sus datos.\n\u2022 Las claves for\u00e1neas de las relaciones  permiten referenciar claves primarias\ny, de este modo, establecer conexion es entre los datos de las relaciones.\nb)En lo que respecta a la integridad de los datos :\n\u2022 La regla de integridad de unicidad y de entidad de la clave primaria: las cla-\nves primarias no pueden contener valores repetidos ni valores nulos.\n\u2022 La regla de integridad re ferencial: los valores de las claves for\u00e1neas deben\nexistir en la clave primaria referenc iada o bien deben ser valores nulos.\n\u2022 La regla de integridad de dominio: los valores no nulos de un atributo de-\nben pertenecer al dominio del atribu to, y los operadores que es posible\naplicar sobre los valores dependen de los dominios de estos valores.\n2)El \u00e1lgebra relacional proporciona un conjunto de operaciones para mani-\npular relaciones. Estas oper aciones se pueden clasific ar de la forma siguiente:\na)Operaciones conjuntistas: uni\u00f3n, in tersecci\u00f3n, diferencia y producto\ncartesiano.\nb)Operaciones espec\u00edficamente relacion ales: selecci\u00f3n, proyecci\u00f3n y com-\nbinaci\u00f3n.\nLas operaciones del \u00e1lgebra relacional pueden formar secu encias que permiten\nresolver consultas complejas.\uf8e9 FUOC \u2022 71Z799014MO 53 El modelo relacional y el \u00e1lgebra relacional\nEjercicios de autoevaluaci\u00f3n\n1.Dada la relaci\u00f3n que corresponde a la siguiente representaci\u00f3n tabular:\nFigura 4\na)Indicad qu\u00e9 conjunto de atributos tiene.\nb)Decid qu\u00e9 dominio tiene ca da uno de sus atributos.\nc)Escribid todas las distintas formas de denotar su esquema de relaci\u00f3n.\nd)Elegid una de las formas de denotar su esquema de relaci\u00f3n y utilizadla para dibujar el con-\njunto de tuplas correspondiente a su extensi\u00f3n.\n2.Indicad cu\u00e1les son todas las supercla ves de las siguientes relaciones:\na)DESPACHOS (edificio, n\u00famero, superficie ), que tiene como \u00fanica clave candidata la siguien-\nte: edificio, n\u00famero .\nb)EMPLEADOS (DNI, NSS, nombre, apellido ), que tiene las siguient es claves candidatas: DNI y NSS .\n3.Decid, para cada una de las siguientes operaciones de actualizaci\u00f3n, si se podr\u00eda aceptar su\naplicaci\u00f3n sobre la base de datos qu e se ha utilizado en esta unidad:\na)Insertar en EDIFICIOS_EMP  la tupla <Nexus, 30>.\nb)Insertar en DESPACHOS  la tupla <Diagonal, NULO, 15>.\nc)Insertar en  EMPLEADOS_ADM  la tupla <55.555.555, Mar\u00eda, Puig, Diagonal, 500>.\nd)Modificar en DESPACHOS  la tupla <Marina, 230, 20> por <Marina, 120, 20>.\ne)Borrar en EMPLEADOS_PROD  la tupla <88.999.20, Pedro, Gonz\u00e1lez, NULO, NULO>.\nf)Modificar en EMPLEADOS_ADM  la tupla <40.444.255, Juan, Garc\u00eda, Marina, 120> por\n<33.567.711, Juan, Garc\u00eda, Marina, 120>.\ng)Borrar en EDIFICIOS_EMP  la tupla <Marina, 15> si para  la clave for\u00e1nea edificio de DESPA-\nCHOS  se ha seleccionado la pol\u00edtica de  restricci\u00f3n en caso de borrado.\nh)Borrar en EDIFICIOS_EMP  la tupla <Marina, 15> si para  la clave for\u00e1nea edificio de DES-\nPACHOS  se ha seleccionado la pol\u00edt ica de actualizaci\u00f3n en ca scada en caso de borrado.\n4.Escribid secuencias de operaciones del \u00e1lgebr a relacional que resuel van las siguientes con-\nsultas en la base de datos que hemos utilizado en esta unidad:\na)Obtener los despachos con una superficie mayor que 15. Concretamente, se quiere saber\nel nombre del edificio, el n\u00famero y la superfic ie de estos despachos, junto con la superficie\nmedia de los despachos del edificio donde est\u00e1n situados.\nb)Obtener el nombre del edificio y el n\u00famero de los despachos que no tienen asignado a\nning\u00fan empleado (ni de produc ci\u00f3n ni de administraci\u00f3n).\nc)Obtener el nombre y el apellido de los emplea dos (tanto de administraci\u00f3n como de pro-\nducci\u00f3n), que no tienen despacho.\nd)Obtener el nombre y el apellido de todos los empleados (tanto de administraci\u00f3n como\nde producci\u00f3n) que tienen despacho asignado, junto con la superficie de su despacho y lasuperficie media de los despachos del edificio al que pertenece su despacho.\ne)Obtener los despachos con una superficie mayo r que la superficie del despacho Diagonal,\n120. Concretamente, se quiere saber el nombre del edificio y el n\u00famero de estos despachos.\nf)Obtener todos los despachos de la empresa (tan to si tienen empleados como si no), junto\ncon los empleados que tienen asignados (en caso  de que los tengan). Concretamente, se quie-\nre conocer el nombre del edificio, el n\u00famero de despacho y el DNI del empleado.\n\uf8e9 FUOC \u2022 71Z799014MO 54 El modelo relacional y el \u00e1lgebra relacional\n5.Sea R la relaci\u00f3n que resulta de la intersecci\u00f3n de las relaciones T y S, es decir, R := T \u2229 S.\nEscribid una secuencia de operaciones del \u00e1lgebra relacional que incluya s\u00f3lo operacionesprimitivas y que obtenga como resultado R.\n6.Sean las relaciones de esquema T( A, B, C) y S( D, E, F), y sea R la relaci\u00f3n que resulta de la\nsiguiente combinaci\u00f3n:\nR := T [B = D, C = E ]S.\nEscribid una secuencia de operaciones del \u00e1lgebra relacional que incluya s\u00f3lo operaciones\nprimitivas y que obtenga como resultado R.\uf8e9 FUOC \u2022 71Z799014MO 55 El modelo relacional y el \u00e1lgebra relacional\nSolucionario\nEjercicios de autoevaluaci\u00f3n\n1. \na)La relaci\u00f3n representada tiene el siguiente conjunto de atributos: edificio, n\u00famero, superficie .\nb)Los dominios son dominio( edificio ) = edificios , dominio( n\u00famero ) = n\u00fameros  y dominio( su-\nperficie ) = sups.\nc)Las formas de denotar el esquema de relaci\u00f3n son:\n\u2022D E S P A C H O S ( edificio, n\u00famero, superficie ),\n\u2022D E S P A C H O S ( edificio, superficie, n\u00famero ),\n\u2022D E S P A C H O S ( n\u00famero, edificio, superficie ),\n\u2022D E S P A C H O S ( n\u00famero, superficie, edificio ),\n\u2022D E S P A C H O S ( superficie, edificio, n\u00famero ),\n\u2022D E S P A C H O S ( superficie, n\u00famero, edificio ),\nque corresponden a las posibles or denaciones de sus atributos.\nd)Elegiremos la siguiente forma de denotar el esquema de relaci\u00f3n:\nDESPACHOS( edificio, n\u00famero, superficie ).\nEntonces el conjunto de tuplas de su extensi\u00f3n ser\u00e1:\nFigura 5\n2.Las superclaves de las relaciones correspondientes son:\na){edificio, n\u00famero } y {edificio, n\u00famero, superficie }.\nb){DNI}, {NSS}, {DNI, NSS }, {DNI, nombre }, {DNI, apellido }, {NSS, nombre }, {NSS, apellido }, {DNI, nom-\nbre, apellido }, {NSS, nombre, apellido }, {DNI, NSS, nombre, apellido } y {DNI, NSS, nombre, apellido }.\n3. \na)Se acepta.\nb)Se rechaza porque viola la regla de integr idad de entidad de la clave primaria.\nc)Se rechaza porque viola la regl a de integridad referencial.\nd)Se rechaza porque viola la regla de integr idad de unicidad de la clave primaria.\ne)Se acepta.\nf)Se rechaza porque viola la regla de integr idad de unicidad de la clave primaria.\ng)Se rechaza porque viola la regl a de integridad referencial.\nh)Se acepta y se borran el edificio Marina y todos sus despachos.\n4. \na)Podemos utilizar la siguiente secuencia de operaciones:\n\u2022A  := DESPACHOS (superficie >15),\n\u2022R := A * EDIFICIOS_EMP .\nb)Podemos utilizar la siguiente secuencia de operaciones:\n\u2022A  : =  D E S P A C H O S [edificio, n\u00famero ],\n\u2022 B := EMPLEADOS_ADM \u222a EMPLEADOS_PROD,\n\u2022 C := B [edificiodesp, n\u00famerodesp ],\n\u2022R := A \u2212 C.\nc)Podemos utilizar la siguiente secuencia de operaciones:\n\u2022 A := EMPLEADOS_ADM \u222a EMPLEADOS_PROD ,\n\u2022B := A(edificiodesp  = NULO y  n\u00famerodesp  = NULO),\n\u2022R := B[nombre, apellido ].\nd)Podemos utilizar la siguiente secuencia de operaciones:\n\u2022 A := EMPLEADOS_ADM \u222a EMPLEADOS_PROD,\n\u2022 B(DNI, nombre, apellido, edificio, n\u00famero) := A(DNI, nombre, apellido, edificiodesp,  n\u00famerodesp) ,\n\u2022C := B * DESPACHOS ,\n\u2022D := C * EDIFICIOS_EMP ,\n\u2022R  : =  D [nombre, apellido, superficie, supmediadesp ].\n\uf8e9 FUOC \u2022 71Z799014MO 56 El modelo relacional y el \u00e1lgebra relacional\ne)Podemos utilizar la siguiente secuencia de operaciones:\n\u2022A := DESPACHOS (edificio  = Diagonal y n\u00famero  = 120),\n\u2022B ( Ed, Num , Sup) := A( edificio , n\u00famero , superficie ),\n\u2022C := DESPACHOS [superficie >Sup] B,\n\u2022R := C[edificio , n\u00famero ].\nf)Podemos utilizar la siguiente secuencia de operaciones:\n\u2022A := EMPLEADOS_ADM \u222a EMPLEADOS_PROD ,\n\u2022B(DNI, nombre , apellido , edificio , n\u00famero ) := A(DNI, nombre , apellido , edificiodesp , n\u00famerodesp ),\n\u2022C := DESPACHOS  *I B,\n\u2022R := C[edificio , n\u00famero , DNI].\n5.La secuencia siguiente:\n\u2022A  : =  T  \u2212 S,\n\u2022R  := T \u2212 A,\ns\u00f3lo incluye operaciones primitivas, dado que la diferencia es primitiva, y obtiene el mismo\nresultado que R := T \u2229 S.\n6.La siguiente secuencia:\n\u2022A  := T \u00d7 S,\n\u2022R  := A(B = D y C = E),\nque s\u00f3lo incluye operaciones primitivas (un pr oducto cartesiano y una selecci\u00f3n), obtiene el\nmismo resultado que R := T[B = D ,C = E ]S.\nGlosario\nactualizaci\u00f3n\nHecho de reflejar los cambios que se producen en  la realidad en las re laciones de una base de\ndatos.\nactualizaci\u00f3n en cascada para el caso de borrado\nPol\u00edtica de mantenimiento de la integridad referencial que consiste en borrar una tupla t que\ntiene una clave primaria refere nciada, as\u00ed como borrar toda s las tuplas que referencian t.\nactualizaci\u00f3n en cascada para el caso de modificaci\u00f3n\nPol\u00edtica de mantenimiento de la integridad referencial que consiste en permitir modificar atri-\nbutos de la clave primaria de una tupla t con una clave primaria referenciada, y modificar del\nmismo modo todas las tuplas  que referencian la tupla t.\nanulaci\u00f3n en caso de borrado\nPol\u00edtica de mantenimiento de la integridad referencial que consiste en borrar una tupla t con\nuna clave referenciada y, adem\u00e1s, modi ficar todas las tuplas que referencian  t de modo que\nlos atributos de la clave for\u00e1nea correspondiente tomen valores nulos.\nanulaci\u00f3n en caso de modificaci\u00f3n\nPol\u00edtica de mantenimiento de la integridad referencial que consiste en modificar atributos de\nla clave primaria de una tupla t con una clave referenciada y, adem\u00e1s, modificar todas las tu-\nplas que referencian t de modo que los atributos de la clave for\u00e1nea correspondiente tomen\nvalores nulos.\natributo (en el contexto del modelo relacional)\nNombre del papel que ejerce un do minio en un esquema de relaci\u00f3n.\nborrado\nHecho de borrar una o m\u00e1s tuplas de una relaci\u00f3n.\ncardinalidad de una relaci\u00f3n\nN\u00famero de tuplas que pe rtenecen a su extensi\u00f3n.\ncierre relacional\nPropiedad de todas las operacion es del \u00e1lgebra relacional seg\u00fan la cual tanto sus operandos\ncomo su resultado son relaciones.\nclave alternativa de una relaci\u00f3n\nClave candidata de la relaci\u00f3n que no se ha elegido como clave primaria.\nclave candidata de una relaci\u00f3n\nSuperclave C de la relaci\u00f3n que cumple qu e ning\u00fan subconjunto propio de C es superclave.\nclave primaria de una relaci\u00f3n\nClave candidata de la relaci\u00f3n que se ha elegido para identificar las tuplas de la relaci\u00f3n.\uf8e9 FUOC \u2022 71Z799014MO 57 El modelo relacional y el \u00e1lgebra relacional\nclave for\u00e1nea de una relaci\u00f3n R\nSubconjunto de los atributos del esquema de la relaci\u00f3n, CF, tal que existe una relaci\u00f3n S (S\nno debe ser necesariamente diferente de R) que tiene por clave primaria CP, y se cumple que,\npara toda tupla t de la extensi\u00f3n de R, los valores para CF de t son o bien valores nulos, o bien\nvalores que coinciden con los valores para CP de alguna tupla s de S.\ncombinaci\u00f3n\nOperaci\u00f3n del \u00e1lgebra relacional  que, a partir de dos relaci ones, obtiene una nueva relaci\u00f3n\nformada por todas las tuplas qu e resultan de concatenar tuplas de la primera relaci\u00f3n con\ntuplas de la segunda relaci\u00f3n, y que cumplen una condici\u00f3n de combinaci\u00f3n especificada.\ncombinaci\u00f3n externa\nExtensi\u00f3n de combinaci\u00f3n entre dos relaciones, T y S, que conserva en el resultado todas las\ntuplas de T, de S o de las dos relaciones.\ncombinaci\u00f3n natural\nVariante de combinaci\u00f3n que consiste b\u00e1sicamente en una equicombinaci\u00f3n seguida de la\neliminaci\u00f3n de los atributos superfluos.\nconsulta\nObtenci\u00f3n de datos deducibles a partir de las relaciones que contiene la base de datos.\ndiferencia\nOperaci\u00f3n del \u00e1lgebra relacional  que, a partir de dos relaci ones, obtiene una nueva relaci\u00f3n\nformada por todas las tuplas que est\u00e1n en la pr imera relaci\u00f3n y, en cambio, no est\u00e1n en la\nsegunda.\ndominio (en el contexto del modelo relacional)\nConjunto de valores at\u00f3micos.\nequicombinaci\u00f3n\nCombinaci\u00f3n en la que todas las comparacione s de la condici\u00f3n tienen el operador \u201c=\u201d.\nesquema de relaci\u00f3n\nComponente de una relaci\u00f3n que consiste en un nombre de relaci\u00f3n R y en un conjunto de\natributos { A1, A2, ..., An}.\nextensi\u00f3n de una relaci\u00f3n de esquema R (A1, A2, ..., An)\nConjunto de tuplas ti (i = 1, 2, ..., m ) donde cada tupla ti es un conjunto de pares ti = {<A1:Vi1>,\n<A2Vi2>, ..., <An:Vin>} y, para cada par < Aj:Vij>, se cumple que vij es un valor de dominio( Aj) o\nbien un valor nulo.\ngrado de una relaci\u00f3n\nN\u00famero de atributos que pertenecen a su esquema.\ninserci\u00f3n\nHecho de a\u00f1adir una o m\u00e1s tuplas a una relaci\u00f3n.\nintegridad\nPropiedad de los datos de corresponder a re presentaciones plausi bles del mundo real.\nintersecci\u00f3n\nOperaci\u00f3n del \u00e1lgebra relacional  que, a partir de dos relaci ones, obtiene una nueva relaci\u00f3n\nformada por las tuplas que est\u00e1n en  las dos relaciones de partida.\nlenguaje basado en el c\u00e1lculo relacional\nLenguaje que proporciona un tipo de formulaci\u00f3 n de consultas fundamentado en el c\u00e1lculo\nde predicados de la l\u00f3gica matem\u00e1tica.\nlenguaje basado en el \u00e1lgebra relacional\nLenguaje que proporciona un tipo de formulac i\u00f3n de consultas inspirado en la teor\u00eda de\nconjuntos.\nmodificaci\u00f3n\nHecho de alterar los valores que tienen una o m\u00e1s tuplas de una relaci\u00f3n para uno o m\u00e1s de\nsus atributos.\nproducto cartesiano\nOperaci\u00f3n del \u00e1lgebra relacional  que, a partir de dos relaci ones, obtiene una nueva relaci\u00f3n\nformada por todas las tuplas qu e resultan de concatenar tuplas de la primera relaci\u00f3n con\ntuplas de la segunda relaci\u00f3n.\uf8e9 FUOC \u2022 71Z799014MO 58 El modelo relacional y el \u00e1lgebra relacional\nproyecci\u00f3n\nOperaci\u00f3n del \u00e1lgebra relacional que, a partir  de una relaci\u00f3n, obtiene una nueva relaci\u00f3n\nformada por todas las (sub)tuplas de  la relaci\u00f3n de partida que resultan de eliminar unos atri-\nbutos especificados.\nredenominar\nOperaci\u00f3n auxiliar del \u00e1lgebra relacional que permite cambiar los nombres que figuran en el\nesquema de una relaci\u00f3n.\nregla de integridad de dominio\nRegla que establece que un valor no nulo de un atributo Ai debe pertenecer al dominio del\natributo Ai, y que los operadores que es posible aplic ar sobre los valores dependen de los do-\nminios de estos valores.\nregla de integridad de entidad de la clave primaria\nRegla que establece que si el conjunto de atributos CP es la clave primaria de una relaci\u00f3n R,\nla extensi\u00f3n de R no puede tener en ning\u00fan momento ninguna tupla con un valor nulo paraalguno de los atributos de CP.\nregla de integridad de modelo\nCondiciones generales que deben cumplirse en toda base de da tos de un modelo determinado.\nregla de integridad de unicidad de la clave primaria\nRegla que establece que si el conjunto de atributos CP es la clave primaria de una relaci\u00f3n R,\nla extensi\u00f3n de R no puede tener en ning\u00fan momento dos tuplas con la misma combinaci\u00f3n\nde valores para los atributos de CP.\nregla de integridad referencial\nRegla que establece que si el conjunto de atributos CF es una clave for\u00e1nea de una relaci\u00f3n R\nque referencia una relaci\u00f3n S (no necesariamente diferente de R), que tiene por clave prima-\nria CP, entonces, para toda tupla t de la extensi\u00f3n de R, los valores para CF de t son o bien\nvalores nulos o bien valores que coinciden con los valores para CP de alguna tupla s de S.\nrelaci\u00f3n\nElemento de la estructura de los datos de una base de datos relacional  formado por un esque-\nma (o intensi\u00f3n) y una extensi\u00f3n.\nrestricci\u00f3n en caso de modificaci\u00f3n\nPol\u00edtica de mantenimient o de la integridad referencial, que consiste en no permitir modificar\nning\u00fan atributo de la clave prim aria de una tupla si se trata de  una clave primaria referenciada.\nrestricci\u00f3n en caso de borrado\nPol\u00edtica de mantenimiento de la integridad refe rencial que consiste en no permitir borrar una\ntupla si tiene una clav e primaria referenciada.\nrestricciones de integridad de usuario\nCondiciones espec\u00edficas que se deben cumplir en una base de datos concreta.\nselecci\u00f3n\nOperaci\u00f3n del \u00e1lgebra relacional que, a partir de  una relaci\u00f3n, obtiene una nueva relaci\u00f3n for-\nmada por todas las tuplas de la relaci\u00f3n de partida que cu mplen una condici\u00f3n de selecci\u00f3n\nespecificada.\nsuperclave de una relaci\u00f3n de esquema R( A\n1, A2, ..., An)\nSubconjunto de los atributos del esquema tal qu e no puede haber dos tu plas en la extensi\u00f3n\nde la relaci\u00f3n que tengan la misma combinaci\u00f3 n de valores para los a tributos del subconjunto.\nuni\u00f3n\nOperaci\u00f3n del \u00e1lgebra relacional  que, a partir de dos relaci ones, obtiene una nueva relaci\u00f3n\nformada por todas las tuplas que est\u00e1n en  alguna de las relaciones de partida.\nBibliograf\u00eda\nBibliograf\u00eda b\u00e1sica\nDate, C.J.  (2001). Introducci\u00f3n a los sistemas de bases de datos (7\u00aa ed.). Prentice-Hall.\nElmasri, R.; Navathe, S.B.  (2000).  Sistemas de bases de dato s. Conceptos fundamentales  (3\u00aa\ned.). Madrid: Addison-Wesley Iberoamericana.El lenguaje SQL\nCarme Mart\u00edn Escofet\n\uf8e9 FUOC \u2022 71Z799014MO El lenguaje SQL\n\u00cdndice\nIntroducci\u00f3n ............................................................................................... 5\nObjetivos ...................................................................................................... 10\n1. Sentencias de definici\u00f3n .................................................................... 11\n1.1. Creaci\u00f3n y borrado de una base de datos relacional......................... 12\n1.2. Creaci\u00f3n de tablas ............................................................................. 13\n1.2.1. Tipos de datos ........................................................................ 13\n1.2.2. Creaci\u00f3n, modificaci\u00f3n y borrado de dominios.................... 14\n1.2.3. Definiciones por defecto ........................................................ 16\n1.2.4. Restricciones de columna....................................................... 17\n1.2.5. Restricciones de tabla............................................................. 17\n1.2.6. Modificaci\u00f3n y borrado de  claves primarias con claves  \nfor\u00e1neas que hacen referencia a \u00e9stas .................................... 18\n1.2.7. Aserciones............................................................................... 19\n1.3. Modificaci\u00f3n y borrado de tablas...................................................... 19\n1.4. Creaci\u00f3n y borrado de vistas ............................................................. 20\n1.5. Definici\u00f3n de la base de datos relacional BDUOC............................ 23\n2. Sentencias de manipulaci\u00f3n ............................................................. 26\n2.1. Inserci\u00f3n de filas en una tabla........................................................... 26\n2.2. Borrado de filas de una tabla ............................................................. 27\n2.3. Modificaci\u00f3n de filas de una tabla .................................................... 27\n2.4. Introducci\u00f3n de filas en la base de datos relacional BDUOC ........... 28\n2.5. Consultas a una base de datos relacional.......................................... 29\n2.5.1. Funciones de agregraci\u00f3n....................................................... 31\n2.5.2. Subconsultas........................................................................... 32\n2.5.3. Otros predicados .................................................................... 32\n2.5.4. Ordenaci\u00f3n de los datos obtenidos  \nen respuestas a consultas ....................................................... 35\n2.5.5. Consultas con agrupaci\u00f3n de filas de una tabla .................... 36\n2.5.6. Consultas a m\u00e1s de una tabla ................................................ 38\n2.5.7. La uni\u00f3n ................................................................................. 43\n2.5.8. La intersecci\u00f3n ....................................................................... 44\n2.5.9. La diferencia........................................................................... 45\n3. Sentencias de control .......................................................................... 48\n3.1. Las transacciones ............................................................................... 48\n3.2. Las autorizaciones y desautorizaciones ............................................. 49\uf8e9 FUOC \u2022 71Z799014MO El lenguaje SQL\n4. Sublenguajes especializados .............................................................. 51\n4.1. SQL hospedado.................................................................................. 51\n4.2. Las SQL/CLI ....................................................................................... 52\nResumen ....................................................................................................... 53\nActividad ..................................................................................................... 55\nEjercicios de autoevaluaci\u00f3n .................................................................. 55\nSolucionario ................................................................................................ 56\nBibliograf\u00eda ................................................................................................. 58\nAnexos .......................................................................................................... 59\uf8e9 FUOC \u2022 71Z799014MO 5 El lenguaje SQL\nIntroducci\u00f3n\nEl SQL es el lenguaje est\u00e1ndar ANSI/ISO de definici\u00f3n, manipulaci\u00f3n y control \nde bases de datos relacionales. Es un le nguaje declarativo: s\u00f3lo hay que indicar \nqu\u00e9 se quiere hacer. En cambio, en lo s lenguajes procedimentales es necesario \nespecificar c\u00f3mo hay que hacer cualquier ac ci\u00f3n sobre la base de datos. El SQL \nes un lenguaje muy parecido al lenguaje natural; concretamente, se parece al ingl\u00e9s, y es muy expresivo. Por estas razo nes, y como lenguaje est\u00e1ndar, el SQL \nes un lenguaje con el que se puede ac ceder a todos los sistemas relacionales \ncomerciales.\nEmpezamos con una breve explicaci\u00f3n de la forma en que el SQL ha llegado a \nser el lenguaje est\u00e1ndar de las bases de datos relacionales:\n1)Al principio de los a\u00f1os setenta, los laboratorios de investigaci\u00f3n Santa Te -\nresa de IBM empezaron a trabajar en el pr oyecto System R. El objetivo de este \nproyecto era implementar un  prototipo de SGBD relaci onal; por lo tanto, tam -\nbi\u00e9n necesitaban investigar en el campo de los lenguajes de bases de datos rela -\ncionales. A mediados de los a\u00f1os setenta,  el proyecto de IBM dio como resultado \nun primer lenguaje denominado SEQUEL ( Structured English Query Language ), que \npor razones legales se denomin\u00f3 m\u00e1s adelante SQL (Structured Query Language ). \nAl final de la d\u00e9cada de los setenta y al principio de la de los ochenta, una vez \nfinalizado el proyecto Syst em R, IBM y otras empresas  empezaron a utilizar el \nSQL en sus SGBD relacionales, con lo qu e este lenguaje adquiri\u00f3 una gran po -\npularidad.\n2)En 1982, ANSI ( American National Standards Institute ) encarg\u00f3 a uno de sus co -\nmit\u00e9s (X3H2) la definici\u00f3n de un lenguaje de bases de datos relacionales. Este co -\nmit\u00e9, despu\u00e9s de evaluar diferentes lenguajes, y ante la aceptaci\u00f3n comercial del \nSQL, eligi\u00f3 un lenguaje es t\u00e1ndar que estaba basado en \u00e9ste pr\u00e1cticamente en su \ntotalidad. El SQL se convirti\u00f3 oficialmente en el lenguaje est\u00e1ndar de ANSI en el \na\u00f1o 1986, y de ISO ( International Standards Organization ) en 1987. Tambi\u00e9n ha \nsido adoptado como lenguaje est\u00e1ndar por FIPS ( Federal Information Processing\nStandard ), Unix X/Open y SAA ( Systems Application Architecture ) de IBM.\n3)En el a\u00f1o 1989, el est\u00e1ndar fue objeto de una revisi\u00f3n y una ampliaci\u00f3n \nque dieron lugar al lenguaje que se conoce con el nombre de SQL1 o SQL89. \nEn el a\u00f1o 1992 el est\u00e1ndar volvi\u00f3 a se r revisado y ampliado considerablemente \npara cubrir carencias de la versi\u00f3n ante rior. Esta nueva versi\u00f3n del SQL, que se \nconoce con el nombre de SQL2  o SQL92 , es la que nosotros presentaremos en \nesta unidad did\u00e1ctica.\nComo veremos m\u00e1s adelante, aunque aparezca s\u00f3lo la sigla SQL, siempre nos estaremos refiriendo al SQL92, ya que \u00e9ste tiene como subconjunto el SQL89; Recordad que el \u00e1lgebra relacional, \nque hemos visto en la unidad  \n\u201cEl modelo relacional y el \u00e1lgebra relacional\u201d, es un lenguaje procedimental.\n\uf8e9 FUOC \u2022 71Z799014MO 6 El lenguaje SQL\npor lo tanto, todo lo que era v\u00e1lido en el caso del SQL89 lo  continuar\u00e1 siendo \nen el SQL92. \nDe hecho, se pueden distinguir  tres niveles dentro del SQL92:\n1)El nivel introductorio (entry ), que incluye el SQL89 y las definiciones de \nclave primaria  y clave for\u00e1nea  al crear una tabla.\n2)El nivel intermedio ( intermediate ), que, adem\u00e1s del SQL89, a\u00f1ade algu -\nnas ampliaciones del SQL92.\n3)El nivel completo ( full), que ya tiene todas las ampliaciones del SQL92.\nEl modelo relacional tiene  como estructura de almacenamiento de los datos \nlas relaciones. La intensi\u00f3 n o esquema de una relaci\u00f3n consiste en el nombre \nque hemos dado a la relaci\u00f3n y un conjunto de atributos. La extensi\u00f3n de una \nrelaci\u00f3n es un conjunto de tuplas. Al trabajar con SQL, esta nomenclatura \ncambia, como podemos apreciar en la siguiente figura:\n\u2022H a b l a r e m o s  d e  tablas  en lugar de relaciones.\n\u2022H a b l a r e m o s  d e  columnas  en lugar de atributos.\n\u2022H a b l a r e m o s  d e  filas en lugar de tuplas.\nSin embargo, a pesar de que la nomenc latura utilizada sea diferente, los con -\nceptos son los mismos.\nCon el SQL se puede definir, manipular y controlar una base de datos relacio -\nnal. A continuaci\u00f3n veremos,  aunque s\u00f3lo en un nivel introductorio, c\u00f3mo se \npueden realizar estas acciones: \nEl concepto de clave primaria  y su \nimportancia en una relaci\u00f3n o tabla se ha visto en la unidad \u201cEl modelo relacional y el \u00e1lgebra relacional\u201d  \nde este curso.\nEl modelo relacional se ha presentado en la unidad  \n\u201cEl modelo relacional y el \u00e1lgebra relacional\u201d de este curso.\n\uf8e9 FUOC \u2022 71Z799014MO 7 El lenguaje SQL\n1)Ser\u00eda necesario crear una tabla que cont uviese los datos de  los productos de \nnuestra empresa:\n2)Insertar un producto en la tabla creada anteriormente:\n3)Consultar qu\u00e9 productos de nuestra empresa son sillas:\n4)Dejar acceder a uno de nuestros vended ores a la informaci\u00f3n de la tabla \nproductos :\nY muchas m\u00e1s cosas que iremos viendo  punto por punto en los siguientes \napartados.\nFij\u00e9monos en la estructura  de todo lo que hemos hecho hasta ahora con SQL. \nLas operaciones de SQL reciben el nombre de sentencias  y est\u00e1n formadas por CREATE TABLE productos\n(codigo_producto INTEGER,\nnombre_producto CHAR(20),\ntipo CHAR(20),\ndescripcion CHAR(50),\nprecio REAL,\nPRIMARY KEY (codigo_producto));\nINSERT INTO productos\nVALUES (1250, \u2018LENA\u2019, \u2018Mesa\u2019, \u2018Dise\u00f1o Juan Pi. A\u00f1o 1920.\u2019, 25000);\nSELECT codigo_producto, nombre_producto\nFROM productos\nWHERE tipo = \u2018Silla\u2019;\nGRANT SELECT ON productos TO jmontserrat;Nombre de la tabla\nNombre de las columnas y tipo\nClave primaria\nNombre de la tabla\nValores de la fila\nColumnas seleccionadas\nFilas seleccionadasTabla\nHacer consultas Usuario\nNombre de la tabla\uf8e9 FUOC \u2022 71Z799014MO 8 El lenguaje SQL\ndiferentes partes  que denominamos cl\u00e1usulas , tal y como podemos apreciar \nen el siguiente ejemplo:\nEsta consulta muestra el c\u00f3digo, el nombre y el tipo de los productos que cues -\ntan m\u00e1s de 1.000 euros.\nLos tres primeros apartados de este m\u00f3dulo tratan sobre un tipo de SQL deno -\nminado SQL interactivo , que permite acceder directamente a una base de da -\ntos relacional:\na)En el primer apartado definiremos las denominadas sentencias de defini -\nci\u00f3n, donde crearemos la base de datos, las tablas que la compondr\u00e1n y los do -\nminios, las aserciones y las vistas que queramos.\nb)En el segundo aprenderemos a manipular la base de datos, ya sea introdu -\nciendo, modificando o borra ndo valores en las filas de las tablas, o bien ha -\nciendo consultas.\nc)En el tercero veremos las sentencias de control, que aseguran un buen uso \nde la base de datos.\nSin embargo, muchas veces querremos acceder a la base de datos desde una \naplicaci\u00f3n hecha en un le nguaje de programaci\u00f3n cualquiera, que nos ofrece \nmucha m\u00e1s potencia fuera del entorno de las bases de datos. Para utilizar SQL \ndesde un lenguaje de prog ramaci\u00f3n necesitaremos se ntencias especiales que \nnos permitan distinguir entre las instru cciones del lenguaje de programaci\u00f3n \ny las sentencias de SQL. La idea es que trabajando b\u00e1sicamente con un lengua -\nje de programaci\u00f3n anfitri\u00f3n se puede cobijar SQL como si fuese un hu\u00e9sped. Por este motivo, este tipo de SQL se conoce con el nombre de\n SQL hospeda -\ndo. Para trabajar con SQL hospedado necesitamos un precompilador que se -\npare las sentencias del lenguaje de prog ramaci\u00f3n de las del lenguaje de bases \nde datos. Una alternativa a es ta forma de trabajar son las rutinas SQL/CLI*\n(SQL/Call-Level Interface ), que resolviendo tambi\u00e9n el problema de acceder a \nSQL desde un lenguaje de programa ci\u00f3n, no necesitan precompilador.\nAntes de empezar a conocer el lenguaje, es necesario a\u00f1adir un \u00faltimo comen -\ntario. Aunque SQL es el lenguaje est\u00e1ndar  para bases de datos relacionales y ha \nsido ampliamente aceptado por los sistem as relacionales co merciales, no ha \nsido capaz de reflejar toda la teor\u00eda de l modelo relacional establecida por E.F. \nCodd; esto lo iremos viendo a medida que profundicemos en el lenguaje.SELECT codigo_producto, nombre_producto, tipo\nFROM productos\nWHERE precio > 1000;\nIntroduciremos SQL hospedado y el \nconcepto de SQL/CLI en el apartado 4 de esta unidad did\u00e1ctica.\n* Las rutinas SQL/CLI se a\u00f1adieron \nal est\u00e1ndar SQL92 en 1995.\nEncontrar\u00e9is la teor\u00eda del modelo \nrelacional de E.F. Codd en la unidad \u201cEl modelo relacional y el \u00e1lgebra relacional\u201d de este curso.\nSentenciaCl\u00e1usula\nCl\u00e1usula\nCl\u00e1usula\uf8e9 FUOC \u2022 71Z799014MO 9 El lenguaje SQL\nLos sistemas relacionales comerciales y los investigadores de bases de datos \nson una referencia muy impo rtante para mantener el est\u00e1ndar actualizado. En \nestos momentos ya se dispone de una nueva versi\u00f3n de SQL92 que se denomi -\nna SQL: 1999 o SQL3. SQL: 1999 tiene a SQL92 como subconjunto, e incorpora \nnuevas prestaciones de gran inter\u00e9s. En  inform\u00e1tica, en general, y particular -\nmente en bases de datos, es necesario estar siempre al d\u00eda, y por eso es muy im -\nportante tener el h\u00e1bito de leer publicaciones peri\u00f3dicas que nos informen y \nnos mantengan al corriente de las novedades. \n\uf8e9 FUOC \u2022 71Z799014MO 10 El lenguaje SQL\nObjetivos\nUna vez finalizado el estudio de los ma teriales did\u00e1cticos de esta unidad, \ndispondr\u00e9is de las herramientas indispen sables para alcanzar los siguientes \nobjetivos:\n1.Conocer el lenguaje est\u00e1ndar ANSI/ISO SQL92.\n2.Definir una base de datos relacional , incluyendo domini os, aserciones y \nvistas.\n3.Saber introducir, borra r y modificar datos.\n4.Ser capaz de plantear cualquier tipo  de consulta a la base de datos.\n5.Saber utilizar senten cias de control.\n6.Conocer los principios b\u00e1sicos de la utilizaci\u00f3n del SQL desde un lenguaje \nde programaci\u00f3n.\uf8e9 FUOC \u2022 71Z799014MO 11 El lenguaje SQL\n1. Sentencias de definici\u00f3n\nPara poder trabajar con bases de datos relacionales, lo primero que tenemos \nque hacer es definirlas. Veremos las \u00f3r denes del est\u00e1ndar SQL92 para crear y \nborrar una base de datos re lacional y para insertar, borrar y modificar las dife -\nrentes tablas que la componen.\nEn este apartado  tambi\u00e9n veremos c\u00f3mo se definen los dominios, las asercio -\nnes (restricciones) y las vistas. \nLa sencillez y la homogene idad del SQL92 hacen que:\n1)Para crear bases de datos, tablas, domi nios, aserciones y vistas se utilice la \nsentencia  CREATE .\n2)Para modificar tablas y dominios se utilice la sentencia ALTER .\n3)Para borrar bases de datos, tablas, dominios, aserci ones y vistas se utilice la \nsentencia DROP .\nLa adecuaci\u00f3n de estas sentencias a cada caso nos dar\u00e1 diferencias que iremos \nperfilando al hacer la descripci\u00f3n individual de cada una.\nPara ilustrar la aplicaci\u00f3n de las sentencias de SQL que veremos, utilizaremos \nuna base de datos de ejemplo  muy sencilla de una peque\u00f1a empresa con sede \nen Barcelona, Girona, Lleida y Tarrago na, que se encarga de desarrollar pro -\nyectos inform\u00e1ticos. La in formaci\u00f3n que nos interesar\u00e1 almacenar de esta em -\npresa, que denominaremos BDUOC , ser\u00e1 la siguiente:\n1)Sobre los empleados que trab ajan en la empresa, qu erremos saber su c\u00f3digo \nde empleado, el nombre y ap ellido, el sueldo, el nomb re y la ciudad de su de -\npartamento y el n\u00famero de proyecto al que est\u00e1n asignados.\n2)Sobre los diferentes departamentos en lo s que est\u00e1 estructurada la empresa, \nnos interesa conocer su no mbre, la ciudad donde se encuentran y el tel\u00e9fono. \nSer\u00e1 necesario tener en cuenta que un departamento con el mismo nombre \npuede estar en ciudades diferentes, y que en una misma ciudad puede haber \ndepartamentos con no mbres diferentes.\n3)Sobre los proyectos inform \u00e1ticos que se desarrollan, querremos saber su c\u00f3 -\ndigo, el nombre, el precio, la fecha de in icio, la fecha previs ta de finalizaci\u00f3n, \nla fecha real de finalizaci\u00f3n y el c\u00f3di go de cliente para quien se desarrolla.\n4)Sobre los clientes para quien trabaja la  empresa, querremos saber el c\u00f3digo \nde cliente, el nombre, el NIF, la direcci\u00f3n, la ciudad y el tel\u00e9fono.Vistas\nUna vista en el modelo relacio-\nnal no es sino una tabla virtual derivada de las tablas reales de nuestra base de datos, un es-quema externo puede ser un conjunto de vistas.\n\uf8e9 FUOC \u2022 71Z799014MO 12 El lenguaje SQL\n1.1. Creaci\u00f3n y borrado de una base de datos relacional\nEl est\u00e1ndar SQL92 no dispone de ninguna sentencia de creaci\u00f3n de bases de \ndatos. La idea es que una base de datos no es m\u00e1s que un conjunto de tablas \ny, por lo tanto, las senten cias que nos ofrece el SQL92 se concentran en la crea -\nci\u00f3n, la modificaci\u00f3n y el borrado de estas tablas.\nEn cambio, disponemos de una sentencia m\u00e1 s potente que la de creaci\u00f3n de bases \nde datos: la sentencia de creaci\u00f3n de esquemas  denominada CREATE SCHEMA . \nCon la creaci\u00f3n de esquemas podemos ag rupar un conjunto de elementos de la \nbase de datos que son propiedad de un usuario. La sintaxis de esta sentencia es la \nque ten\u00e9is a continuaci\u00f3n:\nLa nomenclatura utilizada en la sentencia es la siguiente: \n\u2022 Las palabras en negrita son palabras reservadas del lenguaje: \n\u2022 La notaci\u00f3n [...] quiere decir que lo que hay entre los corchetes se podr\u00eda \nponer o no.\n\u2022L a  n o t a c i \u00f3 n  {A| ... |B} quiere decir que tenemos que elegir entre todas las \nopciones que hay entre las llaves, pe ro debemos poner una obligatoriamente.\nLa sentencia de creaci\u00f3n de esquemas hace que varias tablas ( lista_de_ele-\nmentos_del_esquema ) se puedan agrupar ba jo un mismo nombre ( nom-\nbre_esquema ) y que tengan un propietario ( usuario ). Aunque todos los par\u00e1 -\nmetros de la sentencia CREATE SCHEMA  son opcionales, como m\u00ednimo se debe \ndar o bien el nombre del es quema, o bien el nombre del usuario propietario de la \nbase de datos. Si s\u00f3lo especificamos el usuario, \u00e9ste ser\u00e1 el nombre del esquema.\nLa creaci\u00f3n de esquemas  puede hacer mucho m\u00e1s qu e agrupar tablas, porque \nlista_de_elementos_del_esquema  puede, adem\u00e1s de tablas, ser tambi\u00e9n \ndominios, vistas, privilegios y re stricciones, entre otras cosas.\nPara borrar una base de datos encontramos  el mismo problema que para crear -\nla. El est\u00e1ndar SQL92 s\u00f3lo nos ofrece la sentencia de borrado de esquemas \nDROP SCHEMA , que presenta la siguiente sintaxis:CREATE SCHEMA  {[nombre_esquema]} | [AUTHORIZATION  usuario]} \n[lista_de_elementos_del_esquema];\nDROP SCHEMA  nombre_esquema { RESTRICT |CASCADE};La instrucci\u00f3n  \nCREATE DATABASE\nMuchos de los sistemas  \nrelacionales comerciales  \n(como ocurre en el caso  \nde Informix, DB2, SQL  \nServer y otros) han incorporado sentencias de creaci\u00f3n  \nde bases de datos con la  \nsiguiente sintaxis:\nCREATE DATABASE\nLa sentencia  \nDROP DATABASE\nMuchos de los sistemas  \nrelacionales comerciales  \n(como por ejemplo Informix, DB2, SQL Server y otros)  \nhan incorporado sentencias  \nde borrado de bases de datos con la siguiente sintaxis:\nDROP DATABASE\uf8e9 FUOC \u2022 71Z799014MO 13 El lenguaje SQL\nDonde tenemos lo siguiente:\n\u2022 La opci\u00f3n de borrado de esquemas RESTRICT  hace que el esquema s\u00f3lo se \npueda borrar si no contiene ning\u00fan elemento.\n\u2022L a  o p c i \u00f3 n  CASCADE  borra el esquema aunque no  est\u00e9 completamente vac\u00edo.\n1.2. Creaci\u00f3n de tablas\nComo ya hemos visto, la estructura de  almacenamiento de los datos del mo -\ndelo relacional so n las tablas. Para crear una tabla , es necesario utilizar la  sen-\ntencia CREATE TABLE . Veamos su formato:\nDonde definici\u00f3n_columna  es:\nEl proceso que hay que seguir para crear una tabla es el siguiente: \n1)Lo primero que tenemos que hacer es decidir qu\u00e9 nombre queremos poner \na la tabla ( nombre_tabla ).\n2)Despu\u00e9s, iremos dando el nombre de cada uno de los atributos que forma -\nr\u00e1n las columnas de la tabla ( nombre_columna ).\n3)A cada una de las columnas  le asignaremos un tipo  de datos predefinido o \nbien un dominio definido por el usuario. Tambi\u00e9n podremos dar definiciones \npor defecto y restricciones de columna.\n4)Una vez definidas las columnas, s\u00f3lo nos quedar\u00e1 dar las restricciones de tabla.\n1.2.1. Tipos de datos\nPara cada columna tenemos que elegir entre al g\u00fan dominio definido por el usua -\nrio o alguno de los tipos de datos predef inidos que se describen a continuaci\u00f3n:CREATE TABLE  nombre_tabla\n( definici\u00f3n_columna\n[, definici\u00f3n_columna...]\n[, restricciones_tabla]\n);\nnombre_columna {tipo_datos |dominio} [def_defecto] [restric_col]\nTipos de datos predefinidos\nTipos de datos Descripci\u00f3n\nCHARACTER (longitud) Cadenas de caracteres de longitud fija.\nCHARACTER VARYING (longitud) Cadenas de caracteres de longitud variable.Recordad que las tablas se han \nestudiado en la unidad \u201cEl modelo relacional y el \u00e1lgebra relacional\u201d  \nde este curso.\nRecordad que las correspondencias entre los tipos de datos y los dominios predefinidos del modelo relacional se han visto en el subapartado 2.2 de la unidad \u201cEl modelo relacional  \ny el \u00e1lgebra relacional\u201d de este curso.\n\uf8e9 FUOC \u2022 71Z799014MO 14 El lenguaje SQL\nEjemplos de asignaciones de columnas\nVeamos algunos ejemplos de asignaciones de columnas en los tipos de datos predefinidos \nDATE , TIME  y TIMESTAMP :\n\u2022 La columna fecha_nacimiento  podr\u00eda ser del tipo DATE  y podr\u00eda tener como valor \n\u20181978-12-25\u2019.\n\u2022 La columna inicio_partido  podr\u00eda ser del tipo TIME  y podr\u00eda tener como valor \n\u201817:15:00.000000\u2019.\n\u2022L a  c o l u m n a  entrada_trabajo  podr\u00eda ser de tipo TIMESTAMP  y podr\u00eda tener como valor \n\u20181998-7-8 9:30:05\u2019.\n1.2.2. Creaci\u00f3n, modificaci\u00f3n y borrado de dominios\nAdem\u00e1s  de los dominios dados por el tipo de datos predefinidos, el SQL92 nos \nofrece la posibilidad de  trabajar con dominios definidos por el usuario.\nPara crear un dominio  es necesario utiliz ar la sentencia CREATE DOMAIN :\ndonde restricciones_dominio  tiene el siguiente formato:Tipos de datos predefinidos\nTipos de datos Descripci\u00f3n\nBIT (longitud) Cadenas de bits de longitud fija.\nBIT VARYING (longitud) Cadenas de bits de longitud variables.\nNUMERIC (precisi\u00f3n, escala)N\u00famero decimales con tantos d\u00edgitos  \ncomo indique la precisi\u00f3n y tantos decimales  \ncomo indique la escala.\nDECIMAL (precisi\u00f3n, escala)N\u00famero decimales con tantos d\u00edgitos  \ncomo indique la precisi\u00f3n y tantos decimales  \ncomo indique la escala.\nINTEGER N\u00fameros enteros.\nSMALLINT N\u00fameros enteros peque\u00f1os.\nREALN\u00fameros con coma flotante con precisi\u00f3n \npredefinida.\nFLOAT (precisi\u00f3n)N\u00fameros con coma flotante con la precisi\u00f3n especificada.\nDOUBLE PRECISIONN\u00fameros con coma flotante con m\u00e1s precisi\u00f3n predefinida que la del tipo REAL .\nDATEFechas. Est\u00e1n compuestas de: YEAR a\u00f1o, MONTH \nmes, DAY d\u00eda . \nTIMEHoras. Est\u00e1n compuestas de HOUR hora, MINUT \nminutos, SECOND segundos .\nTIMESTAMPFechas y horas. Est\u00e1n compuestas de YEAR a\u00f1o, \nMONTH mes, DAY d\u00eda, HOUR hora, MINUT minutos, SECOND segundos .\nCREATE DOMAIN nombre dominio [ AS] tipos_datos  \n[def_defecto] [restricciones_dominio];\n[CONSTRAINT  nombre_restricci\u00f3n] CHECK (condiciones)Los tipos de datos  \nNUMERIC y DECIMAL\nNUMERIC  y DECIMAL  se descri-\nben igual, y es posible utilizar tanto el uno como el otro para definir n\u00fameros decimales.\nEl tratamiento del tiempo\nEl est\u00e1ndar SQL92 define  \nla siguiente nomenclatura  \npara trabajar con el tiempo:\nYEAR (0001..9999)\nMONTH (01..12)\nDAY (01..31)\nHOUR (00..23)\nMINUT (00..59)\nSECOND (00..59.precisi\u00f3n)\nDe todos modos, los sistemas \nrelacionales comerciales  \ndisponen de diferentes  \nformatos, entre los cuales  \npodemos elegir cuando  \ntenemos que trabajar con  \ncolumnas temporales.\nDominios definidos  \npor el usuario\nAunque el SQL92 nos ofrece  \nla sentencia CREATE DOMAIN , \nhay pocos sistemas relaciona-les comerciales que nos  \npermitan utilizarla.\nExplicaremos la construcci\u00f3n  \nde condiciones m\u00e1s adelante, en el subapartado 2.5 cuando hablemos  \nde c\u00f3mo se hacen consultas a una base  \nde datos. Veremos def_defecto  en  \nel subapartado 1.2.3 de esta unidad.\n\uf8e9 FUOC \u2022 71Z799014MO 15 El lenguaje SQL\nCreaci\u00f3n de un dominio en BDUOC\nSi quisi\u00e9ramos definir un dominio para las ci udades donde se encuentran los departamentos \nde la empresa BDUOC, har\u00edamos:\nDe este modo, cuando definimos la columna ciudades  dentro de la tabla departamentos \nno se tendr\u00e1 que decir que es de tipo CHAR  (20) , sino de tipo dom_ciudades . Esto nos de -\nber\u00eda asegurar, seg\u00fan el modelo  relacional, que s\u00f3lo haremos operaciones sobre la columna \nciudades  con otras columnas que tengan este mism o dominio definido po r el usuario; sin \nembargo, el SQL92 no nos ofrece herramientas  para asegurar que las comparaciones que ha -\ncemos sean entre los mismos dominios definidos por el usuario.\nPor ejemplo, si tenemos una columna con los nombres de los empleado s definida sobre el \ntipo de datos CHAR  (20) , el SQL nos permite compararla con la columna ciudades , aunque \nsem\u00e1nticamente no tenga sentido. En cambio, seg\u00fan el modelo relacional, esta comparaci\u00f3n \nno se deber\u00eda haber permitido.\nPara borrar un domi nio definido po r el usuario  es preciso utilizar la senten -\ncia DROP DOMAIN , que tiene este formato:\nEn este caso, tenemos que:\n\u2022 La opci\u00f3n de borrado de dominios RESTRICT  hace que el dominio s\u00f3lo se \npueda borrar si no se utiliza en ning\u00fan sitio.\n\u2022L a  o p c i \u00f3 n  CASCADE  borra el dominio aunque est\u00e9 referenciado, y pone el \ntipo de datos del domini o all\u00ed donde se utilizaba.\nBorrar un dominio de BDUOC\nSi quisi\u00e9ramos borrar el dominio que hemos cr eado antes para las ci udades donde se encuen -\ntran los departamentos de la empresa BDUOC, har\u00edamos:\nEn este caso nos deber\u00edamos asegurar de  que ninguna columna est\u00e1 definida sobre dom_ciu-\ndades  antes de borrar el dominio.\nPara modificar un dominio sem\u00e1ntico  es necesario utilizar la sentencia \nALTER DOMAIN . Veamos su formato:CREATE DOMAIN dom_ciudades AS CHAR (20)\nCONSTRAINT ciudades_validas\nCHECK (VALUE IN (\u2018Barcelona\u2019, \u2018Tarragona\u2019, \u2018Lleida\u2019, \u2018Girona\u2019));\nDROP DOMAIN  nombre_dominio { RESTRICT |CASCADE};\nDROP DOMAIN dom_ciudades RESTRICT;\nALTER  DOMAIN  nombre_dominio  {acci\u00f3n_modificar_dominio | \nacci\u00f3n_modif_restricci\u00f3n_dominio};\uf8e9 FUOC \u2022 71Z799014MO 16 El lenguaje SQL\nDonde tenemos lo siguiente:\n\u2022acci\u00f3n_modificar_dominio  puede ser:\n\u2022acci\u00f3n_modif_restricci\u00f3n_dominio  puede ser:\nModificar un dominio en BDUOC\nSi quisi\u00e9ramos a\u00f1adir una nuev a ciudad (Matar\u00f3) al dominio que hemos creado antes para \nlas ciudades donde se encuentran los depa rtamentos de la empresa BDUOC, har\u00edamos:\nCon esto hemos eliminado la restricci\u00f3n de dominio antigua. Y ahora tenemos que introdu -\ncir la nueva restricci\u00f3n:\n1.2.3. Definicion es por defecto\nYa hemos visto en otros m\u00f3dulos la importancia de los valores nulos y su inevi -\ntable aparici\u00f3n como valores de las bases de datos.\nLa opci\u00f3n  def_defecto  nos permite espe cificar qu\u00e9 nomenclatura queremos \ndar a nuestros va lores por omisi\u00f3n.\nPor ejemplo, para un empleado que todav\u00eda no se ha decidido cu\u00e1nto ganar\u00e1, \npodemos elegir que, de momento, tenga un sueldo de 0 euros ( DEFAULT 0.0 ), \no bien que tenga un sueldo con un valor nulo ( DEFAULT NULL ).\nSin embargo, hay que tener en cuenta que si elegimos la opci\u00f3n DEFAULT \nNULL , la columna para la que daremos la definici\u00f3n po r defecto de valor nulo \ndeber\u00eda admitir valores nulos.\nLa opci\u00f3n DEFAULT  tiene el siguiente formato:{SET def_defecto |DROP DEFAULT }\n{ADD restricciones_dominio |DROP  CONSTRAINT  nombre_restricci\u00f3n}\nALTER DOMAIN dom_ciudades DROP CONSTRAINT ciudades_validas;\nALTER_DOMAIN dom_ciudades ADD CONSTRAINT ciudades_validas\nCHECK  (VALUE  IN (\u2018Barcelona\u2019,  \u2018Tarragona\u2019,  \u2018Lleida\u2019,  \u2018Girona\u2019,  \u2018Mataro\u2019));\nDEFAULT (literal |funci\u00f3n |NULL)\uf8e9 FUOC \u2022 71Z799014MO 17 El lenguaje SQL\nLa posibilidad m\u00e1s ut ilizada y la opci\u00f3n por defect o, si no especificamos nada, \nes la palabra reservada NULL . Sin embargo, tambi\u00e9n podemos definir nuestro \npropio literal, o bien recurrir a una de las funciones que aparecen en la tabla \nsiguiente:\n1.2.4. Restricciones de columna\nEn cada una de las columnas de la tabl a, una vez les hemos dado un nombre y \nhemos definido su dominio, podemos imponer ciertas restricciones que siem -\npre se tendr\u00e1n que cumplir. Las restricciones que se pueden dar son las que apa -\nrecen en la tabla que tenemos a continuaci\u00f3n:\n1.2.5. Restricciones de tabla\nUna vez hemos dado un nombre, hemos de finido una tabla y hemos impuesto \nciertas restricciones para cada una de las columnas, podemos aplicar restriccio -\nnes sobre toda la tabla, que siempre se deber\u00e1n cumplir. Las restricciones que \nse pueden dar son las siguientes:Funci\u00f3n Descripci\u00f3n\n{USER |CURRENT_USER} Identificador del usuario actual\nSESSION_USER Identificador del usuario de esta sesi\u00f3n\nSYSTEM_USER Identificador del usuario del sistema operativo\nCURRENT_DATE Fecha actual\nCURRENT_TIME Hora actual\nCURRENT_TIMESTAMP Fecha y hora actuales\nRestricciones de columna\nRestricci\u00f3n Descripci\u00f3n\nNOT NULL La columna no puede tener valores nulos.\nUNIQUELa columna no puede tener valores repetidos. Es una clave \nalternativa.\nPRIMARY KEYLa columna no puede tener va lores repetidos ni nulos.  \nEs la clave primaria.\nREFERENCES  \ntabla [(columna)]La columna es la clave for\u00e1nea de la columna de la tabla \nespecificada.\nCHECK (condiciones) La columna debe cumplir las condiciones especificadas.\nRestricciones de tabla\nRestricci\u00f3n Descripci\u00f3n\nUNIQUE \n(columna [, columna . . .])El conjunto de las colu mnas especificadas no \npuede tener valores repetidos. Es una clave alternativa.\uf8e9 FUOC \u2022 71Z799014MO 18 El lenguaje SQL\n1.2.6. Modificaci\u00f3n y borrado de  claves primarias con claves  \nfor\u00e1neas que hacen referencia a \u00e9stas\nEn otra unidad de este curso hemos vist o tres pol\u00edticas aplicables a los casos de \nborrado y modificaci\u00f3n de filas que tien en una clave primaria  referenciada por \nclaves for\u00e1neas. Estas pol\u00edticas eran la restricci\u00f3n, la actu alizaci\u00f3n en cascada \ny la anulaci\u00f3n.\nEl SQL nos ofrece la posibilidad de especi ficar, al definir un a clave for\u00e1nea, qu\u00e9 \npol\u00edtica queremos seguir . Veamos su formato:\nDonde una de las restricciones de tabla era la definici\u00f3n de claves for\u00e1neas, \nque tiene el siguiente formato:\nDonde NO ACTION  corresponde a la pol\u00edtica de restricci\u00f3n; CASCADE , a la actua -\nlizaci\u00f3n en cascada, y SET NULL  ser\u00eda la anulaci\u00f3n. SET DEFAULT  se podr\u00eda con -\nsiderar una variante de SET NULL , donde en lugar de valores nulos se puede poner \nel valor especificado por defecto.Restricciones de tabla\nRestricci\u00f3n Descripci\u00f3n\nPRIMARY KEY\n(columna [, columna . . .])El conjunto de las co lumnas especificadas  \nno puede tener valores nulos ni repetidos.  \nEs una clave primaria.\nFOREIGN KEY\n(columna [, columna . . .])\nREFERENCES tabla\n[(columna2 [, columna2 . . .])]El conjunto de las colu mnas especificadas es \nuna clave for\u00e1nea que referencia la clave primaria formada por el conjunto de las columnas2 de la tabla dada. Si las columnas \n \ny las columnas2 se de nominan exactamente \nigual, entonces no ser\u00eda necesario poner \ncolumnas2.\nCHECK (condiciones)La tabla debe cumplir las condiciones especificadas.\nCREATE TABLE  nombre_tabla\n( definici\u00f3n_columna\n[, definici\u00f3n_columna. . .]\n[, restricciones_tabla]\n);\nFOREIGN  KEY clave_secundaria  REFERENCES  tabla  [(clave_primaria)]\n[ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]\n[ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]Para recordar las pol\u00edticas  \nque se pueden aplicar a los casos  \nde borrado y modificaci\u00f3n de las filas, consultad los subapartados 4.3.1,  \n4.3.2 y 4.3.3 de la unidad \u201cEl modelo relacional y el \u00e1lgebra relacional\u201d  \nde este curso.\n\uf8e9 FUOC \u2022 71Z799014MO 19 El lenguaje SQL\n1.2.7. Aserciones\nUna aserci\u00f3n es una restricci\u00f3n genera l que hace referencia a una o m\u00e1s co -\nlumnas de m\u00e1s de una tabla. Para definir una aserci\u00f3n  se utiliza la sentencia\nCREATE ASSERTION , y tiene el siguiente formato:\nCrear una aserci\u00f3n en BDUOC\nCreamos una aserci\u00f3n sobre la base de dato s BDUOC que nos asegure que no hay ning\u00fan \nempleado con un sueldo superior a 80.000 asignado al proyecto SALSA:\nPara borrar una aserci\u00f3n  es necesario utilizar la sentencia DROP ASSERTION , \nque presenta este formato:\nBorrar una aserci\u00f3n en BDUOC\nPor ejemplo, para borrar la aserci\u00f3n restriccion1 , utilizar\u00edamos la sentencia DROP\nASSERTION  de la forma siguiente:\n1.3. Modificaci\u00f3n y borrado de tablas\nPara modificar una tabla  es preciso utilizar la sentencia ALTER TABLE . Vea -\nmos su formato:CREATE ASSERTION  nombre_aserci\u00f3n CHECK (condiciones);\nCREATE ASSERTION restriccion1 CHECK (NOT EXISTS (SELECT * \nFROM proyectos p, empleados e\nWHERE p.codigo_proyec =  \n= e.num_proyec  and e.sueldo > 8.0E+4\nand p.nom_proj = \u2018SALSA\u2019) );\nDROP ASSERTION  nombre_aserci\u00f3n;\nDROP ASSERTION restriccion1;\nALTER TABLE  nombre_tabla {acci\u00f3n_modificar_columna |\nacci\u00f3n_modif_restricci\u00f3n_tabla};\uf8e9 FUOC \u2022 71Z799014MO 20 El lenguaje SQL\nEn este caso, tenemos que:\n\u2022acci\u00f3n_modificar_columna  puede ser:\n\u2022acci\u00f3n_modif_restricci\u00f3n_tabla  puede ser:\nSi queremos modificar una tabla es que qu eremos realizar una de las siguientes \noperaciones: \n1)A\u00f1adirle una columna ( ADD columna ).\n2)Modificar las definiciones po r defecto de la columna ( ALTER columna ).\n3)Borrar la columna ( DROP columna ).\n4)A\u00f1adir alguna nueva restricci\u00f3n de tabla ( ADD restricci\u00f3n ).\n5)Borrar alguna restricci\u00f3n de tabla ( DROPCONSTRAINT restricci\u00f3n ).\nPara borrar una tabla  es preciso utilizar la sentencia DROP TABLE :\nEn este caso tenemos que:\n\u2022 Si utilizamos la opci\u00f3n RESTRICT , la tabla no se borrar\u00e1 si est\u00e1 referencia -\nda, por ejemplo, por alguna vista.\n\u2022 Si usamos la opci\u00f3n CASCADE , todo lo que referencie  a la tabla se borrar\u00e1 \ncon \u00e9sta.\n1.4. Creaci\u00f3n y borrado de vistas\nComo hemos observado, la arquitectura ANSI/SPARC distingue tres niveles, que \nse describen en el esquema conceptual , el esquema interno y los esquemas ex -\nternos. Hasta ahora, mientras cre\u00e1bamos la s tablas de la base de datos, \u00edbamos {ADD [COLUMN] columna def_columna |\nALTER [COLUMN] columna { SET def_defecto |DROP DEFAULT }|\nDROP [COLUMN ] columna { RESTRICT |CASCADE}}\n{ADD restricci\u00f3n |\nDROP CONSTRAINT  restricci\u00f3n { RESTRICT |CASCADE}}\nDROP TABLE  nombre_tabla { RESTRICT |CASCADE};\nLos tres niveles de la arquitectura \nANSI/SPARC se han estudiado  \nen el subapartado 4.1 de la unidad \u201cIntroducci\u00f3n a las bases de datos\u201d  \nde este curso.\n\uf8e9 FUOC \u2022 71Z799014MO 21 El lenguaje SQL\ndescribiendo el esquema co nceptual. Para describir los diferentes esquemas ex -\nternos utilizamos el concepto de vista del SQL.\nPara crear una vista  es necesario utilizar la sentencia CREATE VIEW . Veamos \nsu formato:\nLo primero que tene mos que hacer para crear una vista es decidir qu\u00e9 nombre \nle queremos poner ( nombre_vista ). Si queremos cambia r el nombre de las \ncolumnas, o bien poner nombre a alguna  que en principio no ten\u00eda, lo pode -\nmos hacer en lista_columnas . Y ya s\u00f3lo nos quedar\u00e1 definir la consulta que \nformar\u00e1 nuestra vista.\nLas vistas no existen realmente como un conjunto de valores almacenados \nen la base de datos, sino que son tablas ficticias, denominadas  derivadas  (no \nmaterializadas). Se construyen a partir de tablas reales (materializadas) alma -\ncenadas en la base de datos, y conocidas con el nombre de tablas b\u00e1sicas (o \ntablas de base). La no-existencia real de las vistas hace que puedan ser actua -\nlizables o no. \nCreaci\u00f3n de una vista en BDUOC\nCreamos una vista sobre la base de datos BDUOC que nos d\u00e9 para cada cliente el n\u00famero de \nproyectos que tiene encargados el cliente en cuesti\u00f3n.\nSi tuvi\u00e9semos las siguientes extensiones:\n\u2022T a b l a  clientes :\n\u2022T a b l a  proyectos :CREATE VIEW  nombre_vista [(lista_columnas)] AS (consulta)\n[WITH CHECK OPTION ];\nCREATE  VIEW  proyectos_por_cliente  (codigo_cli, numero_proyectos) AS\n(SELECT c.codigo_cli, COUNT(*)\nFROM proyectos p, clientes c\nWHERE p.codigo_cliente = c.codigo_cli\nGROUP BY c.codigo_cli);\nclientes\ncodigo_cli nombre_cli nif direccion ciudad telefono\n10 ECIGSA 38.567.893-C Arag\u00f3n 11 Barcelona NULL\n20 CME 38.123.898-E Valencia 22 Girona 972.23.57.21\n30 ACME 36.432.127-A Mallorca 33 Lleida 973.23.45.67Por lo que respecta a la \nconstrucci\u00f3n de consultas, consultad el subapartado 2.5  \nde esta unidad did\u00e1ctica.\nproyectos\ncodigo_proyec nombre_proyec precio fecha_inicio fecha_prev_fin fecha_fin codigo_cliente\n1 GESCOM 1,0E+6 1-1-98 1-1-99 NULL 10\n2 PESCI 2,0E+6 1-10-96 31-3-98 1-5-98 10\uf8e9 FUOC \u2022 71Z799014MO 22 El lenguaje SQL\nY mir\u00e1semos la extensi\u00f3n de la vista proyectos_por_clientes , ver\u00edamos lo que encon -\ntramos en el margen.\nEn las vistas, adem\u00e1s de hacer consulta s, podemos insertar, modificar y borrar \nfilas.\nActualizaci\u00f3n de vistas en BDUOC\nSi alguien insertase en la vista proyectos_por_cliente , los valores para un nuevo cliente \n60 con tres proyectos encargados, encontrar\u00edam os que estos tres proyectos tendr\u00edan que fi -\ngurar realmente en la tabla proyectos  y, por lo tanto, el SGBD los deber\u00eda insertar con la \ninformaci\u00f3n que tenemos, que es pr\u00e1cticamente inexistente. Veamos gr\u00e1ficamente c\u00f3mo \nquedar\u00edan las tablas despu\u00e9s de esta hipot\u00e9tica actualizaci\u00f3n, que no llegaremos a hacer nun -\nca, ya que ir\u00eda en contra de la  teor\u00eda del modelo relacional:\n\u2022T a b l a  clientes\n\u2022T a b l a  p r o y e c t o s :\nEl SGBD no puede actual izar la tabla b\u00e1sica clientes  si s\u00f3lo sabe la clave primaria, y \ntodav\u00eda menos la tabla b\u00e1sica proyectos  sin la clave primaria; por lo tanto, esta vista no \nser\u00eda actualizable.\nEn cambio, si definimos una vista para saber los clientes que tenemos en Barcelona o en Gi -\nrona, har\u00edamos:proyectos\ncodigo_proyec nombre_proyec precio fecha_inicio fecha_prev_fin fecha_fin codigo_cliente\n3 SALSA 1,0E+6 10-2-98 1-2-99 NULL 20\n4 TINELL 4,0E+6 1-1-97 1-12-99 NULL 30\nclientes\ncodigo_cli nombre_cli nif direccion ciudad telefono\n10 ECIGSA 38.567.893-C Arag\u00f3n 11 Barcelona NULL\n20 CME 38.123.898-E Valencia 22 Girona 972.23.57.21\n30 ACME 36.432.127-A Mallorca 33 Lleida 973.23.45.67\n60 NULL NULL NULL NULL NULLproyectos_por_clientes\ncodigo_cli numero_proyectos\n10 220 130 1\nproyectos\ncodigo_proyec nombre_proyec precio fecha_inicio fecha_prev_fin fecha_fin codigo_cliente\n1 GESCOM 1,0E+6 1-1-98 1-1-99 NULL 10\n2 PESCI 2,0E+6 1-10-96 31-3-98 1-5-98 10\n3 SALSA 1,0E+6 10-2-98 1-2-99 NULL 20\nNULL NULL NULL NULL NULL NULL 60\nNULL NULL NULL NULL NULL NULL 60\nNULL NULL NULL NULL NULL NULL 60\nCREATE VIEW clientes_Barcelona_Girona AS\n(SELECT *\nFROM clientes\nWHERE ciudad IN (\u2018Barcelona\u2019, \u2018Girona\u2019))\nWHITH CHECK OPTION;\uf8e9 FUOC \u2022 71Z799014MO 23 El lenguaje SQL\nSi queremos asegurarnos de que se cumpla la condici\u00f3n de la cl\u00e1usula WHERE , debemos poner \nla opci\u00f3n WHITH CHECK OPTION . Si no lo hici\u00e9semos, podr\u00eda ocurrir que alguien incluyese \nen la vista clientes_Barcelona_Girona  a un cliente nuevo con el c\u00f3digo 70, de nombre \nJMB, con el NIF 36.788.224-C, la direcci\u00f3n en NULL, la ciudad Lleida y el tel\u00e9fono NULL.\nSi consult\u00e1semos la extensi\u00f3n de la vista clientes_Barcelona_Girona , ver\u00edamos:\nEsta vista s\u00ed podr\u00eda ser actual izable. Podr\u00edamos insertar un nu evo cliente con c\u00f3digo 50, de \nnombre CEA, con el NIF 38.226.777-D, con la dire cci\u00f3n Par\u00eds 44, la ciudad Barcelona y el te -\nl\u00e9fono 93.422.60.77. Despu\u00e9s de esta actualizaci\u00f3n, en la tabla b\u00e1sica clientes  encontra -\nr\u00edamos, efectivamente:\nPara borrar una vista es preciso utilizar la sentencia DROP VIEW , que presenta \nel formato:\nSi utilizamos la opci\u00f3n RESTRICT , la vista no se borrar\u00e1  si est\u00e1 referenciada, \npor ejemplo, por otra vista. En  cambio, si ponemos la opci\u00f3n CASCADE , todo \nlo que referencie a la vi sta se borrar\u00e1 con \u00e9sta.\nBorrar una vista en BDUOC\nPara borrar la vista clientes_Barcelona_Girona , har\u00edamos lo siguiente:\n1.5. Definici\u00f3n de la base de datos relacional BDUOC\nVeamos c\u00f3mo se crear\u00eda la  base de datos BDUOC, ut ilizando, por ejemplo, un \nSGBD relacional que disponga de la sentencia CREATE DATABASE :clientes_Barcelona_Girona\ncodigo_cli nombre_cli nif direccion ciudad telefono\n10 ECIGSA 38.567.893-C Arag\u00f3n 11 Barcelona NULL\n20 CME 38.123.898-E Valencia 22 Girona 972.23.57.21\nclientes\ncodigo_cli nombre_cli nif direccion ciudad telefono\n10 ECIGSA 38.567.893-C Arag\u00f3n 11 Barcelona NULL\n20 CME 38.123.898-E Valencia 22 Girona 972.23.57.21\n30 ACME 36.432.127-A Mallorca 33 Lleida 973.23.45.67\n50 CEA 38.226.777-D Par\u00eds, 44 Barcelona 93.442.60.77\nDROP VIEW  nombre_vista ( RESTRICT |CASCADE);\nDROP VIEW clientes_Barcelona_Girona RESTRICT;\nCREATE DATABASE bduoc;\nCREATE TABLE clientesOrden de creaci\u00f3n\nAntes de crear una tabla con \nuna o m\u00e1s claves for\u00e1neas, se deben haber creado las  \ntablas que tienen como clave primaria las referenciadas  \npor las for\u00e1neas.\uf8e9 FUOC \u2022 71Z799014MO 24 El lenguaje SQL\n(codigo_cli INTEGER,\nnombre_cli CHAR(30) NOT NULL,\nnif CHAR (12),\ndireccion CHAR (30),\nciudad CHAR (20),\ntelefono CHAR (12),\nPRIMARY KEY (codigo_cli),\nUNIQUE(nif)\n);\nCREATE TABLE departamentos\n(nombre_dep CHAR(20) PRIMARY KEY,*\nciudad_dep CHAR(20),\ntelefono INTEGER DEFAULT NULL,\nPRIMARY KEY (nombre_dep, ciudad_dep)\n);\nCREATE TABLE proyectos\n(codigo_proyec INTEGER,\nnombre_proyec CHAR(20),\nprecio REAL,\nfecha_inicio DATE,\nfecha_prev_fin DATE,\nfecha_fin DATE DEFAULT NULL,\ncodigo_cliente INTEGER,\nPRIMARY KEY (codigo_proyec),\nFOREIGN  KEY codigo_cliente  REFERENCES  clientes  (codigo_cli),\nCHECK (fecha_inicio < fecha_prev_fin),\nCHECK (fecha_inicio < fecha_fin)\n);\nCREATE TABLE empleados\n(codigo_empl INTEGER,\nnombre_empl CHAR (20),\napellido_empl CHAR(20),\nsueldo REAL CHECK (sueldo > 7000),\nnombre_dep CHAR(20)\nciudad_dep CHAR(20),\nnum_proyec INTEGER,\nPRIMARY KEY (codigo_empl),\nFOREIGN KEY (nombre_dep, ciudad_dep) REFERENCES\ndepartamentos (nombre_dep, ciudad_dep),\nFOREIGN  KEY (num_proyec)  REFERENCES  proyectos  (codigo_proyec)\n);\nCOMMIT ;* Tenemos que elegir restricci\u00f3n \nde tabla porque la clave primaria \nest\u00e1 compuesta por m\u00e1s \nde un atributo.\nLa sentencia COMMIT  se explica  \nen el subapartado 3.1 de esta unidad did\u00e1ctica.\n\uf8e9 FUOC \u2022 71Z799014MO 25 El lenguaje SQL\nAl crear una tabla vemos que muchas re stricciones se pueden imponer de dos \nformas: como restricciones de columna o como restricciones de tabla. Por ejem -\nplo, cuando queremos decir cu\u00e1l es la clave primaria de una tabla, tenemos las \ndos posibilidades. Esto se de be a la flexibilidad del SQL:\n\u2022 En el caso de que la restricci\u00f3n haga referencia a un solo  atributo, podemos \nelegir la posibilidad  que m\u00e1s nos guste.\n\u2022 En el caso de la tabla departamentos , tenemos que elegir  por fuerza la op -\nci\u00f3n de restricciones de tabla, porque la clave primaria est\u00e1 compuesta por \nm\u00e1s de un atributo.\nEn general, lo pondremos todo como  restricciones de  tabla, excepto NOT NULL\ny CHECK  cuando haga referencia  a una sola columna. \n\uf8e9 FUOC \u2022 71Z799014MO 26 El lenguaje SQL\n2. Sentencias de manipulaci\u00f3n\nUna vez creada la base de datos con sus tablas, debemos poder insertar, modi -\nficar y borrar los valores de las filas de  las tablas. Para poder hacer esto, el \nSQL92 nos ofrece las siguientes sentencias: INSERT  para insertar, UPDATE  para \nmodificar y DELETE  para borrar. Una vez hemos in sertado valores en nuestras \ntablas, tenemos que poder consultarlos. La sentencia para hacer consultas a \nuna base de datos con el SQL92 es SELECT FROM . Veamos a continuaci\u00f3n estas \nsentencias. \n2.1. Inserci\u00f3n de filas en una tabla\nAntes de poder consultar los datos de una base de datos, es preciso introdu -\ncirlos  con la sentencia INSER TINTO VALUES , que tiene el formato:\nLos valores v1, v2, ..., vn se deben corresponder ex actamente con las colum -\nnas que hemos dicho que tendr\u00edamos con el CREATE TABLE  y deben estar en \nel mismo orden, a menos que las volv amos a poner a continuaci\u00f3n del nom -\nbre de la tabla. En este \u00faltimo caso, los valores se deben disponer de forma co -\nherente con el nuevo orden que hemos im puesto. Podr\u00eda darse el caso de que \nquisi\u00e9ramos que algunos valo res para insertar fuesen  valores por omisi\u00f3n, de -\nfinidos previamente con la opci\u00f3n DEFAULT . Entonces pondr\u00edamos la palabra \nreservada DEFAULT . Si se trata de introducir valores nulos, tambi\u00e9n podemos \nutilizar la pala bra reservada NULL .\nInserci\u00f3n de una fila en BDUOC\nLa forma de insertar a un cliente en la tabla clientes  de la base de datos de BDUOC es:\no bien:INSERT INTO  nombre_tabla  [(columnas)]\n{VALUES  ({v1 |DEFAULT |NULL},  ...,  {vn/DEFAULT/NULL}) |<consulta>};\nINSERT INTO clientes\nVALUES  (10,  \u2018ECIGSA\u2019,  \u201837.248.573-C\u2019,  \u2018ARAGON  242\u2019,  \u2018Barcelona\u2019,  DEFAULT);\nINSERT  INTO  clientes(nif,  nombre_cli,  codigo_cli,  telefono,  direccion,  \nciudad)\nVALUES  (\u201837.248.573-C\u2019,  \u2018ECIGSA\u2019,  10,  DEFAULT,  \u2018ARAGON  242\u2019,  \u2018Barcelona\u2019);\nInserci\u00f3n de m\u00faltiples filas\nPara insertar m\u00e1s de una fila \ncon una sola sentencia,  \ntenemos que obtener los  \nvalores como resultado de  \nuna consulta realizada en una  \no m\u00e1s tablas.\uf8e9 FUOC \u2022 71Z799014MO 27 El lenguaje SQL\n2.2. Borrado de filas de una tabla\nPara borrar valores de algunas filas de una tabla  podemos utilizar la senten -\ncia DELETE FROM WHERE . Su formato es el siguiente:\nEn cambio, si lo que qu isi\u00e9ramos conseguir es borrar todas las filas de una \ntabla , entonces s\u00f3lo tendr\u00edamos  que poner la sentencia DELETE FROM , sin \nWHERE .\nBorrar todas las filas de una tabla en BDUOC\nPodemos dejar la tabla proyectos  sin ninguna fila:\nEn nuestra base de datos, borrar los proyectos del cliente 2 se har\u00eda de la forma que mostra -\nmos a continuaci\u00f3n:\n2.3. Modificaci\u00f3n de filas de una tabla\nSi quisi\u00e9ramos modificar los valores de al gunas filas de una tabla , tendr\u00edamos \nque utilizar la sentencia  UPDATE SET WHERE . A continuaci\u00f3n presentamos su \nformato:\nModificaci\u00f3n de los valores  de algunas filas en BDUOC\nSupongamos que queremos incrementar el sueldo  de todos los empleado s del proyecto 2 en \n1.000 euros. La modificaci\u00f3n a ejecutar ser\u00eda:DELETE FROM  nombre_tabla\n[WHERE condiciones];\nDELETE FROM proyectos;\nDELETE FROM proyectos\nWHERE codigo_cliente = 2;\nUPDATE nombre_tabla\nSET columna = {expresi\u00f3n |DEFAULT |NULL}\n[, columna = {expr |DEFAULT |NULL} ...]\nWHERE condiciones;\nUPDATE empleados\nSET sueldo = sueldo + 1000\nWHERE num_proyec = 2;Borrado de m\u00faltiples filas\nNotemos que el cliente con  \nel c\u00f3digo 2 podr\u00eda tener m\u00e1s  \nde un proyecto contratado  \ny, por lo tanto, se borrar\u00eda  \nm\u00e1s de una fila con una sola  \nsentencia.\nModificaci\u00f3n de m\u00faltiples filas\nNotemos que el proyecto  \nn\u00famero 2 podr\u00eda tener  \na m\u00e1s de un empleado  \nasignado y, por lo tanto,  \nse modificar\u00eda la columna  \nsueldo , de m\u00e1s de una fila  \ncon una sola sentencia.\uf8e9 FUOC \u2022 71Z799014MO 28 El lenguaje SQL\n2.4. Introducci\u00f3n de filas en la base de datos relacional BDUOC\nAntes de empezar a hacer consultas a la base de datos BDUOC, habremos intro -\nducido unas cuantas filas en sus tablas con la sentencia INSERT INTO . De esta \nforma, podremos ver reflejado el result ado de las consultas que iremos hacien -\ndo, a partir de este momento, sobre cada  extensi\u00f3n; esto lo podemos observar \nen las tablas correspondientes a cada  extensi\u00f3n, que presentamos a continua -\nci\u00f3n:\n\u2022T a b l a  departamentos :\n\u2022T a b l a  clientes :\n\u2022T a b l a  empleados :departamentos\nnombre_dep ciudad_dep telefono\nDIR Barcelona 93.422.60.70\nDIR Girona 972.23.89.70\nDIS Lleida 973.23.50.40\nDIS Barcelona 93.224.85.23\nPROG Tarragona 977.33.38.52\nPROG Girona 972.23.50.91\nclientes\ncodigo_cli nombre_cli nif direccion ciudad telefono\n10 ECIGSA 38.567.893-C Arag\u00f3n 11 Barcelona NULL\n20 CME 38.123.898-E Valencia 22 Girona 972.23.57.21\n30 ACME 36.432.127-A Mallorca 33 Lleida 973.23.45.67\n40 JGM 38.782.345-B Rosell\u00f3n 44 Tarragona 977.33.71.43\nempleados\ncodigo_empleado nombre_empl apellido_empl sueldo nombre_dep ciudad_dep num_proyec\n1 Mar\u00eda Puig 1,0E+5 DIR Girona 1\n2 Pedro Mas 9,0E+4 DIR Barcelona 4\n3 Ana Ros 7,0E+4 DIS Lleida 3\n4 Jorge Roca 7,0E+4 DIS Barcelona 4\n5 Clara Blanc 4,0E+4 PROG Tarragona 1\n6 Laura Tort 3,0E+4 PROG Tarragona 3\n7 Rogelio Salt 4,0E+4 NULL NULL 4\n8 Sergio Grau 3,0E+4 PROG Tarragona NULL\uf8e9 FUOC \u2022 71Z799014MO 29 El lenguaje SQL\n\u2022T a b l a  proyectos :\n2.5. Consultas a una base de datos relacional\nPara hacer  consultas sobre una tabla con el SQ L es preciso utilizar la sentencia \nSELECT FROM , que tiene el siguiente formato:\nLa opci\u00f3n AS nos permite renombrar las columnas que queremos seleccionar o \nlas tablas que queremos consultar que en este caso, es s\u00f3lo una. Dicho de otro \nmodo, nos permite la definici\u00f3n de alias. Fij\u00e9monos en que la palabra clave AS\nes opcional, y es bastante habitual poner s\u00f3lo un espacio en blanco en lugar de \ntoda la palabra.\nConsultas a BDUOC\nA continuaci\u00f3n presentamos un ejemplo de cons ulta a la base de da tos BDUOC para conocer \ntodos los datos que aparece en la tabla clientes :\nLa respuesta a esta consulta ser\u00eda:proyectos\ncodigo_proyec nombre_proyec precio fecha_inicio fecha_prev_fin fecha_fin codigo_cliente\n1 GESCOM 1,0E+6 1-1-98 1-1-99 NULL 10\n2 PESCI 2,0E+6 1-10-96 31-3-98 1-5-98 10\n3 SALSA 1,0E+6 10-2-98 1-2-99 NULL 20\n4 TINELL 4,0E+6 1-1-97 1-12-99 NULL 30\nSELECT  nombre_columna_a_seleccionar  [[AS] col_renombrada]\n[,nombre_columna_a_seleccionar  [[AS] col_renombrada]...]\nFROM tabla_a_consultar [[ AS] tabla_ renombrada];\nSELECT *\nFROM clientes;\ncodigo_cli nombre_cli nif direccion ciudad telefono\n10 ECIGSA 38.567.893-C Arag\u00f3n 11 Barcelona NULL\n20 CME 38.123.898-E Valencia 22 Girona 972.23.57.21\n30 ACME 36.432.127-A Mallorca 33 Lleida 973.23.45.67\n40 JGM 38.782.345-B Rosell\u00f3n 44 Tarragona 977.33.71.43El * despu\u00e9s de SELECT  indica \nque queremos ver todos \nlos atributos que aparecen\nen la tabla.\uf8e9 FUOC \u2022 71Z799014MO 30 El lenguaje SQL\nSi hubi\u00e9semos querido ver s\u00f3lo el c\u00f3digo, el nombre, la direcci\u00f3n y la ciudad, habr\u00edamos \nhecho:\nY habr\u00edamos obtenido la respuesta siguiente:\nCon la sentencia SELECT FROM  podemos seleccionar columnas de una tabla, \npero para seleccionar filas de una ta bla es preciso a\u00f1adirle la cl\u00e1usula  WHERE . El \nformato es:  \nLa cl\u00e1usula WHERE  nos permite obtener las fila s que cumplen la condici\u00f3n es -\npecificada en la consulta.\nConsultas a BDUOC seleccionando filas\nVeamos un ejemplo en el que pedimos \u201clos c\u00f3di gos de los empleados que trabajan en el pro -\nyecto n\u00famero 4\u201d:\nLa respuesta a esta consulta ser\u00eda la que pod\u00e9is ver en el margen.\nPara definir las condic iones en la cl\u00e1usula WHERE , podemos utilizar alguno de \nlos operadores de los que dispone el SQL, que son los siguientes: \nSi queremos que en una consulta nos ap arezcan las filas resultantes sin repeti -\nciones, es preciso poner la palabra clave DISTINCT  inmediatamente despu\u00e9s SELECT codigo_cli, nombre_cli, direccion, ciudad\nFROM clientes;\ncodigo_cli nombre_cli direccion ciudad\n10 ECIGSA Arag\u00f3n 11 Barcelona\n20 CME Valencia 22 Girona\n30 ACME Mallorca 33 Lleida\n40 JGM Rosell\u00f3n 44 Tarragona\nSELECT nombre_columnas_a_seleccionar\nFROM tabla_a_consultar\nWHERE condiciones;\nSELECT codigo_empl\nFROM empleados\nWHERE num_proyec = 4;\nOperadores de comparaci\u00f3n Operadores l\u00f3gicos\n= Igual NOT Para la negaci\u00f3n de condiciones\n< Menor AND Para la conjunci\u00f3n de condiciones\n> Mayor OR Para la disyunci\u00f3n de condiciones\n<= Menor o igual\n>= Mayor o igual\n< > Diferentecodigo_empl\n247\n\uf8e9 FUOC \u2022 71Z799014MO 31 El lenguaje SQL\nde SELECT . Tambi\u00e9n podr\u00edamos explicitar qu e lo queremos todo, incluso con \nrepeticiones, poniendo ALL (opci\u00f3n por defecto) en lugar de DISTINCT . El for -\nmato de DISTINCT  es:\nConsulta a BDUOC seleccionando filas sin repeticiones\nPor ejemplo, si quisi\u00e9ramos ver qu\u00e9 sueldos se est\u00e1n pagando en nuestra empresa, podr\u00edamos \nhacer:\nLa respuesta a esta consulta, sin repeticiones, ser\u00eda la que aparece en el margen.\n2.5.1. Funciones de agregraci\u00f3n\nEl SQL nos ofrece las siguientes funcione s de agregaci\u00f3n para efectuar varias \noperaciones sobre los dato s de una base de datos:\nEn general, las funciones de agregaci\u00f3n  se aplican a una columna, excepto la \nfunci\u00f3n de agregaci\u00f3n COUNT , que normalmente se aplica a todas las columnas \nde la tabla o tablas seleccionadas. Por lo tanto, COUNT  (*) contar\u00e1 todas las filas \nde la tabla o las tablas que cumplan las condiciones. Si se utilizase COUNT(dis -\ntinct columna) , s\u00f3lo contar\u00eda los valores que no fuesen nulos ni repetidos, y \nsi se utilizase COUNT  (columna) , s\u00f3lo contar\u00eda los valores que no fuesen nulos.\nEjemplo de utilizaci\u00f3n de la funci\u00f3n COUNT  (*)\nVeamos un ejemplo de uso de la funci\u00f3n COUNT , que aparece en la cl\u00e1usula SELECT , para \nhacer la consulta \u201c\u00bfCu\u00e1ntos departamentos est\u00e1n ubicados en la ciudad de Lleida?\u201d:\nLa respuesta a esta consulta ser\u00ed a la que aparece reflejada en la tabla que encontrar\u00e9is en el \nmargen.SELECT DISTINCT  nombre_columnas_a_seleccionar\nFROM tabla_a_consultar\n[WHERE condiciones];\nSELECT DISTINCT sueldo\nFROM empleados;\nFunciones de agregaci\u00f3n\nFunci\u00f3n Descripci\u00f3n\nCOUNT Nos da el n\u00famero total de filas seleccionadas\nSUM Suma los valores de una columna\nMIN Nos da el valor m\u00ednimo de una columna\nMAX Nos da el valor m\u00e1ximo de una columna\nAVG Calcula el valor medio de una columna\nSELECT COUNT (*) AS numero_dep\nFROM departamentos\nWHERE ciudad_dep = \u2018Lleida\u2019;sueldo\n3,0E+44,0E+47,0E+49,0E+41,0E+5\nnumero_dep\n1\uf8e9 FUOC \u2022 71Z799014MO 32 El lenguaje SQL\nVeremos ejemplos de las dem\u00e1s funcione s de agregaci\u00f3n en los siguientes \napartados. \n2.5.2. Subconsultas\nSubconsulta en BDUOC\nSi quisi\u00e9ramos saber los c\u00f3digos y los nombres de los proyectos de precio m\u00e1s elevado, \nen primer lugar tendr\u00edamos que encontrar lo s proyectos que tienen el precio m\u00e1s ele -\nvado. Lo har\u00edamos de la forma siguiente:\nEl resultado de la consulta anterior  ser\u00eda lo que puede verse al margen.\n2.5.3. Otros predicados\n1) Predicado BETWEEN\nPara expresar una condici\u00f3n que quiere encontrar un valor entre unos l\u00edmites \nconcretos, podemos utilizar BETWEEN :\nEjemplo de uso del predicado BETWEEN\nUn ejemplo en el que se pide \u201cLos c\u00f3digos de  los empleados que ganan entre 20.000 y 50.000 \neuros anuales\u201d ser\u00eda:Una subconsulta es una consulta incluida dentro de una cl\u00e1usula WHERE\no HAVING  de otra consulta. En ocasiones, para expresar ciertas condicio -\nnes no hay m\u00e1s remedio que obtene r el valor que buscamos como re -\nsultado de una consulta.\nSELECT codigo_proyec, nombre_proyec\nFROM proyectos\nWHERE precio = ( SELECT MAX (precio)\nFROM proyectos);\nSELECT nombre_columnas_a_seleccionar\nFROM tabla_a_consultar\nWHERE columna BETWEEN l\u00edmite1 AND l\u00edmite2;\nSELECT codigo_empl\nFROM empleados\nWHERE sueldo BETWEEN 2.0E+4 and 5.0E+4;\nVeremos la cl\u00e1usula HAVING   \nen el subapartado 2.5.5 de esta unidad did\u00e1ctica.\ncodigo_proyec nombre_proyec\n4T I N E L L\nLos proyectos de precio \nm\u00e1s bajo\nSi en lugar de los c\u00f3digos  \ny los nombres de proyectos  \nde precio m\u00e1s alto hubi\u00e9semos querido saber los de precio m\u00e1s bajo, habr\u00edamos aplicado la funci\u00f3n de agregaci\u00f3n MIN.\uf8e9 FUOC \u2022 71Z799014MO 33 El lenguaje SQL\nLa respuesta a esta consulta ser\u00ed a la que se ve en el margen.\n2) Predicado IN\nPara comprobar si un valor coincide con los elementos de una lista utilizare -\nmos IN, y para ver si no coincide, NOT IN :\nEjemplo de uso del predicado IN\n\u201cQueremos saber el nombre de todos los departamentos que se encuentran en las ciudades \nde Lleida o Tarragona\u201d:\nLa respuesta ser\u00eda la que aparece en el margen.\n3) Predicado LIKE\nPara comprobar si una columna de tipo  car\u00e1cter cumple alguna propiedad de -\nterminada, podemos usar LIKE :\nLos patrones del SQL92 para  expresar caracter\u00edsticas  son los siguientes: \na)Pondremos un car\u00e1cter _ para cada ca r\u00e1cter individual que queramos con -\nsiderar.\nb)Pondremos un car\u00e1cter % para expres ar una secuencia de caracteres, que \npuede no estar formada por ninguno.\nEjemplo de uso del predicado LIKE\nA continuaci\u00f3n presentamos un ejemplo en el  que buscaremos los nombres de los emplea -\ndos que empiezan por J, y otro ejemplo en el  que obtendremos los proyectos que comienzan \npor S y tienen cinco letras: \na)Nombres de empleados que empiezan por la letra J:  \nLa respuesta a esta consulta ser\u00eda la que se muestra en el margen.SELECT nombre_columnas_a_seleccionar\nFROM tabla_a_consultar\nWHERE columna [NOT] IN (valor1, ..., valorN);\nSELECT nombre_dep, ciudad_dep\nFROM departamentos\nWHERE ciudad_dep IN (\u2018Lleida\u2019, \u2018Tarragona\u2019);\nSELECT nombre_columnas_a_seleccionar\nFROM tabla_a_consultar\nWHERE columna LIKE caracter\u00edstica;\nSELECT codigo_empl, nombre_empl\nFROM empleados\nWHERE nombre_empl LIKE \u2018J%\u2019;codigo_empl\n5678\nnombre_dep ciudad_dep\nDIS Lleida\nPROG Tarragona\nOtros patrones\nAunque _ y % son los  \ncaracteres elegidos por  \nel est\u00e1ndar, cada sistema  \nrelacional comercial ofrece  \ndiversas variantes.\nAtributos a\u00f1adidos\nAunque la consulta pide s\u00f3lo \nlos nombres de empleados a\u00f1adimos el c\u00f3digo para poder diferenciar dos empleados  \ncon el mismo nombre.\ncodigo_empl nombre_empl\n4J o r g e\uf8e9 FUOC \u2022 71Z799014MO 34 El lenguaje SQL\nb)Proyectos que empiezan por S y tienen cinco letras:\nY la respuesta a esta otra consulta ser\u00eda la que aparece en el margen.\n4) Predicado IS NULL\nPara comprobar si un va lor es nulo utilizaremos IS NULL , y para averiguar si \nno lo es, IS NOT NULL . El formato es:\nEjemplo de uso del predicado IS NULL\nUn ejemplo de uso de este predicado ser\u00eda \u201cQue remos saber el c\u00f3digo y el nombre de todos \nlos empleados que no est\u00e1n asignados a ning\u00fan proyecto\u201d:\nObtendr\u00edamos la respuesta que tenemos al margen.\n5) Predicados ANY/SOME  y ALL\nPara ver si una columna cumple que todas sus filas ( ALL) o algunas  de sus filas \n(ANY/SOME ) satisfagan una condici\u00f3n, podemos hacer:\nEjemplo de uso de los predicados ALL y ANY/SOME\na)Veamos un ejemplo de aplicaci\u00f3n de ALL para encontrar los c\u00f3di gos y los nombres de los \nproyectos en los que los sueldos de todos los empleados asignados son menores que el precio \ndel proyecto:SELECT codigo_proyec \nFROM proyectos\nWHERE nombre_proyec LIKE \u2018S_ _ _ _\u2019;\nSELECT nombre_columnas_a_seleccionar\nFROM tabla_a_consultar\nWHERE columna IS [NOT] NULL ;\nSELECT codigo_empl, nombre_empl\nFROM empleados\nWHERE num_proyec IS NULL;\nSELECT  nombre_columnas_a  seleccionar\nFROM  tabla_a_consultar\nWHERE  columna  operador_comparaci\u00f3n  {ALL|ANY|SOME}subconsulta;\nSELECT codigo_proyec, nombre_proyec\nFROM proyectos\nWHERE precio > ALL (SELECT sueldo\nFROM empleados\nWHERE codigo_proyec = num_proyec);codigo_proyec\n3\ncodigo_empl nombre_empl\n8S e r g i o\nLos predicados ANY/SOME\nPodemos elegir cualquiera  \nde los dos predicados para  \npedir que alguna fila satisfaga una condici\u00f3n.\uf8e9 FUOC \u2022 71Z799014MO 35 El lenguaje SQL\nFij\u00e9monos en la condici\u00f3n de WHERE  de la subconsulta, que nos asegura que los sueldos que \nobservamos son los de los empleados asignados al proyecto de la consulta. La respuesta a esta \nconsulta ser\u00eda la que aparece en el margen.\nb)A continuaci\u00f3n, presentamos un ejemplo de ANY/SOME  para buscar los c\u00f3digos y los nom -\nbres de los proyectos que tienen alg\u00fan empleado  que gana un sueldo m\u00e1s elevado que el pre -\ncio del proyecto en el que trabaja.\nLa respuesta a esta consulta est\u00e1 vac\u00eda, como se ve en el margen.\n6) Predicado EXISTS\nPara comprobar si una su bconsulta produce alguna fila de resultados, pode -\nmos utilizar la sentencia denominada test de existencia : EXISTS . Para compro -\nbar si una subconsulta no produce ninguna fila de resultados, podemos \nutilizar NOT EXISTS .\nEjemplo de uso del predicado EXISTS\nUn ejemplo en el que se buscan los c\u00f3digos y los nombres de los empleados que est\u00e1n asig -\nnados a alg\u00fan proyecto ser\u00eda:\nLa respuesta a esta consulta ser\u00eda la que se muestra en el margen.\n2.5.4. Ordenaci\u00f3n de los datos obte nidos en respuestas a consultas\nSi se desea que, al hacer una consulta , los datos aparezcan en un orden deter -\nminado, es preciso utilizar la cl\u00e1usula ORDER BY  en la sentencia SELECT , que \npresenta el si guiente formato:SELECT codigo_proyec, nombre_proyec\nFROM proyectos\nWHERE precio < ANY (SELECT sueldo\nFROM empleados\nWHERE codigo_proyec = num_proyec);\nSELECT nombre_columnas_a_seleccionar\nFROM tabla_a_consultar\nWHERE [NOT] EXISTS  subconsulta;\nSELECT codigo_empl, nombre_empl\nFROM empleados\nWHERE EXISTS (SELECT *\nFROM proyectos\nWHERE codigo_proyec = num_proyec);\nSELECT nombre_columnas_a seleccionar\nFROM tabla_a_consultarcodigo_proyec nombre_proyec\n1G E S C O M2P E S C I3S A L S A4T I N E L L\ncodigo_proyec nombre_proyec\ncodigo_empl nombre_empl\n1M a r \u00ed a2P e d r o3A n a4J o r g e\n5C l a r a\n6L a u r a7R o g e l i o\uf8e9 FUOC \u2022 71Z799014MO 36 El lenguaje SQL\nConsulta a BDUOC con respuesta ordenada \nImaginemos que queremos consultar los nombre s de los empleados ordenados seg\u00fan el suel -\ndo que ganan, y si ganan el mismo sueldo , ordenados alfab\u00e9ticamente por el nombre:\nEsta consulta dar\u00eda la respuesta siguiente:\nSi no se especifica nada m\u00e1s, se seguir\u00e1 un orden ascendente, pero si se desea \nseguir un orden descende nte es necesario a\u00f1adir DESC  detr\u00e1s de cada factor de \nordenaci\u00f3n expresado en la cl\u00e1usula ORDER BY :\nTambi\u00e9n se puede ex plicitar un orden ascendente poniendo la palabra clave \nASC (opci\u00f3n por defecto).\n2.5.5. Consultas con agrupaci \u00f3n de filas de una tabla\nLas cl\u00e1usulas siguientes, a\u00f1 adidas a la instrucci\u00f3n SELECT FROM , permiten or -\nganizar las filas por grupos:\na)La cl\u00e1usula GROUP BY  nos sirve para agrupar f ilas seg\u00fan las columnas que \nindique esta cl\u00e1usula.[WHERE condiciones]\nORDER BY  columna_seg\u00fan_la_cual_se_quiere_ordenar [DESC]\n[, col_ordenaci\u00f3n [DESC]...];\nSELECT codigo_empl, nombre_empl, apellido_empl, sueldo\nFROM empleados\nORDER BY sueldo, nombre_empl;\ncodigo_empl nombre_empl apellido_empl sueldo\n6 Laura Tort 3,0E+4\n8 Sergio Grau 3,0E+4\n5 Clara Blanc 4,0E+4\n7 Rogelio Salt 4,0E+4\n3 Ana Ros 7,0E+4\n4 Jorge Roca 7,0E+4\n2 Pedro Mas 9,0E+4\n1 Mar\u00eda Puig 1,0E+5\nORDER  BY columna_ordenaci\u00f3n [ DESC] [, columna  [DESC] ...];\uf8e9 FUOC \u2022 71Z799014MO 37 El lenguaje SQL\nb)La cl\u00e1usula HAVING  especifica condiciones de b\u00fasqueda para grupos de \nfilas; lleva a cabo la misma funci\u00f3n que antes cumpl\u00eda la cl\u00e1usula WHERE  para \nlas filas de toda la tabla, pero ahora las condiciones se aplican a los grupos \nobtenidos.\nPresenta el si guiente formato:\nNotemos que en las sentencias SQL se van a\u00f1adiendo cl\u00e1usulas a medida que \nla dificultad o la exigencia de la consulta lo requiere. \nConsulta con agrupaci\u00f3n de filas en BDUOC\nImaginemos que queremos saber el sueldo medio que ganan los empleados de cada de -\npartamento:\nEl resultado de esta consulta ser\u00eda:\nEjemplo de uso de la funci\u00f3n de agregaci\u00f3n SUM \nVeamos un ejemplo de uso de una funci\u00f3n de agregaci\u00f3n SUM del SQL que aparece en la cl\u00e1u -\nsula HAVING  de GROUP BY : \u201cQueremos saber los c\u00f3digos de los proyectos en los que la suma \nde los sueldos de los emplea dos es mayor que 180.000 euros\u201d: \nEl resultado de esta consulta ser\u00eda el que se ve al margen.SELECT nombre_columnas_a seleccionar\nFROM tabla_a_consultar\n[WHERE condiciones]\nGROUP BY  columnas_seg\u00fan_las_cuales_se_quiere_agrupar\n[HAVING condiciones_por_grupos]\n[ORDER  BY columna_ordenaci\u00f3n  [DESC] [, columna [ DESC]...]];\nSELECT nombre_dep, ciudad_dep, AVG(sueldo) AS sueldo_medio\nFROM empleados\nGROUP BY nombre_dep, ciudad_dep;\nnombre_dep ciudad_dep sueldo_medio\nDIR Barcelona 9,0E + 4\nDIR Girona 1,0E + 5\nDIS Lleida 7,0E + 4\nDIS Barcelona 7,0E + 4\nPROG Tarragona 3,3E + 4\nNULL NULL 4,0E + 4\nSELECT num_proyec\nFROM empleados\nGROUP BY num_proyec\nHAVING SUM (sueldo) >1.8E+5;\nFactores de agrupaci\u00f3n\nLos factores de agrupaci\u00f3n  \nde la cl\u00e1usula GROUP BY   \ndeben ser, como m\u00ednimo,  \nlas columnas que figuran  \nen SELECT , exceptuando  \nlas columnas afectadas por funciones de agregaci\u00f3n.\nnum_proyec\n4\nDISTINCT  y GROUP BY\nEn este ejemplo no es necesario \nponer DISTINCT , a pesar de \nque la columna num_proyec  \nno es atributo identificador.  \nFij\u00e9monos en que en la tabla empleados  hemos puesto  \nque todos los proyectos tienen el mismo c\u00f3digo juntos en un mismo grupo y no es posible que aparezcan repetidos.\uf8e9 FUOC \u2022 71Z799014MO 38 El lenguaje SQL\n2.5.6. Consultas a m\u00e1s de una tabla\nMuchas veces queremos consultar datos de m\u00e1s de una tabla haciendo combi -\nnaciones de columnas de tablas diferentes. En el SQL es posible listar m\u00e1s de \nuna tabla que se quiere consultar especific\u00e1ndolo en  la cl\u00e1usula FROM .\n1) Combinaci\u00f3n\nLa combinaci\u00f3n consigue crear una sola tabla a partir de las tablas especifica -\ndas en la cl\u00e1usula FROM , haciendo coincidir los va lores de las columnas rela -\ncionadas de estas tablas.\nEjemplo de combinaci\u00f3n en BDUOC\nA continuaci\u00f3n mostramos un ejemplo con la base de datos BDUOC en el que queremos sa -\nber el NIF del cliente y el c\u00f3digo y el precio del proyecto que desarro llamos para el cliente \nn\u00famero 20:\nEl resultado ser\u00eda:\nSi trabajamos con m\u00e1s de una tabla, puede ocurrir que la tabla resultante tenga \ndos columnas con el mismo nombre. Por ello es obligatorio especificar a qu\u00e9 \ntabla corresponden las columnas a la s que nos estamos refiriendo, denomi -\nnando la tabla a la que pertenecen antes de ponerlas (por ejemplo, clien-\ntes.codigo_cli ). Para simplificarlo, se utilizan los alias que, en  este caso, se \ndefinen en la cl\u00e1usula FROM .\nEjemplo de alias en BDUOC\nc podr\u00eda ser el alias de la tabla clientes . De este modo, para indi car a qu\u00e9 tabla pertenece \ncodigo_cli , s\u00f3lo har\u00eda falta poner: c.codigo_cli.\nVeamos c\u00f3mo quedar\u00eda la consulta anterior ex presada mediante alias, aunque en este ejem -\nplo no ser\u00edan necesarios, porque todas las columnas de las dos tablas tienen nombres dife -\nrentes. Pediremos, ad em\u00e1s, las columnas c.codigo_cli  y p.codigo_cliente.\nEntonces obtendr\u00edamos este resultado:SELECT  proyectos.codigo_proyecto,  proyectos.precio, clientes.nif\nFROM clientes, proyectos\nWHERE  clientes.codigo_cli  = proyectos.codigo_cliente AND  clientes.  \ncodigo_cli  = 20;\nproyectos.codigo_proyecto proyectos.precio clientes.nif\n3 1,0E+6 38.123.898-E\nSELECT  p.codigo_proyecto,  p.precio,  c.nif,  p.codigo_cliente,  c.codigo_cli\nFROM clientes c, proyectos p\nWHERE c.codigo_cli = p.codigo_cliente AND c.codigo_cli = 20;\np.codigo_proyec p.precio c.nif p.codigo_cliente c.codigo_cli\n3 1,0E+6 38.123.898-E 20 20Recordad que la misma operaci\u00f3n \nde combinaci\u00f3n, pero del \u00e1lgebra relacional, se ha visto en el subapartado 5.3.3. de la unidad \u201cEl modelo relacional y el \u00e1lgebra relacional\u201d de este curso.\n\uf8e9 FUOC \u2022 71Z799014MO 39 El lenguaje SQL\nNotemos que en WHERE  necesitamos expresar el v\u00ednculo que se establece entre las dos tablas, \nen este caso codigo_cli  de clientes  y codigo_cliente  de proyectos . Expresado en \noperaciones del \u00e1lgebra relacional, esto signif ica que hacemos una combinaci\u00f3n en lugar de \nun producto cartesiano.\nFij\u00e9monos en que, al igual que en \u00e1lgebra rela cional, la operaci\u00f3n que acabamos de hacer es \nuna equicombinaci\u00f3n ( equi-join ); por lo tanto, nos aparecen dos columnas id\u00e9nticas: c.co-  \ndigo_cli  y p.codigo_cliente .\nLa forma de expresar la combinaci\u00f3n que acabamos de ver pertenece al SQL92 \nintroductorio. Una forma alternativa de realizar la equicombinaci\u00f3n anterior, \nutilizando el SQL92 intermedio o completo, ser\u00eda la siguiente:\nEjemplo anterior con el SQL92 intermedio o completo\nEl ejemplo que hemos expuesto antes utiliza ndo el SQL92 intermedio o completo ser\u00eda:\nY obtendr\u00edamos el mism o resultado de antes.\nLa opci\u00f3n ON, adem\u00e1s de expresar condiciones con la igualdad, en el caso de \nque las columnas que queramos vincular  tengan nombres diferentes, nos ofre -\nce la posibilidad de expresar condicio nes con los dem\u00e1s op eradores de compa -\nraci\u00f3n que no sean el de igualdad. Ser\u00ed a el equivalente a la operaci\u00f3n que en \n\u00e1lgebra relacional hemos denominado \u03b8-combinaci\u00f3n  (\u03b8-join).\nTambi\u00e9n podemos utilizar una misma ta bla dos veces con alias diferentes, \npara distinguirlas.\nDos alias para una misma tabla en BDUOC\nSi pidi\u00e9semos los c\u00f3digos y los apellidos de los empleados que ganan m\u00e1s que el empleado \nque tiene por c\u00f3digo el n\u00famero 5, har\u00edamos lo siguiente:\nHemos tomado la tabla e2 para fijar la fila del empleado con c\u00f3digo n\u00famero 5, de modo que \npodamos comparar el sueldo de la tabla e1, que contiene a todos los empleados, con el suel -\ndo de la tabla e2, que contiene s\u00f3lo al empleado 5.SELECT nombre_columnas_a_seleccionar\nFROM tabla1 JOIN tabla2\n{ON condiciones |USING (columna [, columna...])}\n[WHERE condiciones];\nSELECT p.codigo_proyecto, p.precio, c.nif, p.codigo_cliente, c.codigo_cli\nFROM clientes c JOIN proyectos p ON c.codigo_cli = p.codigo_cliente\nWHERE c.codigo_cli = 20;\nSELECT el.codigo_empl, el.apellido_empl\nFROM empleados el JOIN empleados e2 ON el.sueldo > e2.sueldo\nWHERE e2.codigo_empl = 5;Las operaciones del \u00e1lgebra \nrelacional se han visto en el apartado 5 de la unidad \u201cEl modelo \nrelacional y el \u00e1lgebra relacional\u201d  \nde este curso.\nPod\u00e9is ver la equicombinaci\u00f3n  \ny la \u03b8-combinaci\u00f3n en el \nsubapartado 5.3.3 de la unidad  \n\u201cEl modelo relacional y el \u00e1lgebra relacional\u201d de este curso.\n\uf8e9 FUOC \u2022 71Z799014MO 40 El lenguaje SQL\nLa respuesta a esta consulta ser\u00eda:\n2) Combinaci\u00f3n natural\nLa combinaci\u00f3n natural ( natural join ) de dos tablas consiste b\u00e1sicamente, al \nigual que en el \u00e1lgebra relacional, en  hacer una equicombinaci\u00f3n entre colum -\nnas del mismo nombre y eliminar las columnas repetidas. La combinaci\u00f3n na -\ntural, utilizando el SQL92 intermedio o completo, se har\u00eda de la forma siguiente:\nCombinaci\u00f3n natural en BDUOC\nVeamos a continuaci\u00f3n un ejemplo en el que la s columnas para las que se har\u00eda la combina -\nci\u00f3n natural se denominan igual en las dos tabl as. Ahora queremos saber el c\u00f3digo y el nom -\nbre de los empleados que est\u00e1n asignados al departamento cuyo te l\u00e9fono es 977.33.38.52:\nLa combinaci\u00f3n natural tambi\u00e9n se  podr\u00eda hacer con la cl\u00e1usula USING , s\u00f3lo aplicando la pa -\nlabra reservada JOIN :\nLa respuesta que dar\u00eda ser\u00eda:\n3) Combinaci\u00f3n in terna y externa\nCualquier combinaci\u00f3n puede ser interna o externa:\na)La combinaci\u00f3n interna  (inner join ) s\u00f3lo se queda con las filas que tienen \nvalores id\u00e9nticos en las columnas de la s tablas que compara. Esto puede hacer \nque perdamos alguna fila interesante de alguna de las dos tablas; por ejemplo, e1.codigo_empl e1.apellido_empl\n1 Puig\n2 Mas\n3 Ros\n4 Roca\nSELECT nombre_columnas_a_seleccionar\nFROM tabla1 NATURAL JOIN  tabla2\n[WHERE condiciones];\nSELECT codigo_empl, nombre_empl\nFROM empleados NATURAL JOIN departamentos\nWHERE telefono = '977.333.852 ';\nSELECT codigo_empl, nombre_empl\nFROM empleados JOIN departamentos USING (nombre_dep, ciudad_dep)\nWHERE telefono = '977.333.852 ';\nempleados.codigo_empl empleados.nombre_empl\n5 Clara\n6 Laura\n8 Sergio\uf8e9 FUOC \u2022 71Z799014MO 41 El lenguaje SQL\nporque se encuentra a NULL en el mome nto de hacer la combinaci\u00f3n. Su for -\nmato es el siguiente:\nb)Por ello disponemos de la combinaci\u00f3n externa  (outer join ), que nos per -\nmite obtener todos los valores de la ta bla que hemos puesto a la derecha, los \nde la tabla que hemos puesto a la izquie rda o todos los valores de las dos tablas. \nSu formato es:\nCombinaci\u00f3n natural interna en BDUOC\nSi quisi\u00e9ramos vincular con una combinaci\u00f3n natural interna las tablas empleados  y \ndepartamentos  para saber el c\u00f3digo y el nombre de todos los empleados y el nombre, \nla ciudad y el tel\u00e9fono de todos los departamentos, har\u00edamos:\nY obtendr\u00edamos el siguiente resultado:\nFij\u00e9monos en que en el resultado no aparece el  empleado n\u00famero 7, que no est\u00e1 asignado a \nning\u00fan departamento, ni el de partamento de programaci\u00f3n de  Girona, que no tiene ning\u00fan \nempleado asignado.\nCombinaci\u00f3n natural externa a BDUOC\nEn los ejemplos siguientes veremos c\u00f3mo var\u00edan  los resultados que iremos obteniendo seg\u00fan \nlos tipos de combinaci\u00f3n externa:SELECT nombre_columnas_a_seleccionar\nFROM t1 [NATURAL] [INNER] JOIN t2\n{ON condiciones |\n|USING (columna [,columna...]) }\n[WHERE condiciones];\nSELECT nombre_columnas_a_seleccionar\nFROM t1 [NATURAL] [LEFT |RIGHT |FULL] [OUTER] JOIN t2\n{ON condiciones |\n[USING (columna [,columna...])}\n[WHERE condiciones];\nSELECT e.codigo_empl, e.nombre_empl, e.nombre_dep, e.ciudad_dep, d.telefono\nFROM empleados e NATURAL JOIN departamentos d;\ne.codigo_empl e.nombre_empl e.nombre_dep e.ciudad_dep d.telefono\n1 Mar\u00eda DIR Girona 972.23.89.70\n2 Pedro DIR Barcelona 93.422.60.70\n3 Ana DIS Lleida 973.23.50.40\n4 Jorge DIS Barcelona 93.224.85.23\n5 Clara PROG Tarragona 977.33.38.52\n6 Laura PROG Tarragona 977.33.38.52\n8 Sergio PROG Tarragona 977.33.38.52Combinaci\u00f3n interna\nAunque en el ejemplo estamos \nhaciendo una combinaci\u00f3n  \nnatural interna, no es necesario poner la palabra INNER , ya \nque es la opci\u00f3n por defecto.\uf8e9 FUOC \u2022 71Z799014MO 42 El lenguaje SQL\na)Combinaci\u00f3n externa izquierda\nEl resultado ser\u00eda el que podemos ver a continuaci\u00f3n:\nb)Combinaci\u00f3n externa derecha\nObtendr\u00edamos este resultado:\nc)Combinaci\u00f3n externa plena\nY obtendr\u00edamos el siguiente resultado:SELECT e.codigo_empl, e.nombre_empl, e.nombre_dep, e.ciudad_dep, d.telefono\nFROM empleados e NATURAL LEFT OUTER JOIN departamentos d;\ne.codigo_empl e.nombre_empl e.nombre_dep e.ciudad_dep d.telefono\n1 Mar\u00eda DIR Girona 972.23.89.70\n2 Pedro DIR Barcelona 93.422.60.70\n3 Ana DIS Lleida 973.23.50.40\n4 Jorge DIS Barcelona 93.224.85.23\n5 Clara PROG Tarragona 977.33.38.52\n6 Laura PROG Tarragona 977.33.38.52\n7 Rogelio NULL NULL NULL\n8 Sergio PROG Tarragona 977.33.38.52\nSELECT e.codigo_empl, e.nombre_empl, e.nombre_dep, e.ciudad_dep, d.telefono\nFROM empleados e NATURAL RIGHT OUTER JOIN departamentos d;\ne.codigo_empl e.nombre_empl e.nombre_dep e.ciudad_dep d.telefono\n1 Mar\u00eda DIR Girona 972.23.89.70\n2 Pedro DIR Barcelona 93.422.60.70\n3 Ana DIS Lleida 973.23.50.40\n4 Jorge DIS Barcelona 93.224.85.23\n5 Clara PROG Tarragona 977.33.38.52\n6 Laura PROG Tarragona 977.33.38.52\n8 Sergio PROG Tarragona 977.33.38.52\nNULL NULL PROG Girona 972.23.50.91\nSELECT e.codigo_empl, e.nombre_empl, e.nombre_dep, e.ciudad_dep, \nd.telefono\nFROM empleados e NATURAL FULL OUTER JOIN departamentos d;\ne.codigo_empl e.nombre_empl e.nombre_dep e.ciudad_dep d.telefono\n1 Mar\u00eda DIR Girona 972.23.89.70\n2 Pedro DIR Barcelona 93.422.60.70\n3 Ana DIS Lleida 973.23.50.40Combinaci\u00f3n externa \nizquierda\nAqu\u00ed figura el empleado 7.\nCombinaci\u00f3n externa \nderecha\nAqu\u00ed figura el departamento \nde programaci\u00f3n de Girona.\uf8e9 FUOC \u2022 71Z799014MO 43 El lenguaje SQL\n4) Combinaciones con m\u00e1s de dos tablas\nSi queremos combinar tres tablas o m\u00e1 s con el SQL92 introductorio, s\u00f3lo te -\nnemos que a\u00f1adir todas las tablas en el FROM  y los v\u00ednculos necesarios en el \nWHERE . Si queremos combinarlas con el SQ L92 intermedio o con el completo, \ntenemos que ir haciendo co mbinaciones de tablas por pares, y la tabla resul -\ntante se convertir\u00e1 en el prim er componente del siguiente par.\nCombinaciones con m\u00e1s de dos tablas en BDUOC\nVeamos ejemplos de los dos casos, suponiendo que queremos combinar las tablas emplea-\ndos, proyectos  y clientes :\no bien:\n2.5.7. La uni\u00f3n\nLa cl\u00e1usula UNION  permite unir consultas de dos o m\u00e1s sentencias SELECT\nFROM . Su formato es:\nSi ponemos la opci\u00f3n ALL, aparecer\u00e1n todas las filas obtenidas a causa de \nla uni\u00f3n. No la pondremos si queremos  eliminar las filas repetidas. Lo m\u00e1s e.codigo_empl e.nombre_empl e.nombre_dep e.ciudad_dep d.telefono\n4 Jorge DIS Barcelona 93.224.85.23\n5 Clara PROG Tarragona 977.33.38.52\n6 Laura PROG Tarragona 977.33.38.52\n7 Rogelio NULL NULL NULL\n8 Sergio PROG Tarragona 977.33.38.52\nNULL NULL PROG Girona 972.23.50.91\nSELECT *\nFROM empleados, proyectos, clientes\nWHERE num_proyec = codigo_proyec AND codigo_cliente = codigo_cli;\nSELECT *\nFROM (empleados JOIN proyectos ON num_proyec = codigo_proyec)\nJOIN clientes ON codigo_cliente = codigo_cli;\nSELECT columnas\nFROM tabla\n[WHERE condiciones]\nUNION [ALL]\nSELECT columnas\nFROM tabla\n[WHERE condiciones];Combinaci\u00f3n externa \nplena\nAqu\u00ed figura el empleado 7  \ny el departamento  \nde programaci\u00f3n de Girona.\uf8e9 FUOC \u2022 71Z799014MO 44 El lenguaje SQL\nimportante de la uni\u00f3n es que somo s nosotros quienes tenemos que procu -\nrar que se efect\u00fae entre columnas defi nidas sobre dominios compatibles; es \ndecir, que tengan la misma interpre taci\u00f3n sem\u00e1ntica. Como ya hemos co -\nmentado, el SQL92 no nos ofrece herra mientas para asegurar la compatibi -\nlidad sem\u00e1ntica entre columnas. \nUtilizaci\u00f3n de la uni\u00f3n en BDUOC\nSi queremos saber todas las ciudades que hay en nuestra base de da tos, podr\u00edamos hacer:\nEl resultado de esta consulta se r\u00eda el que se muestra al margen.\n2.5.8. La intersecci\u00f3n\nPara hacer la intersecci\u00f3n entre dos o m\u00e1s sentencias SELECT FROM , podemos \nutilizar la cl\u00e1usula  INTERSECT , cuyo formato es:\nSi indicamos la opci\u00f3n ALL, aparecer\u00e1n todas las filas obtenidas a partir de la \nintersecci\u00f3n. No la pondremos si quer emos eliminar las filas repetidas. \nLo m\u00e1s importante de la intersecci\u00f3n es que somos nosotros quienes tenemos \nque vigilar que se haga entre columnas definidas sobre dominios compatibles; \nes decir, que tengan la misma interpretaci\u00f3n sem\u00e1ntica.\nUtilizaci\u00f3n de la intersecci\u00f3n en BDUOC\nSi queremos saber todas las ciudades donde tenemos departamentos en los que podamos en -\ncontrar alg\u00fan cliente, podr\u00edamos hacer:\nEl resultado de esta consulta se r\u00eda el que se muestra al margen.SELECT ciudad\nFROM clientes\nUNION\nSELECT ciudad_dep\nFROM departamentos;\nSELECT columnas\nFROM tabla\n[WHERE condiciones]\nINTERSECT  [ALL]\nSELECT columnas\nFROM tabla\n[WHERE condiciones];\nSELECT ciudad\nFROM clientes\nINTERSECT\nSELECT ciudad_dep\nFROM departamentos;\nciudad\nBarcelona\nGirona\nLleida\nTarragona\nciudad\nBarcelona\nGirona\nLleida\nTarragona\uf8e9 FUOC \u2022 71Z799014MO 45 El lenguaje SQL\nSin embargo, la intersecci\u00f3n es una de  las operaciones del SQL que se puede \nhacer de m\u00e1s formas diferentes. Tambi\u00e9 n podr\u00edamos encontrar la intersecci\u00f3n \ncon IN o EXISTS : \na)Intersecci\u00f3n utilizando IN\nb)Intersecci\u00f3n utilizando EXISTS\nEjemplo anterior expresado con IN y con EXISTS\nEl ejemplo que hemos propuesto antes se podr\u00eda expresar con IN:\no tambi\u00e9n con EXISTS :\n2.5.9. La diferencia\nPara encontrar la diferencia entre dos o m\u00e1s sentencias SELECT FROM  podemos \nutilizar la cl\u00e1usula  EXCEPT , que tiene este formato:SELECT columnas\nFROM tabla\nWHERE columna IN (SELECT columna\nFROM tabla\n[WHERE condiciones]);\nSELECT columnas\nFROM tabla\nWHERE EXISTS  (SELECT *\nFROM tabla\nWHERE condiciones);\nSELECT c.ciudad\nFROM clientes c\nWHERE c.ciudad IN (SELECT d.ciudad_dep\nFROM departamentos d);\nSELECT c.ciudad\nFROM clientes c\nWHERE EXISTS (SELECT *\nFROM departamentos d\nWHERE c.ciudad = d.ciudad_dep;\nSELECT columnas\nFROM tabla\n\uf8e9 FUOC \u2022 71Z799014MO 46 El lenguaje SQL\nSi ponemos la opci\u00f3n ALL aparecer\u00e1n todas las filas qu e da la diferencia. No la \npondremos si queremos elim inar las filas repetidas.\nLo m\u00e1s importante de la diferencia es  que somos nosotros quienes tenemos que \nvigilar que se haga entre columnas definidas sobre dominios compatibles. \nUtilizaci\u00f3n de la diferencia en BDUOC\nSi queremos saber los clientes que no nos ha n contratado ning\u00fan proyecto, podr\u00edamos hacer:\nEl resultado de esta consulta ser\u00eda el que se ve en el margen.\nLa diferencia es, junto con la interse cci\u00f3n, una de las operaciones del SQL que \nse puede realizar de m\u00e1s formas dife rentes. Tambi\u00e9n podr\u00edamos encontrar la \ndiferencia utilizando NOT IN  o NOT EXISTS : \na)Diferencia utilizando NOT IN :\nb)Diferencia utilizando NOT EXISTS :[WHERE condiciones]\nEXCEPT [ALL]\nSELECT columnas\nFROM tabla\n[WHERE condiciones];\nSELECT codigo_cli\nFROM clientes\nEXCEPT\nSELECT codigo_cliente\nFROM proyectos;\nSELECT columnas\nFROM tabla\nWHERE columna NOT IN (SELECT columna\nFROM tabla\n[WHERE condiciones]);\nSELECT columnas\nFROM tabla\nWHERE NOT EXISTS  (SELECT *\nFROM tabla\nWHERE condiciones);\ncodigo_cli\n40\n\uf8e9 FUOC \u2022 71Z799014MO 47 El lenguaje SQL\nEjemplo anterior expresado con NOT IN  y con NOT EXISTS\nEl ejemplo que hemos hecho antes se podr\u00eda expresar con NOT IN :\no tambi\u00e9n con NOT EXISTSSELECT c.codigo_cli\nFROM clientes c\nWHERE c.codigo_cli NOT IN (SELECT p.codigo_cliente\nFROM proyectos p);\nSELECT c.codigo_cli\nFROM clientes c\nWHERE NOT EXISTS (SELECT *\nFROM proyectos p\nWHERE c.codigo_cli = p.codigo_cliente);\uf8e9 FUOC \u2022 71Z799014MO 48 El lenguaje SQL\n3. Sentencias de control\nAdem\u00e1s de definir y manipular una base de datos relacional, es importante que \nse establezcan mecanismos de control  para resolver problemas de concurrencia \nde usuarios y garantizar la seguridad de los datos. Para la concurrencia de usuarios \nutilizaremos el concepto de transacci\u00f3n , y para la seguridad veremos c\u00f3mo se pue -\nde autorizar y desautorizar a usuarios a acceder a la base de datos.\n3.1. Las transacciones\nLa mayor\u00eda de las transacciones se inicia n de forma impl\u00edcita al utilizar alguna \nsentencia que empieza con CREATE , ALTER , DROP , SET, DECLARE , GRANT  o \nREVOKE , aunque existe la sentencia SQL para iniciar transacciones , que es la \nsiguiente:\nSi queremos actualizar la base de datos utilizaremos la opci\u00f3n READ WRITE , y \nsi no la queremos actualiz ar, elegiremos la opci\u00f3n READ ONLY .\nSin embargo, en cambio, una transacci\u00f3n siempre debe acabar expl\u00edcitamente \ncon alguna de las se ntencias siguientes:\nLa diferencia entre COMMIT  y ROLLBACK  es que mientras la sentencia COMMIT\nconfirma todos los cambios producidos co ntra la BD durante la ejecuci\u00f3n de \nla transacci\u00f3n, la sentencia ROLLBACK  deshace todos los cambios que se hayan \nproducido en la base de datos y la deja como estaba antes del inicio de nuestra \ntransacci\u00f3n.\nLa palabra reservada WORK  s\u00f3lo sirve para aclarar lo que hace la sentencia, y es \ntotalmente opcional.Una transacci\u00f3n es una unidad l\u00f3gica  de trabajo. O informalmente, y \ntrabajando con SQL, un conjunto de sentencias que se ejecutan como si fuesen una sola. En general, las sentencias que form an parte de una \ntransacci\u00f3n se interrelacionan entre s\u00ed, y no tiene sentido que se ejecute \nuna sin que se ejecuten las dem\u00e1s.\nSET TRANSACTION  {READ ONLY |READ WRITE };\n{COMMIT |ROLLBACK } [WORK];\uf8e9 FUOC \u2022 71Z799014MO 49 El lenguaje SQL\nEjemplo de transacci\u00f3n\nA continuaci\u00f3n proponemos un ejemplo de transa cci\u00f3n en el que se quiere disminuir el suel -\ndo de los empleados que han trabajado en el proy ecto 3 en 1.000 euros. y aumentar el sueldo \nde los empleados que han trabajado en el proyecto 1 tambi\u00e9n en 1.000 euros.\n3.2. Las autorizaciones y desautorizaciones\nTodos los privilegios sobre la base de dato s los tiene su propietario, pero no es \nel \u00fanico que accede a \u00e9sta. Por este moti vo, el SQL nos ofrece sentencias para \nautorizar y desautoriz ar a otros usuarios.\n1) Autori zaciones\nPara autorizar, el SQL dispon e de la siguiente sentencia:\nDonde tenemos que:\na)privilegios  puede ser:\n\u2022ALL PRIVILEGES : todos los privilegios sobr e el objeto especificado.\n\u2022USAGE : utilizaci\u00f3n del objeto especifi cado; en este caso el dominio.\n\u2022SELECT : consultas.\n\u2022INSERT  [(columnas )]: inserciones. Se pu ede concretar de qu\u00e9 columnas .\n\u2022UPDATE  [(columnas )]: modificaciones. Se puede concretar de qu\u00e9 columnas .\n\u2022DELETE : borrados.\n\u2022REFERENCES  [(columna )]: referencia del objeto en restricciones de integri -\ndad. Se puede concretar de qu\u00e9 columnas .\nb)Objeto  debe ser:\n\u2022DOMAIN : dominioSET TRANSACTION READ WRITE;\nUPDATE empleados SET sueldo = sueldo \u2013 1000 WHERE num_proyec = 3;\nUPDATE empleados SET sueldo = sueldo + 1000 WHERE num_proyec = 1;\nCOMMIT;\nGRANT privilegios ON objeto TO usuarios\n[WITH GRANT OPTION ];\uf8e9 FUOC \u2022 71Z799014MO 50 El lenguaje SQL\n\u2022TABLE : tabla.\n\u2022Vista .\nc) Usuarios  puede ser todo el mundo: PUBLIC , o bien una lista de los identi -\nficadores de los usuarios  que queremos autorizar.\nd)La opci\u00f3n WITH GRANT OPTION  permite que el usuario que autoricemos \npueda, a su vez, autorizar a otros usuarios a acceder al objeto con los mismos privilegios con los que ha sido autorizado.\n2) Desautorizaciones\nPara desautorizar, el SQL disp one de la siguiente sentencia:\nDonde tenemos que:\na)privilegios , objeto  y usuarios  son los mismos que para la sentencia \nGRANT .\nb)La opci\u00f3n GRANT OPTION FOR  se utilizar\u00eda en el ca so de que quisi\u00e9ramos \neliminar el derecho a autorizar ( WITH GRANT OPTION ).\nc)Si un usuario al que hemos autorizado ha autorizado a su vez a otros, que \nal mismo tiempo pueden haber hecho m\u00e1s autorizaciones, la opci\u00f3n CASCADE\nhace que queden desautor izados todos a la vez.\nd)La opci\u00f3n  RESTRICT  no nos permite desautorizar a un usuario si \u00e9ste ha \nautorizado a otros.REVOKE [GRANT OPTION FOR] privilegios ON objeto FROM\nusuarios [ RESTRICT |CASCADE];\uf8e9 FUOC \u2022 71Z799014MO 51 El lenguaje SQL\n4. Sublenguajes especializados\nMuchas veces querremos acceder a la base de datos desde una aplicaci\u00f3n he -\ncha en un lenguaje de programaci\u00f3n cu alquiera. Para utilizar el SQL desde un \nlenguaje de programaci \u00f3n, podemos utilizar el SQL hospedado , y para traba -\njar con \u00e9ste necesitamos un precompila dor que separe las sentencias del len -\nguaje de programaci\u00f3n de las del lenguaje de bases de datos. Una alternativa \nmuy interesante a esta forma de trabajar son las  rutinas SQL/CLI .\nEl objetivo de este apartado no es explicar con detalle ni el SQL hospedado ni, \na\u00fan menos, las rutina s SQL/CLI. S\u00f3lo introducirem os las ideas b\u00e1sicas del fun -\ncionamiento de ambos. \n4.1. SQL hospedado\nPara crear y manipular una base de dato s relacional necesi tamos SQL. Adem\u00e1s, \nsi la tarea que queremos hacer requiere el poder de  procesamiento de un len -\nguaje de programaci\u00f3n como Java, C, Cobol, Fortran, Pa scal, etc., podemos \nutilizar el SQL hospedado en  el lenguaje de programa ci\u00f3n elegido. De este mo -\ndo, podemos utilizar las sentencias del SQL dentro de nuestras aplicaciones, \nponiendo siempre delante la palabra reservada EXEC SQL* . \nPara poder compilar la mezcla de llama das de SQL y sentencias de programa -\nci\u00f3n, antes tenemos que utilizar un precompilador. Un precompilador  es una \nherramienta que separa la s sentencias del SQL y la s sentencias de programa -\nci\u00f3n. All\u00e1 donde en el programa fuente haya una sentencia de acceso a la base \nde datos, se debe insertar una llamada a la interfaz del SGBD. El programa fuente \nresultante de la precompilaci\u00f3n ya est\u00e1 \u00fanicamente en el lenguaje de programa -\nci\u00f3n, preparado para ser comp ilado, montado y ejecutado.\nEn la figura que encontrar\u00e9is en la p\u00e1gina siguiente pod\u00e9is observar este \nfuncionamiento.\nTodas las sentencias de definici\u00f3n, ma nipulaci\u00f3n y control que hemos visto \npara el SQL se pueden utilizar en el SQ L hospedado, pero pr ecedidas de la cl\u00e1u -\nsula EXEC SQL . S\u00f3lo habr\u00e1 una excepci\u00f3n: cuando el resultado de una senten -\ncia SQL obtenga m\u00e1s de una fila o haga  referencia tambi\u00e9 n a m\u00e1s de una, \ndeberemos trabajar con el concepto de cursor .\nUn cursor se tiene que haber declarado antes de su utilizaci\u00f3n ( EXEC  SQL\nDECLARE  nombre_cursor  CURSOR  FOR). Para utilizarlo, se debe abrir ( EXEC \nSQL OPEN nombre_cursor ), ir tomando los datos uno a uno, tratarlos \n* Puede haber peque\u00f1as diferencias \ndependiendo del lenguaje\nde programaci\u00f3n concreto \nque estemos considerando.\uf8e9 FUOC \u2022 71Z799014MO 52 El lenguaje SQL\n(EXEC SQL FETCH nombre_cursor INTO ), y finalmente, cerrarlo ( EXEC \nSQL CLOSE nombre_cursor ).\n4.2. Las SQL/CLI\nLas SQL/CLI ( SQL/Call-Level Interface ), denominadas de forma abreviada CLI, \npermiten que aplicaciones desarrollada s en un cierto lenguaje de programa -\nci\u00f3n (con s\u00f3lo las herramientas disponib les para este lenguaje y sin el uso de \nun precompilador) puedan incluir sent encias SQL mediante llamadas a libre -\nr\u00edas. Estas sentencias SQL se deben interpretar en tiempo de ejecuci\u00f3n del \nprograma, a diferencia del SQL hospedad o, que requer\u00eda el uso de un pre -\ncompilador. \nLa interfaz ODBC  (Open Database Connectivity ) define una librer\u00eda de funciones \nque permite a las aplicacion es acceder al SGBD utilizando el SQL. Las rutinas \nSQL/CLI est\u00e1n fuertemente basadas en las caracter\u00edsticas de la interfaz ODBC, \ny gracias al trabajo desarrollado por SAG-X/Open ( SQL Access Group-X/Open ), \nfueron a\u00f1adidas al est\u00e1ndar ANSI/ISO SQL92 en 1995.\nLas SQL/CLI son simplement e rutinas que llaman al SG BD para interpretar las \nsentencias SQL que pide la  aplicaci\u00f3n. Desde el punt o de vista del SGBD, las \nSQL/CLI se pueden considerar, simp lemente, como otras aplicaciones. \n\uf8e9 FUOC \u2022 71Z799014MO 53 El lenguaje SQL\nResumen\nEn esta unidad hemos pres entado las sentencias m\u00e1s utilizadas del lenguaje es -\nt\u00e1ndar ANSI/ISO SQL92 de definici\u00f3n, ma nipulaci\u00f3n y control de bases de da -\ntos relacionales. Como ya hemos comentad o en la introducci\u00f3n, el SQL es un \nlenguaje muy potente, y esto hace que existan m\u00e1s sentencias y opciones de \nlas que hemos explicado en este m\u00f3dulo. Sin embargo, no es menos cierto que \nhemos visto m\u00e1s sentencias que las que algunos sistemas relacionales ofrecen \nactualmente. Hemos intentado seguir co n la mayor fidelidad el est\u00e1ndar, in -\ncluyendo comentarios s\u00f3lo cuando en la  mayor\u00eda de los sistemas relacionales \ncomerciales alguna operaci\u00f3n se hac\u00eda de forma distinta.\nConociendo el SQL92 podemos trabajar con cualquier sistema relacional co -\nmercial; s\u00f3lo tendremos qu e dedicar unas cuantas horas a ver qu\u00e9 variaciones \nse dan con respecto al est\u00e1ndar.\nRecordemos c\u00f3mo ser\u00e1 la creaci\u00f3n de una base de datos con SQL :\n1)En primer lugar, tendremos que dar nomb re a la base de datos, con la sen -\ntencia CREATE DATABASE , si la hay, o con CREATE SCHEMA .\n2)A continuaci\u00f3n definiremos las tablas , los dominios, las aserciones y las \nvistas que formar\u00e1n nuestra base de datos.\n3)Una vez definidas las tablas, que estar\u00e1n completamente vac\u00edas, se deber\u00e1n \nllenar con la sentencia INSERT  INTO .\nCuando la base de datos tenga un conjun to de filas, la podremos manipular, \nya sea actualizando  filas o bien haci\u00e9ndo consultas.\nAdem\u00e1s, podemos usar todas las senten cias de control qu e hemos explicado.\uf8e9 FUOC \u2022 71Z799014MO 55 El lenguaje SQL\nActividad\n1.Seguro que siempre hab\u00e9is querido saber d\u00f3nde ten\u00edais aquella pel\u00edcula de v\u00eddeo que nunca \nencontrabais. Por ello os proponemos crear una ba se de datos para organi zar las cintas de v\u00eddeo \ny localizarlas r\u00e1pidamente cuando os apetezca utilizarlas. Tendr\u00e9is  que crear la base de datos y \nlas tablas; tambi\u00e9n deber\u00e9 is decidir las claves primarias e insertar filas.\nPara almacenar las cintas de v\u00eddeo, tendremos que crear las siguientes tablas:\na)Las cintas: querremos saber su c\u00f3digo, la esta nter\u00eda donde se encuentran, el estante y la \nfila, suponiendo que en un estante haya m\u00e1s de una fila. Tendremos que poner nosotros el c\u00f3digo de las cintas, con un rotulador, en el lomo de cada una.\nb)Las pel\u00edculas: querremos saber su c\u00f3digo, t\u00edtulo , director principal (en el caso de que haya \nm\u00e1s de uno) y el tema. El c\u00f3digo de las pel\u00edculas tambi\u00e9n lo tendremos que escribir nosotros con un rotulador para distinguir pe l\u00edculas que tienen el mismo nombre.\nc)Los actores: s\u00f3lo querremos saber de ellos un c\u00f3digo, el nombre y el apellido y, si somos \naficionados al cine, otros datos que nos pueda interesar almacenar. El c\u00f3digo de los actores, que inventaremos nosotros, nos permitir\u00e1 dist inguir entre actores que se llaman igual.\nd)Pel\u00edculas que hay en cada cinta:  en esta tabla pondremos el c\u00f3 digo de la cinta y el c\u00f3digo \nde la pel\u00edcula. En una cinta puede haber m\u00e1s de una pel\u00edcula, y podemos tener una pel\u00edcula \nrepetida en m\u00e1s de una cinta; se debe tener en cuenta este hecho en el momento de elegir la \nclave primaria.\ne)Actores que aparecen en las pel\u00edculas: en esta  tabla indicaremos el c\u00f3digo de la pel\u00edcula \ny el c\u00f3digo del actor. En una pel\u00edcula puede participar m\u00e1s de un actor y un actor puede \naparecer en m\u00e1s de una pel\u00edcula; hay que tener presente este hecho cuando se elige la clave \nprimaria.\nEsperamos que, adem\u00e1s de prac ticar sentencias de definici\u00f3n, manipulaci\u00f3n y control del \nSQL, esta actividad os resulte muy \u00fatil.\nEjercicios de autoevaluaci\u00f3n\nCon la actividad anterior hemos practicado sentencias de definici\u00f3n y control del SQL. Me -\ndiante las sentencias de manipulaci\u00f3n hemos insertado filas y, si nos hubi\u00e9semos equivocado, tambi\u00e9n habr\u00edamos borrado y modi ficado alguna fila. Con los ejercicios de autoevaluaci\u00f3n \npracticaremos la parte de sentencias de manipu laci\u00f3n que no hemos tratado todav\u00eda: las con\n-\nsultas. Los ejercicios que propon emos se har\u00e1n sobre la base de datos relacional BDUOC que \nha ido apareciendo a lo largo de esta unidad.\n1.Obtened los c\u00f3digos y los nombres y apellidos  de los empleados, ordenados alfab\u00e9tica -\nmente de forma descendente por apellido y, en caso de repeticiones, por nombre.\n2.Consultad el c\u00f3digo y el nombre de los proy ectos de los clientes que son de Barcelona.\n3.Obtened los nombres y las ciudades de los de partamentos que trabajan en los proyectos \nn\u00famero 3 y n\u00famero 4.\n4.De todos los empleados que perciben un sueldo  de entre 50.000 y 80 .000 euros, buscad \nlos c\u00f3digos de empleado y los nombres de los proyectos que tienen asignados.\n5.Buscad el nombre, la ciudad y el tel\u00e9fono  de los departamentos donde trabajan los em -\npleados del proyecto GESCOM.\n6.Obtened los c\u00f3digos y los nombres y apellidos de los empleados que trabajan en los pro -\nyectos de precio m\u00e1s alto. \n7.Averiguad cu\u00e1l es el sueldo m\u00e1s alto de cada departamento. Concretamente, es necesario \ndar el nombre y la ciudad del depa rtamento y el sueldo m\u00e1s elevado.\n8.Obtened los c\u00f3digos y los nombres de los clientes que tienen m\u00e1s de un proyecto contratado.\n9.Averiguad los c\u00f3digos y los nombres de los proyectos cuyos empleados asignados tienen \nun sueldo superior a 30.000 euros.\n10.Buscad los nombres y las ciudades de los de partamentos que no tienen ning\u00fan empleado \nasignado.\uf8e9 FUOC \u2022 71Z799014MO 56 El lenguaje SQL\nSolucionario\nEjercicios de autoevaluaci\u00f3n\n1.\n2.Con el SQL92 introductorio, la soluci\u00f3n ser\u00eda:\nCon el SQL92 intermedio o con el completo, la soluci\u00f3n ser\u00eda:\n3. \n4.Con el SQL92 introductorio, la soluci\u00f3n ser\u00eda:\nCon el SQL92 intermedio o con el completo, la soluci\u00f3n ser\u00eda:\n5.Con el SQL92 introductorio, la soluci\u00f3n ser\u00eda:\nCon el SQL92 intermedio o con el completo, la soluci\u00f3n ser\u00eda:SELECT apellido_empl, nombre_empl, codigo_empl\nFROM empleados\nORDER BY apellido_empl DESC, nombre_empl DESC;\nSELECT p.codigo_proyec, p.nombre_proyec\nFROM proyectos p, clientes c\nWHERE c.ciudad = \u2018Barcelona\u2019 and c.codigo_cli = p.codigo_cliente;\nSELECT p.codigo_proyec, p.nombre_proyec\nFROM proyectos p JOIN clientes c ON c.codigo_cli = p.codigo_cliente\nWHERE c.ciudad = \u2018Barcelona\u2019;\nSELECT DISTINCT e.nombre_dep, e.ciudad_dep\nFROM empleados e\nWHERE e.num_proyec IN (3,4);\nSELECT e.codigo_empl, p.nombre_proyec\nFROM empleados e, proyectos p\nWHERE e.sueldo BETWEEN 5.0E+4 AND 8.0E+4 and e. num_proyec = p.codigo_proyec;\nSELECT e.codigo_empl, p.nombre_proyec\nFROM empleados e JOIN proyectos p ON e.num_proyec = p.codigo_proyec\nWHERE e.sueldo BETWEEN 5.0E+4 AND 8.0E+4;\nSELECT DISTINCT d.*\nFROM departamentos d, empleados e, proyectos p\nWHERE p. nombre_proyec = \u2018GESCOM\u2019 and d.nombre_dep = e.nombre_dep AND\nd.ciudad_dep = e.ciudad_dep and e. num_proyec = p.codigo_proyec;\nSELECT DISTINCT d.nombre_dep, d.ciudad_dep, d.telefono\nFROM  (departamentos  dNATURAL  JOIN  empleados e)  JOIN  proyectos p  ON e.num_proyec  = p.codigo_proyec\nWHERE p.nombre_proyec = \u2018GESCOM\u2019;\uf8e9 FUOC \u2022 71Z799014MO 57 El lenguaje SQL\n6.Con el SQL92 introductorio, la soluci\u00f3n ser\u00eda:\nCon el SQL92 intermedio o con el completo, la soluci\u00f3n ser\u00eda:\n7.\n8.Con el SQL92 introductorio, la soluci\u00f3n ser\u00eda:\nCon el SQL92 intermedio o con el completo, la soluci\u00f3n ser\u00eda:\n9.Con el SQL92 introductorio, la soluci\u00f3n ser\u00eda:\nCon el SQL92 intermedio o con el completo, la soluci\u00f3n ser\u00eda:\n10.SELECT e.codigo_empl, e.nombre_empl, e.apellido_empl\nFROM proyectos p, empleados e\nWHERE e.num_proyec = p.codigo_proyec and p.precio = (SELECT MAX(p1. precio)\nFROM proyectos p1);\nSELECT e.codigo_empl, e.nombre_empl, e.apellido_empl\nFROM empleados e JOIN proyectos p ON e.num_proyec = p.codigo_proyec\nWHERE p.precio = (SELECT MAX(p1.pr ecio)\nFROM proyectos p1);\nSELECT nombre_dep, ciudad_dep, MAX(sueldo) AS sueldo_maximo\nFROM empleados\nGROUP BY nombre_dep, ciudad_dep;\nSELECT c.codigo_cli, c.nombre_cli\nFROM proyectos p, clientes c\nWHERE c.codigo_cli = p.codigo_cliente\nGROUP BY c.codigo_cli, c.nombre_cli\nHAVING COUNT(*) > 1;\nSELECT c.codigo_cli, c.nombre_cli\nFROM proyectos p JOIN clientes c ON c.codigo_cliente = p.codigo_cliente\nGROUP BY c.codigo_cli, c.nombre cli\nHAVING COUNT(*) > 1;\nSELECT p.codigo_proyec, p.nombre_proyec\nFROM proyectos p, empleados e\nWHERE e.num_proyec = p.codigo_proyec\nGROUP BY p.codigo_proyec, p.nombre_proyec\nHAVING MIN(e.sueldo) > 3.0E+4;\nSELECT p.codigo_proyec, p.nombre_proyec\nFROM empleados e JOIN proyectos p ON e.num_proyec = p.codigo_proyec\nGROUP BY p.codigo_proyec, p.nombre_proyec\nHAVING MIN(e.sueldo)>3.0E+4;\nSELECT d.nombre_dep, d.ciudad_dep\nFROM departamentos d\nWHERE NOT EXISTS (SELECT *\nFROM empleados e\nWHERE e.nombre_dep = d.nombre_dep AND\ne.ciudad_dep = d.ciudad_dep);\uf8e9 FUOC \u2022 71Z799014MO 58 El lenguaje SQL\no bien:\nBibliograf\u00eda\nBibliograf\u00eda b\u00e1sica\nEl SQL92 se define, seg\u00fan lo busqu\u00e9is en ISO o en ANSI, en cualquiera de los dos documentos \nsiguientes:\nDatabase Language SQL  (1992). Document ISO/IEC 9075:1992. International Organization \nfor Standardization (ISO).\nDatabase Language SQL  (1992). Document ANSI/X3.135-1992. American National Standards \nInstitute (ANSI).\nDate, C.J.; Darwen, H.  (1997). A guide to the SQL Standard (4.a ed.). Reading, Massachusetts: \nAddison-Wesley.\nLos libros que contienen la descripci\u00f3n del est\u00e1 ndar ANSI/ISO SQL92 son bastante gruesos y \npesados de leer. Este libro constituye un resumen del oficial.\nDate, C.J. (2001). Introducci\u00f3n a los sistemas de bases de datos  (7\u00aa edici\u00f3n). Prentice Hall.\nTen\u00e9is todav\u00eda una versi\u00f3n m\u00e1s re sumida de uno de los mismos au tores del libro anterior en el \ncap\u00edtulo 4 de este libro. Adem\u00e1s  en el ap\u00e9ndice B pod\u00e9is en contrar una panor\u00e1mica de SQL3.\nOtros libros traducidos al castellano del SQ L92 que os recomendamos son los siguientes:\nGroff, J.R.; Weinberg, P.N.  (1998). LAN Times. Gu\u00eda de SQL . Osborne: McGraw-Hill.\nOs recomendamos la consulta de este libro por  su claridad y por los comentarios sobre el \nmodo en el que se utiliza el est\u00e1ndar en los diferentes sistemas relacionales comerciales.\nSilberschatz, A.; Korth, H.F.; Sudarshan, S. (1998). Fundamentos de bases de datos . (3.a ed.). \nMadrid: McGraw-Hill.\nPod\u00e9is encontrar una lectura r\u00e1pida, resumida, pe ro bastante completa del SQL en el cap\u00edtulo \n4 de este libro.\nPor \u00faltimo, para profundizar en  el estudio de SQL:1999 reco mendamos el siguiente libro:\nMelton, J.; Simon, A.R.  (2001). SQL:1999.  Undestandign Relational Language Components . \nMorgan Kaufmann.SELECT nombre_dep, ciudad_dep\nFROM departamentos \nEXCEPT\nSELECT nombre_dep, ciudad_dep\nFROM empleados;\uf8e9 FUOC \u2022 71Z799014MO 59 El lenguaje SQL\nAnexos\nAnexo 1\nSentencias de definici\u00f3n\n1)Creaci\u00f3n de esquemas:\n2)Borrado de esquemas:\n3)Creaci\u00f3n de base de datos:\n4)Borrado de bases de datos:\n5)Creaci\u00f3n de tablas\nDonde tenemos lo siguiente:\n\u2022definici\u00f3n_columna  es:\n\u2022 Una de las restricciones de la tabla era la definici\u00f3n de claves for\u00e1neas:CREATE SCHEMA  {nombre_esquema | AUTHORIZATION  usuario}\n[lista_de_elementos_del_esquema];\nDROP SCHEMA  nombre_esquema { RESTRICT |CASCADE};\nCREATE DATABASE  nombre_base_de_datos;\nDROP DATABASE  nombre_base_de_datos;\nCREATE TABLE  nombre_tabla\n(definici\u00f3n_columna\n[, definici\u00f3n_columna...]\n[, restricciones_tabla]\n);\nnombre_columna  {tipos_datos |dominio}  [def_defecto]  [restric_col]\nFOREIGN KEY clave_foranea REFERENCES  tabla [(clave_primaria)]\n[ON DELETE {NO ACTION |CASCADE |SET DEFAULT |SET NULL }]\n[ON UPDATE  {NO ACTION |CASCADE |SET DEFAULT |SET NULL }]\uf8e9 FUOC \u2022 71Z799014MO 60 El lenguaje SQL\n6)Modificaci\u00f3n de una tabla:\nDonde tenemos lo siguiente:\n\u2022acci\u00f3n_modificar_columna  puede ser:\n\u2022acci\u00f3n_modif_restriccion_tabla  puede ser:\n7)Borrado de tablas:\n8)Creaci\u00f3n de dominios:\nDonde tenemos lo siguiente:\n\u2022def_defecto  tiene el siguiente formato:\n\u2022restricciones_dominio  tiene el siguiente formato:\n9)Modificaci\u00f3n de un dominio sem\u00e1ntico:ALTER TABLE  nombre_tabla {acci\u00f3n_modificar_columna |\nacci\u00f3n_modif_restricci\u00f3n_tabla};\n{ADD [COLUMN] columna def_columna |\nALTER [COLUMN] columna { SET def_defecto |DROP DEFAULT }|\nDROP [COLUMN] columna { RESTRICT |CASCADE}}\n{ADD restricci\u00f3n |\nDROP CONSTRAINT  restricci\u00f3n { RESTRICT |CASCADE}}\nDROP TABLE  nombre_tabla { RESTRICT |CASCADE};\nCREATE DOMAIN  nombre_dominio [ AS] tipo_datos\n[def_defecto] [restricciones_dominio];\nDEFAULT {literal |funci\u00f3n |NULL}\n[CONSTRAINT  nombre_restriccion] CHECK (condiciones)\nALTER DOMAIN  nombre_dominio {acci\u00f3n_modificar_dominio |\nacci\u00f3n_modif_restricci\u00f3n_dominio };\uf8e9 FUOC \u2022 71Z799014MO 61 El lenguaje SQL\nDonde tenemos lo siguiente:\n\u2022acci\u00f3n_modificar_dominio  puede ser:\n\u2022acci\u00f3n_modif_restricci\u00f3n_dominio  puede ser:\n10) Borrado de dominios creados por el usuario:\n11) Definici\u00f3n de una aserci\u00f3n:\n12) Borrado de una aserci\u00f3n:\n13) Creaci\u00f3n de una vista:\n14) Borrado de una vista:\nAnexo 2\nSentencias de manipulaci\u00f3n\n1)Inserci\u00f3n de filas en una tabla:{SET def_defecto |DROP DEFAULT}\n{ADD  restricciones_dominio |DROP  CONSTRAINT  nombre_restricci\u00f3n}\nDROP DOMAIN  nombre_dominio { RESTRICT |CASCADE};\nCREATE ASSERTION  nombre_aserci\u00f3n CHECK (condiciones);\nDROP ASSERTION  nombre_aserci\u00f3n;\nCREATE VIEW  nombre_vista [(lista_columnas)] AS (consulta)\n[WITH CHECK OPTION ];\nDROP VIEW  nombre_vista { RESTRICT |CASCADE};\nINSERT INTO  nombre_tabla [(columnas)]\n{VALUES  ({v1 |DEFAULT |NULL},  ...,  {{vn |DEFAULT |NULL}) |<consulta>};\uf8e9 FUOC \u2022 71Z799014MO 62 El lenguaje SQL\n2)Borrado de filas de una tabla\n3)Modificaci\u00f3n de filas de una tabla:\n4)Consultas de una base de datos relacional:\nAnexo 3\nSentencias de control\n1)Iniciaci\u00f3n de transacciones:\n2)Finalizaci\u00f3n de transacciones:\n3)Autorizaciones:\n4)Desautorizaciones:DELETE FROM  nombre_tabla\n[WHERE condiciones];\nUPDATE nombre_tabla\nSET columna = {expresion |DEFAULT |NULL}\n[, columna = {expr |DEFAULT |NULL} ...]\nWHERE condiciones;\nSELECT [DISTINCT ] nombre_columnas_a_seleccionar\nFROM tablas_a_consultar\n[WHERE condiciones]\n[GROUP BY  atributos_seg\u00fan_los_cuales_se_quiere_agrupar]\n[HAVING condiciones_por_grupos]\n[ORDER  BY columna_ordenaci\u00f3n  [DESC] [, columna [ DESC]...]];\nSET TRANSACTION {READ ONLY |READ WRITE };\n{COMMIT |ROLLBACK } [WORK];\nGRANT privilegios ON objeto TO usuarios\n[WITH GRANT OPTION ];\nREVOKE [GRANT OPTION FOR ] privilegios ON objeto FROM usuarios\n{RESTRICT |CASCADE};Introducci\u00f3n  \nal dise\u00f1o de bases \nde datos\nDolors Costal Costa\n\uf8e9 FUOC \u2022 71Z799014MO Introducci\u00f3n al dise\u00f1o de bases de datos\n\u00cdndice\nIntroducci\u00f3n ............................................................................................... 5\nObjetivos ...................................................................................................... 5\n1. Introducci\u00f3n al dise\u00f1o de bases de datos ...................................... 7\n1.1. Etapas del dise\u00f1o de bases de datos................................................... 7\n2. Dise\u00f1o conceptual: el modelo ER ..................................................... 10\n2.1. Construcciones b\u00e1sicas...................................................................... 11\n2.1.1. Entidades, atributos e interrelaciones.................................... 11\n2.1.2. Grado de las interrelaciones................................................... 13\n2.1.3. Interrelaciones binarias.......................................................... 16\n2.1.4. Ejemplo: base de datos de casas de colonias.......................... 18\n2.1.5. Interrelaciones n-arias ............................................................ 21\n2.1.6. Interrelaciones recursivas....................................................... 23\n2.1.7. Entidades d\u00e9biles.................................................................... 25\n2.2. Extensiones del modelo ER ............................................................... 26\n2.2.1. Generalizaci\u00f3n/especializaci\u00f3n.............................................. 26\n2.2.2. Entidades asociativas.............................................................. 28\n2.3. Ejemplo: base de datos del personal de una entidad bancaria ......... 30\n3. Dise\u00f1o l\u00f3gico: la transformaci\u00f3n  \ndel modelo ER al modelo relacional ............................................... 35\n3.1. Introducci\u00f3n a la transformaci\u00f3n de entidades  \ne interrelaciones................................................................................. 35\n3.2. Transformaci\u00f3n de entidades ............................................................ 35\n3.3. Transformaci\u00f3n de interrelaciones binarias...................................... 36\n3.3.1. Conectividad 1:1 .................................................................... 36\n3.3.2. Conectividad 1:N ................................................................... 37\n3.3.3. Conectividad M:N.................................................................. 38\n3.3.4. Influencia de la dependencia de existencia  \nen la transformaci\u00f3n de las interrelaciones binarias ............. 39\n3.4. Transformaci\u00f3n de interrelaciones ternarias..................................... 40\n3.4.1. Conectividad M:N:P............................................................... 40\n3.4.2. Conectividad M:N:1............................................................... 41\n3.4.3. Conectividad N:1:1 ................................................................ 42\n3.4.4. Conectividad 1:1:1 ................................................................. 43\n3.5. Transformaci\u00f3n de interrelaciones n-arias ........................................ 44\n3.6. Transformaci\u00f3n de interrelaciones recursivas................................... 44\n3.7. Transformaci\u00f3n de entidades d\u00e9biles................................................ 46\n3.8. Transformaci\u00f3n de la generalizaci\u00f3n/especializaci\u00f3n....................... 47\uf8e9 FUOC \u2022 71Z799014MO Introducci\u00f3n al dise\u00f1o de bases de datos\n3.9. Transformaci\u00f3n de entidades asociativas....................................... 48\n3.10. Resumen de la transf ormaci\u00f3n del modelo ER  \nal modelo relacional....................................................................... 49\n3.11. Ejemplo: base de datos del personal de una entidad bancaria ...... 49\nResumen ....................................................................................................... 51\nEjercicios de autoevaluaci\u00f3n .................................................................. 53\nSolucionario ................................................................................................ 55\nGlosario ........................................................................................................ 59\nBibliograf\u00eda ................................................................................................. 60\uf8e9 FUOC \u2022 71Z799014MO 5 Introducci\u00f3n al dise\u00f1o de bases de datos\nIntroducci\u00f3n al dise\u00f1o de bases de datos\nIntroducci\u00f3n\nEn otras unidades did\u00e1cticas se estudian las bases de datos relacionales y un \nlenguaje relacional, SQL, que nos proporciona mecanismos para crear, actua -\nlizar y consultar estas bases de datos.\nEs necesario complementar estos conoci mientos con un aspecto que es funda -\nmental para poder utilizar adecuadamente la tecnolog\u00eda de las bases de datos re -\nlacionales: el dise\u00f1o. \u00c9ste ser\u00e1 el objeto de estudio de esta unidad, que tratar\u00e1 el \ndise\u00f1o de bases de datos  para el caso espec\u00edfico del modelo relacional. \nConcretamente, en es ta unidad explicaremos en qu \u00e9 consiste el dise\u00f1o de una \nbase de datos, analizaremos las etapas en las que se puede descomponer y des -\ncribiremos con detalle las etapas del di se\u00f1o conceptual y l\u00f3gico de una base \nde datos relacional.\nObjetivos\nEn los materiales did\u00e1cticos de esta  unidad encontrar\u00e9is las herramientas \nindispensables para alcanzar los siguientes objetivos:\n1.Conocer las etapas que integran el proc eso del dise\u00f1o de una base de datos.\n2.Conocer las estructuras del modelo ER.\n3.Saber hacer el dise\u00f1o conceptual de lo s datos de un sistema de informaci\u00f3n \nmediante el modelo ER.\n4.Saber hacer el dise\u00f1o l\u00f3gico de una base de datos relacional partiendo de \nun dise\u00f1o conceptual expr esado con el modelo ER.\n\uf8e9 FUOC \u2022 71Z799014MO 7 Introducci\u00f3n al dise\u00f1o de bases de datos\n1. Introducci\u00f3n al dise\u00f1o de bases de datos\nEn otras unidades hemos aprendido c\u00f3mo es una base de datos relacional y \nhemos estudiado un lenguaje, el SQL, que nos proporciona mecanismos para \ncrear estas bases de datos, as\u00ed como para actualizarlas y consultarlas.\nSin embargo, todav\u00eda debemos resolver  algunas cuestiones fundamentales \npara poder emplear la tecn olog\u00eda de las bases de datos relacionales; por ejem -\nplo, c\u00f3mo se puede decidir qu\u00e9 relaciones debe tener una base de datos deter -\nminada o qu\u00e9 atributos deben presentar las relaciones, qu\u00e9 claves primarias y \nqu\u00e9 claves for\u00e1neas se deben declarar, etc. La tarea de tomar este conjunto de decisiones recibe el nombre de dise\u00f1ar la base de datos .\nUna base de datos sirve para almacenar la informaci\u00f3n que se utiliza en un sis -\ntema de informaci\u00f3n determ inado. Las necesidades y los requisitos de los fu -\nturos usuarios del sistema de informaci\u00f3n se deben te ner en cuenta para poder \ntomar adecuadamente las decisiones anteriores.\nSi record\u00e1is los tres mundos  presentados \u2013el real, el conceptual y el de las re -\npresentaciones\u2013, observar\u00e9is que el dise\u00f1o  de una base de datos consiste en la \nobtenci\u00f3n de una representaci\u00f3n inform\u00e1t ica concreta a partir del estudio del \nmundo real de inter\u00e9s. \n1.1. Etapas del dise\u00f1o de bases de datos\nEl dise\u00f1o de una base de datos no es  un proceso sencillo. Habitualmente, la \ncomplejidad de la informaci\u00f3n y la cantid ad de requisitos de los sistemas de \ninformaci\u00f3n hacen que sea complicado. Por este motivo, cuando se dise\u00f1an bases de datos es interesante aplicar la vieja estrategia de dividir para vencer.\nPor lo tanto, conviene descomponer el pr oceso del dise\u00f1o en varias etapas; en \ncada una se obtiene un resultado interm edio que sirve de punto de partida de \nla etapa siguiente, y en la \u00faltima etapa se obtiene el resultado deseado. De este \nmodo no hace falta resolver de golpe toda la problem\u00e1tica que plantea el di -\nse\u00f1o, sino que en cada etapa se afronta un solo tipo de su bproblema. As\u00ed se \ndivide el problema y, al mismo tiempo, se simplifica el proceso.En resumen, el dise\u00f1o de una base de datos  consiste en definir la es -\ntructura de los datos que debe tener la base de datos de un sistema de \ninformaci\u00f3n determinado. En el caso relacional, esta estructura ser\u00e1 un \nconjunto de esquemas de relaci\u00f3n con sus atributos, dominios de atri -\nbutos, claves primarias, claves for\u00e1neas, etc.Recordad que las bases de datos \nrelacionales y los lenguajes SQL  \nse han estudiado en las unidades  \n\u201cEl modelo relacional y el \u00e1lgebra relacional\u201d y \u201cEl lenguaje SQL\u201d, respectivamente.\n\uf8e9 FUOC \u2022 71Z799014MO 8 Introducci\u00f3n al dise\u00f1o de bases de datos\nDescompondremos el dise\u00f1o de bases de datos en tres etapas: \n1) Etapa del dise\u00f1o conceptual:  en esta etapa se obtiene una estructura de la \ninformaci\u00f3n de la futura BD independ iente de la tecnolog\u00eda que hay que em -\nplear. No se tiene en cuenta todav\u00eda qu\u00e9 tipo de base de datos se utilizar\u00e1 \u2013rela -\ncional, orientada a objetos, jer\u00e1rquica, et c.\u2013; en consecuencia, tampoco se tiene \nen cuenta con qu\u00e9 SGBD ni con qu\u00e9 lenguaje concreto se implementar\u00e1 la base de datos. As\u00ed pues, la etapa del dise\u00f1o  conceptual nos permite concentrarnos \n\u00fanicamente en la problem\u00e1tica de la estr ucturaci\u00f3n de la informaci\u00f3n, sin tener \nque preocuparnos al mismo tiempo de  resolver cuestiones tecnol\u00f3gicas.\nEl resultado de la etapa del dise\u00f1o conceptual se expresa mediante alg\u00fan mo -\ndelo de datos de alto nivel. Uno de los m\u00e1s empleados es el modelo entidad-\ninterrelaci\u00f3n  (entity-relationship ), que abreviaremos con la sigla ER.\n2) Etapa del dise\u00f1o l\u00f3gico : en esta etapa se parte del resultado del dise\u00f1o \nconceptual, que se transforma de forma que se adapte a la tecnolog\u00eda que se \ndebe emplear. M\u00e1s concretamente, es preciso que se ajuste al modelo del \nSGBD con el que se desea implementar la ba se de datos. Por ejemplo, si se trata \nde un SGBD relacional, esta etapa obtendr\u00e1 un conjunto de relaciones con sus atributos, claves primarias y claves for\u00e1neas.\nEsta etapa parte del hecho de que ya se ha resuelto la problem\u00e1tica de la es -\ntructuraci\u00f3n de la informaci\u00f3n en un  \u00e1mbito conceptual, y permite concen -\ntrarnos en las cuestiones tecnol\u00f3gicas re lacionadas con el modelo de base de \ndatos.\nM\u00e1s adelante explicaremos c\u00f3mo se hace el dise\u00f1o l\u00f3gico de una base de datos \nrelacional, tomando como punto de part ida un dise\u00f1o conceptual expresado \ncon el modelo ER; es decir, veremos c\u00f3 mo se puede transformar un modelo ER \nen un modelo relacional.\n3) Etapa del dise\u00f1o f\u00edsico:  en esta etapa se transforma la estructura obtenida \nen la etapa del dise\u00f1o l\u00f3gico, con el objetivo de conseguir una mayor eficien -\ncia; adem\u00e1s, se completa con aspectos de implementaci\u00f3n f\u00edsica que depende -\nr\u00e1n del SGBD.\nPor ejemplo, si se trata de una base de datos relacional, la transformaci\u00f3n de \nla estructura puede consistir en lo siguiente: tener almacenada alguna relaci\u00f3n que sea la combinaci\u00f3n de varias relaciones que se han obtenido en la etapa \ndel dise\u00f1o l\u00f3gico, partir una relaci\u00f3n en  varias, a\u00f1adir alg\u00fan atributo calcula\n-\nble a una relaci\u00f3n, etc. Los aspectos de implementaci\u00f3n f\u00edsica que hay que \ncompletar consisten normalme nte en la elecci\u00f3n de estructuras f\u00edsicas de im -\nplementaci\u00f3n de las relaci ones, la selecci\u00f3n del tama \u00f1o de las memorias inter -\nmedias ( buffers ) o de las p\u00e1ginas, etc.\nEl resultado del dise\u00f1o \nconceptual\nSi retomamos la idea de los  \ntres mundos, podemos afirmar que la etapa del dise\u00f1o  \nconceptual obtiene un  \nresultado que se sit\u00faa en el mundo de las concepciones,  \ny no en el mundo de las  \nrepresentaciones.\nLa forma de elaborar un dise\u00f1o \nconceptual expresado con el modelo ER se explica en el apartado 2  \nde esta unidad.\nEl resultado del dise\u00f1o \nl\u00f3gico\nEl resultado del dise\u00f1o l\u00f3gico \nse sit\u00faa ya en el mundo  \nde las representaciones.\nEl dise\u00f1o l\u00f3gico de una base  \nde datos relacional se explica en el apartado 3 de esta unidad did\u00e1ctica.\nEl resultado del dise\u00f1o \nf\u00edsico\nEl resultado de la etapa  \ndel dise\u00f1o f\u00edsico se sit\u00faa  \nen el mundo de las representa-ciones, al igual que el resultado de la etapa del dise\u00f1o l\u00f3gico. La diferencia con respecto  \na la etapa anterior es que ahora se tienen en cuenta aspectos de car\u00e1cter m\u00e1s f\u00edsico del  \nmundo de las representaciones.\uf8e9 FUOC \u2022 71Z799014MO 9 Introducci\u00f3n al dise\u00f1o de bases de datos\nEn la etapa del dise\u00f1o f\u00edsico \u2013con el objetivo de conseguir un buen rendimien -\nto de la base de datos\u2013, se deben tener en cuenta las caracter\u00edsticas de los pro -\ncesos que consultan y actu alizan la base de dato s, como por ejemplo los \ncaminos de acceso que utilizan y las fre cuencias de ejecuci\u00f3n. Tambi\u00e9n es ne -\ncesario considerar los vol\u00fa menes que se espera tener de los diferentes datos \nque se quieren almacenar.\uf8e9 FUOC \u2022 71Z799014MO 10 Introducci\u00f3n al dise\u00f1o de bases de datos\n2. Dise\u00f1o conceptual: el modelo ER\nEn este apartado trataremos el dise\u00f1o conceptual de una base de datos me -\ndiante el modelo ER. Lo que explicaremos es aplicable al dise\u00f1o de cualquier \ntipo de bases de datos \u2013relacional, jer\u00e1rquica, etc.\u2013, porque, como ya hemos dicho, en la etapa del dise\u00f1o conceptual todav\u00eda no se tiene en cuenta la tec\n-\nnolog\u00eda concreta que se utilizar\u00e1 para  implementar la base de datos. \nEl modelo ER  es uno de los enfoques de mode lizaci\u00f3n de datos que m\u00e1s se uti -\nliza actualmente por su simp licidad y legibilidad. Su le gibilidad se ve favoreci -\nda porque proporciona una notaci\u00f3n di agram\u00e1tica muy comprensiva. Es una \nherramienta \u00fatil tanto para ayudar al di se\u00f1ador a reflejar en un modelo con -\nceptual los requisitos del mundo real de inter\u00e9s como para comunicarse con \nel usuario final sobre el modelo concep tual obtenido y, de este modo, poder \nverificar si satisface sus requisitos.\nEl modelo ER resulta f\u00e1cil de aprender y de utilizar en la mayor\u00eda de las aplica -\nciones. Adem\u00e1s, existen herramientas info rm\u00e1ticas de ayuda al dise\u00f1o (herra -\nmientas CASE*) que utilizan alguna variante del modelo ER para hacer el dise\u00f1o \nde los datos.\nEl nombre completo del modelo ER es entity-relationship , y proviene del hecho de \nque los principales elementos que incluye son las entidades y las interrelaciones \n(entities  y relationships ). Traduciremos este nombre por \u2018entidad-interrelaci\u00f3n\u2019.\nEl origen del modelo ER se encuentra en  trabajos efectuados por Peter Chen en \n1976. Posteriormente, muchos otros auto res han descrito variantes y/o exten -\nsiones de este modelo. As\u00ed pues, en la literatura se encuentran muchas formas \ndiferentes del modelo ER que pueden va riar simplemente en la notaci\u00f3n diagra -\nm\u00e1tica o en algunos de los conceptos en que se basan para modelizar los datos.\nCuando se quiere utilizar el modelo ER para comunicarse con el usuario, es re -\ncomendable emplear una variante del modelo que incluya s\u00f3lo sus elementos \nm\u00e1s simples \u2013entidades, atributos e inte rrelaciones\u2013 y, tal vez, algunas cons -\ntrucciones adicionales, co mo por ejemplo entidades d\u00e9biles y dependencias de \nexistencia. \u00c9stos eran los elementos incl uidos en el modelo original propuesto \npor Chen. En cambio, para llevar a cabo  la tarea de modelizar propiamente di -\ncha, suele ser \u00fatil usar un modelo ER m\u00e1s completo que incluya construccio -\nnes m\u00e1s avanzadas que extienden el modelo original.\nSeg\u00fan la noci\u00f3n de  modelo de datos  que hemos utilizado en los otros m\u00f3dulos, \nun modelo de datos tiene en cuenta tres aspectos de los datos: la estructura, la \nmanipulaci\u00f3n y la integridad. Sin emba rgo, el modelo ER habitualmente se \n* La sigla CASE corresponde\nal t\u00e9rmino ingl\u00e9s Computer Aided \nSoftware Engineering .\nEl modelo entidad-\ninterrelaci\u00f3n\nAlgunos autores denominan \nentidad-relaci\u00f3n  al modelo ER, \npero en nuestro caso hemos preferido traducir relationship  \npor \u2018interrelaci\u00f3n\u2019 y no por  \n\u2018relaci\u00f3n\u2019, con el objetivo  \nde evitar confusiones entre este concepto y el de relaci\u00f3n  \nque se utiliza en el modelo  \nrelacional.\nRecordad el modelo relacional,  \nque se ha estudiado en la unidad  \n\u201cEl modelo relacional y el \u00e1lgebra relacional\u201d.\n\uf8e9 FUOC \u2022 71Z799014MO 11 Introducci\u00f3n al dise\u00f1o de bases de datos\nutiliza para reflejar aspectos de la estr uctura de los datos y de su integridad, \npero no de su manipulaci\u00f3n. \n2.1. Construcciones b\u00e1sicas\n2.1.1. Entidades, atributos e interrelaciones\nEjemplos de entidad\nAlgunos ejemplos de entidad son un empleado , un producto o un despacho. Tambi\u00e9n son \nentidades otros elementos del mu ndo real de inter\u00e9s, menos tangibles pero igualmente dife -\nrenciables del resto de objetos; por ejemplo, una asignatura impartid a en una universidad, \nun pr\u00e9stamo bancario, un pedido de un cliente, etc.\nEjemplos de atributo\nSobre una entidad empleado  nos puede interesar, por ejemplo, tener registrados su DNI, su \nNSS, su nombre, su apellido y su sueldo como atributos.\nEl t\u00e9rmino entidad  se utiliza tanto para denomina r objetos individuales como \npara hacer referencia a conjuntos de ob jetos similares de lo s que nos interesan \nlos mismos atributos; es de cir, que, por ejemplo, se utiliza para designar tanto \na un empleado concreto de una empres a como al conjunto de todos los em -\npleados de la empresa. M\u00e1s concretamente, el t\u00e9rmino entidad se puede referir \na instancias u ocurrencias concretas  (empleados concretos) o a tipos o cla -\nses de entidades  (el conjunto de todos los empleados).\nEl modelo ER proporciona una notaci\u00f3n diagram\u00e1tica  para representar gr\u00e1 -\nficamente las entidades y sus atributos: \n\u2022L a s  entidades se representan con un rect\u00e1ngulo. El nombre de la entidad \nse escribe en may\u00fasculas  dentro del rect\u00e1ngulo.\n\u2022L o s  atributos  se representan mediante su nombre  en min\u00fasculas unido \ncon un gui\u00f3n al rect\u00e1ngulo de la en tidad a la que pertenecen. Muchas ve -\nces, dado que hay muchos atributos para cada entidad, se listan todos apar -\nte del diagrama para no complicarlo.\nCada uno de los atributos de una entida d toma valores de un cierto dominio o \nconjunto de valores. Los valores de los dominios deben ser at \u00f3micos; es decir, Por entidad  entendemos un objeto del mundo real que podemos dis -\ntinguir del resto de objetos y del que nos interesan algunas propiedades.\nLas propiedades de los objetos que nos interesan se denominan atributos .\nNotaci\u00f3n diagram\u00e1tica  \nde entidades y atributos\nLa figura muestra la notaci\u00f3n \ndiagram\u00e1tica para  el caso de \nuna entidad empleado  con los \natributos dni, nss, nombre ,  \napellido  y sueldo .\uf8e9 FUOC \u2022 71Z799014MO 12 Introducci\u00f3n al dise\u00f1o de bases de datos\nno deben poder ser descompuestos. Adem\u00e1s, todos los atributos tienen que ser \nunivaluados. Un atributo es univaluado si tiene un \u00fanico valor para cada ocu -\nrrencia de una entidad.\nEjemplo de atributo univaluado\nEl atributo sueldo  de la entidad empleado , por ejemplo, toma valores del dominio de los reales \ny \u00fanicamente toma un valor para cada empleado concreto; por lo tanto, ning\u00fan empleado \npuede tener m\u00e1s de un valor para el sueldo.\nComo ya hemos comentado anteriormente,  una entidad debe ser distinguible \ndel resto de objetos del mundo real. Esto hace que para toda entidad sea posi -\nble encontrar un conjunto de atributos que permitan identificarla. Este con -\njunto de atributos forma una clave de la entidad .\nEjemplo de clave\nLa entidad empleado  tiene una clave que consta del atributo dni porque todos los empleados \ntienen n\u00fameros de DNI diferentes.\nUna determinada entidad puede tener m\u00e1s de una clave; es decir, puede tener \nvarias claves candidatas .\nEjemplo de clave candidata\nLa entidad empleado  tiene dos claves candidatas, la que est\u00e1 formada por el atributo dni y la \nque est\u00e1 constituida por el atributo nss, teniendo en cuenta que el NSS tambi\u00e9n ser\u00e1 diferente \npara cada uno de los empleados.\nEl dise\u00f1ador elige una clave primaria entre todas las claves candidatas. En la \nnotaci\u00f3n diagram\u00e1tica, la clave primaria se subraya para dist inguirla del resto \nde las claves. \nEjemplo de clave primaria\nEn el caso de la entidad empleado , podemos elegir dni como clave primaria. En la figura del \nmargen vemos que la clave primaria se  subraya para distinguirla del resto.\nLas interrelaciones se representan en los diagramas del modelo ER mediante \nun rombo. Junto al rombo se indica el nombre de la interrelaci\u00f3n con letras may\u00fasculas. \nEjemplo de interrelaci\u00f3n\nConsideremos una entidad empleado  y una entidad despacho  y supongamos que a los emplea -\ndos se les asignan despachos donde trabajar. En tonces hay una interrelaci\u00f3n entre la entidad \nempleado  y la entidad despacho .\nEsta interrelaci\u00f3n, que podr\u00edamos denominar asignaci\u00f3n , asocia a los empleados con los des -\npachos donde trabajan. La figura de l margen muestra la interrelaci\u00f3n asignaci\u00f3n  entre las en -\ntidades empleado  y despacho .\nEl t\u00e9rmino interrelaci\u00f3n  se puede utilizar tanto pa ra denominar asociaciones \nconcretas u ocurrencias de asociaciones como para designar conjuntos o clases de asociaciones similares.Se define interrelaci\u00f3n  como una asociaci\u00f3n entre entidades.Recordad que los valores de los \natributos de las relaciones tambi\u00e9n deben ser at\u00f3micos, tal y como se  \nha explicado en la unidad \u201cEl modelo relacional y el \u00e1lgebra relacional\u201d.\nLos conceptos de clave candidata   \ny clave primaria  de una entidad  \nson similares a los conceptos de  \nclave candidata  y clave primaria de  \nuna relaci\u00f3n, que hemos estudiado  \nen la unidad \u201cEl modelo relacionaly el \u00e1lgebra relacional\u201d.\n\uf8e9 FUOC \u2022 71Z799014MO 13 Introducci\u00f3n al dise\u00f1o de bases de datos\nEjemplo\nUna interrelaci\u00f3n se aplica tanto a una asoc iaci\u00f3n concreta entre el empleado de DNI \n\u201850.455.234\u2019 y el despacho \u2018Diagonal, 20\u2019 como  a la asociaci\u00f3n gen\u00e9rica entre la entidad em-\npleado  y la entidad despacho .\nLos atributos de las interrelaciones se representan mediante su nombre en min\u00fas -\nculas unido con un gui\u00f3n al rombo de la interrelaci\u00f3n a la que pertenecen. \nEjemplo de atributo de una interrelaci\u00f3n\nObservemos la entidad estudiante  y la entidad asignatura  que se muestran en la figura \nsiguiente:\nEntre estas dos entidades se establece la interrelaci\u00f3n evaluaci\u00f3n  para indicar de qu\u00e9 asigna -\nturas han sido evaluados los estudiantes.  Esta interrelaci\u00f3n tiene el atributo nota, que sirve \npara especificar qu\u00e9 nota han obtenido lo s estudiantes de las asignaturas evaluadas.\nConviene observar que el atributo nota deber ser forzosamente un at ributo de la interrelaci\u00f3n \nevaluaci\u00f3n , y que no ser\u00eda correcto considerarlo un atributo de la entidad estudiante  o un atri -\nbuto de la entidad asignatura . Lo explicaremos analizando las ocurrencias de la interrelaci\u00f3n \nevaluaci\u00f3n  que se muestran en la figura anterior.\nSi nota se considerase un atributo de estudiante , entonces para el estudiante \u2018E1\u2019 de la figura \nnecesitar\u00edamos dos valores del atributo, uno para cada asignatura que tiene el estudiante; por lo tanto, no ser\u00eda univaluado. De forma similar, si nota fuese atributo de asignatura  tampoco \npodr\u00eda ser univaluado porque, por ejemplo, la asignatura \u2018A1\u2019 requerir\u00eda tres valores de nota, una para cada estudiante que se ha matriculad o en ella. Podemos concluir que el atributo \nnota est\u00e1 relacionado al mismo tiempo con una asignatura y con un estudiante que la cursa \ny que, por ello, debe ser un atributo de la interrelaci\u00f3n que asocia las dos entidades.\n2.1.2. Grado de las interrelacionesEn ocasiones interesa reflejar algunas propiedades de las interrelacio -\nnes. Por este motivo, las interrelaciones pueden tener tambi\u00e9n atribu -\ntos. Los atributos de las interrelaciones , igual que los de las entidades, \ntienen un cierto dominio, deben tomar valores at\u00f3micos y deben ser univaluados.\nUna interrelaci\u00f3n puede asociar dos o m\u00e1s entidades. El n\u00famero de en -\ntidades que asocia una interrelaci\u00f3n es el grado de la interrelaci\u00f3n .\n\uf8e9 FUOC \u2022 71Z799014MO 14 Introducci\u00f3n al dise\u00f1o de bases de datos\nInterrelaciones de grado dos\nLas interrelaciones evaluaci\u00f3n  y asignaci\u00f3n  de los ejemplos anteriores tienen grado dos:\n\u2022 La interrelaci\u00f3n evaluaci\u00f3n  asocia la entidad estudiante  y la entidad asignatura ; es decir, aso -\ncia dos entidades.\n\u2022 De forma an\u00e1loga, la interrelaci\u00f3n asignaci\u00f3n asocia empleado  y despacho .\nLas interrelaciones de grad o dos se denominan tambi\u00e9n interrelaciones bina -\nrias. Todas las interrelaciones de grado mayor que dos se denominan, en con -\njunto, interrelaciones n-arias . As\u00ed pues, una interrelaci\u00f3n n-aria puede tener \ngrado tres y ser una interrelaci\u00f3n ternar ia, puede tener grado cuatro y ser una \ninterrelaci\u00f3n cuaternaria, etc.\nA continuaci\u00f3n presentaremos un ejemplo que nos ilustrar\u00e1 el hecho de que, \nen ocasiones, las interrelaciones binari as no nos permiten  modelizar correcta -\nmente la realidad y es necesario utilizar interrela ciones de mayor grado.\nConsideremos la interrelaci\u00f3n evaluaci\u00f3n  de la figura anterior, que tiene un \natributo nota. Este atributo permite registrar la nota obtenida por cada estu -\ndiante en cada asignatura de la que ha  sido evaluado. Una interrelaci\u00f3n permite \nestablecer una sola asocia ci\u00f3n entre unas entidades individuales determinadas. \nEn otras palabras, s\u00f3lo se puede interrelac ionar una vez al estudiante \u2018E1\u2019 con la \nasignatura \u2018A1\u2019 v\u00eda la interrelaci\u00f3n evaluaci\u00f3n.\nObservad que, si pudiese haber m\u00e1s de una interrelaci\u00f3n entre el estudiante \n\u2018E1\u2019 y la asignatura \u2018A1\u2019, no podr\u00edamos distinguir estas dife rentes ocurrencias \nde la interrelaci\u00f3n. Esta restricci\u00f3n hace  que se registre una sola nota por estu -\ndiante y asignatura.\nSupongamos que deseamos registrar vari as notas por cada asignatura y estu -\ndiante correspondientes a varios semestre s en los que un mismo estudiante ha \ncursado una asignatura determinada (desgraciadamente, algunos estudiantes \ntienen que cursar una asignatura varias ve ces antes de aprobarla). La interrelaci\u00f3n \n\uf8e9 FUOC \u2022 71Z799014MO 15 Introducci\u00f3n al dise\u00f1o de bases de datos\nanterior no nos permitir\u00eda reflejar este caso. Ser\u00eda ne cesario aumentar el grado \nde la interrelaci\u00f3n, tal y como se  muestra en la figura siguiente:\nLa interrelaci\u00f3n ternaria evaluaci\u00f3n-semestral  asocia estudiantes, asignaturas y \nuna tercera entidad que denominamos semestre . Su atributo nota nos permite \nreflejar todas las notas de una asigna tura que tiene un estudiante correspon -\ndientes a diferentes semestres.\nDe hecho, lo que sucede en este caso es que, seg\u00fan los requisitos de los usua -\nrios de esta BD, una nota pertenece al mismo tiempo a un estudiante, a una \nasignatura y a un semestre y, l\u00f3gicamente, debe ser un atributo de una inte -\nrrelaci\u00f3n ternaria entre estas tres entidades.\nEste ejemplo demuestra que una interrelaci\u00f3n binaria puede no ser suficiente \npara satisfacer los requisitos de los us uarios, y puede ser necesario aplicar una \ninterrelaci\u00f3n de mayor grado. Conviene  observar que esto tambi\u00e9n puede ocu -\nrrir en interrelaciones qu e no tienen atributos. \nEjemplo de interrelaci\u00f3n ternaria sin atributos\nConsideremos un caso en el que deseamos saber para cada estudiante qu\u00e9 asignaturas ha cur -\nsado cada semestre, a pesar de que no queremos  registrar la nota que ha obtenido. Entonces \naplicar\u00edamos tambi\u00e9n una interrelaci \u00f3n ternaria entre las entidades estudiante , asignatura  y se-\nmestre  que no tendr\u00eda atributos, tal y como se muestra en la figura siguiente:\nHemos analizado casos en los que era nece sario utilizar interrelaciones ternarias \npara poder modelizar correctamente cier tas situaciones de inter\u00e9s del mundo \n\uf8e9 FUOC \u2022 71Z799014MO 16 Introducci\u00f3n al dise\u00f1o de bases de datos\nreal. Es preciso remarcar que, de forma similar, a veces puede ser necesario uti -\nlizar interrelaciones de grado todav\u00eda mayor: cuaternarias, etc. \nEn el subapartado siguiente analizaremos con detalle las interrelaciones bina -\nrias, y m\u00e1s adelante, las interrelaciones n-arias.\n2.1.3. Interrelaciones binarias\nConectividad de las in terrelaciones binarias\nUna interrelaci\u00f3n binaria entre dos en tidades puede tener tres tipos de co -\nnectividad: \n\u2022 Conectividad uno a uno (1:1).  La conectividad 1:1 se denota poniendo \nun 1 a lado y lado de la interrelaci\u00f3n.\n\u2022 Conectividad uno a muchos (1:N ). La conectividad 1:N se denota po -\nniendo un 1 en un lado de la interrelaci\u00f3n y una N en el otro.\n\u2022 Conectividad muchos a muchos: (M:N) . La conectividad  M:N se denota \nponiendo una M en uno de los lados de la interrelaci\u00f3n, y una N en el otro.\nEjemplos de conectividad en una interrelaci\u00f3n binaria\nA continuaci\u00f3n analizaremos un ejemplo de ca da una de las conectividades posibles para \nuna interrelaci\u00f3n binaria:\na) Conectividad 1:1La conectividad de una interrelaci\u00f3n  expresa el tipo de corresponden -\ncia que se establece entre las ocurre ncias de entidades asociadas con la \ninterrelaci\u00f3n. En el caso de las in terrelaciones binarias, expresa el n\u00fa -\nmero de ocurrencias de una de las entidades con las que una ocurrencia \nde la otra entidad puede estar asociada seg\u00fan la interrelaci\u00f3n.\nLas relaciones n-arias se analizan  \nen el subapartado 2.1.4 de esta unidad did\u00e1ctica.\n\uf8e9 FUOC \u2022 71Z799014MO 17 Introducci\u00f3n al dise\u00f1o de bases de datos\nLa interrelaci\u00f3n anterior tiene conectividad 1:1. Esta interrelaci\u00f3n asocia las delegaciones \nde una empresa con las ciudades donde est\u00e1n si tuadas. El hecho de que sea 1:1 indica que \nuna ciudad tiene s\u00f3lo una delegaci\u00f3n, y que una delegaci\u00f3n est\u00e1 situada en una \u00fanica \nciudad.\nb) Conectividad 1:N\nLa interrelaci\u00f3n asignaci\u00f3n  entre la entidad empleado  y la entidad despacho  tiene conectividad \n1:N, y la N est\u00e1 en el lado de la entidad empleado . Esto significa que un empleado tiene un \nsolo despacho asignado, pero que, en cambio, un despacho puede tener uno o m\u00e1s emplea -\ndos asignados.\nc) Conectividad M:N\nPara analizar la conectividad M: N, consideramos la interrelaci\u00f3n evaluaci\u00f3n  de la figura ante -\nrior. Nos indica que un estudian te puede ser evaluado de varias asignaturas y, al mismo tiem -\npo, que una asignatura puede tener varios estudiantes por evaluar.\nEs muy habitual que las interrel aciones binarias M:N y todas las  n-arias tengan \natributos. En cambio, las interrelaciones binarias 1: 1 y 1:N no tienen por qu\u00e9 \ntenerlos. Siempre se pueden asignar estos atributos a la entidad del lado N, en el caso de las 1:N, y a cualquiera de las dos entidades interrelacionadas en el \ncaso de las 1:1. Este cambio de situac i\u00f3n del atributo se puede hacer porque \nno origina un atributo multivaluado. \n\uf8e9 FUOC \u2022 71Z799014MO 18 Introducci\u00f3n al dise\u00f1o de bases de datos\nDependencias de existencia en  las interrelaciones binarias\nEn el modelo ER, un c\u00edrculo en la l\u00ed nea de conexi\u00f3n entre una entidad y una \ninterrelaci\u00f3n indica que la entidad es op cional en la interrelaci\u00f3n. La obligato -\nriedad de una entidad a una interrelaci\u00f3n se indica con una l\u00ednea perpendicular. \nSi no se consigna ni un c\u00edrculo ni una l\u00ednea perpendicular, se considera que la dependencia de existencia es desconocida. \nEjemplo de dependencias de existencia\nLa figura siguiente nos servir\u00e1 para entender el  significado pr\u00e1ctico de la dependencia de exis -\ntencia. La entidad empleado  es obligatoria en la interrelaci\u00f3n direcci\u00f3n . Esto indica que no pue -\nde existir un departamento que no tenga un empleado que act\u00faa de director del \ndepartamento. La entidad departamento , en cambio, es opcional en la interrelaci\u00f3n  direcci\u00f3n . \nEs posible que haya un empleado que no est\u00e1  interrelacionado con ning\u00fan departamento: \npuede haber \u2013y es el caso m\u00e1s frecuente\u2013 em pleados que no son directores de departamento.\nAplicaremos la dependencia de existencia  en las interrelacion es binarias, pero \nno en las n-arias.\n2.1.4. Ejemplo: base de da tos de casas de colonias\nEn este punto, y antes de continuar explicando construcciones m\u00e1s complejas \ndel modelo ER, puede result ar muy ilustrativo ver la aplicaci\u00f3n pr\u00e1ctica de las \nconstrucciones que hemos estudiado hasta ahora. Por este motivo, analizare -\nmos un caso pr\u00e1ctico de dise\u00f1o con el modelo ER que corresponde a una base \nde datos destinada a la gest i\u00f3n de las inscripciones en un conjunto de casas de \ncolonias. El modelo ER de esta base de datos ser\u00e1 bastante sencillo e incluir\u00e1 \ns\u00f3lo entidades, atributos e interrelaciones  binarias (no incluir\u00e1 interrelaciones \nn-arias ni otros tipos de estructuras).En algunos casos, una entidad individual s\u00f3lo puede existir si hay como \nm\u00ednimo otra entidad individual asociada con ella mediante una interre -\nlaci\u00f3n binaria determinada. En estos casos, se dice que esta \u00faltima enti -\ndad es una entidad obligatoria en la interrelaci\u00f3n . Cuando esto no \nsucede, se dice que es una entidad opcional en la interrelaci\u00f3n .\n\uf8e9 FUOC \u2022 71Z799014MO 19 Introducci\u00f3n al dise\u00f1o de bases de datos\nLa descripci\u00f3n siguiente explica con de talle los requisitos de los usuarios \nque hay que tener en cuenta al hacer el dise\u00f1o conceptual de la futura base \nde datos:\na)Cada casa de colonias tiene un nombre  que la identifica. Se desea saber de \ncada una, aparte del nombre, la capacidad (el n\u00famero de ni\u00f1os que se pueden \nalojar en cada una como m\u00e1ximo), la comarca donde est\u00e1 situada y las ofertas de actividades que proporciona. Una ca sa puede ofrecer ac tividades como por \nejemplo nataci\u00f3n, esqu\u00ed, remo, pintura, fotograf\u00eda, m\u00fasica, etc.\nb)Es necesario tener en cuenta que en una casa de colonias se pueden practi -\ncar varias actividades (de hecho, cada casa debe ofrecer como m\u00ednimo una), y \ntambi\u00e9n puede ocurrir que una misma ac tividad se pueda llevar a cabo en va -\nrias casas. Sin embargo, toda actividad qu e se registre en la base de datos debe \nser ofertada como m\u00ednimo en una de las casas.\nc)Interesa  tener una evaluaci\u00f3n de las ofer tas de actividades que proporcio -\nnan las casas. Se asigna una calificaci\u00f3n num\u00e9rica que indica el nivel de cali -\ndad que tiene cada una de las actividades ofertadas.\nd)Las casas de colonias alojan ni\u00f1os que se  han inscrito para pasar en ellas unas \npeque\u00f1as vacaciones. Se quiere tener cons tancia de los ni\u00f1os que se alojan en \ncada una de las casas en el momento actual. Se debe suponer que hay casas que \nest\u00e1n vac\u00edas (en las que no  se aloja ning\u00fan ni\u00f1o) durante algunas temporadas.\ne)De los ni\u00f1os que se alojan actualmente en alguna de las casas, interesa cono -\ncer un c\u00f3digo que se les asigna para iden tificarlos, su nombre, su apellido, el n\u00fa -\nmero de tel\u00e9fono de sus padres y su comarca de residencia.\nf)De las comarcas donde hay casas o bien  donde residen ni\u00f1os, se quiere te -\nner registrados la superficie y el n\u00famero de habitantes . Se debe considerar que \npuede haber comarcas donde no reside ninguno de los ni\u00f1os que se alojan en \nun momento determinado en las casas de colonias, y comarcas que no dispo -\nnen de ninguna casa.\nLa figura siguiente muestra un diagrama ER que satisface los requisitos anterio -\nres. Los atributos de las entidades no fi guran en el diagrama y se listan aparte.Es posible, ...\n... por ejemplo, que una  \nactividad como por ejemplo  \nel esqu\u00ed tenga una calificaci\u00f3n de 10 en la oferta de la casa Gr\u00e9vol, y que la misma  \nactividad tenga una califica-ci\u00f3n de 8 en la casa Ardilla.\n\uf8e9 FUOC \u2022 71Z799014MO 20 Introducci\u00f3n al dise\u00f1o de bases de datos\nLos atributos de las entidades que figuran en el diagrama son los siguientes (las \nclaves primarias est\u00e1n subrayadas):\nA continuaci\u00f3n comentamos los aspectos  m\u00e1s relevantes de este modelo ER: \n1)Una de las dificultades que en ocasiones se pres enta durante la modeliza -\nci\u00f3n conceptual es decidir si una informaci\u00f3n determinada debe ser una enti -\ndad o un atributo. En nuestro ejemplo, puede resultar dif\u00edcil decidir si comarca \nse debe modelizar como una entidad o como un atributo.\nA primera vista, po dr\u00eda parecer que comarca  debe ser un atributo de la entidad \ncasa-colonias  para indicar d\u00f3nde est\u00e1 situada una casa de colonias, y tambi\u00e9n \nun atributo de la entidad ni\u00f1o para indicar la residencia del ni\u00f1o. Sin embargo, \nesta soluci\u00f3n no ser\u00eda adecuada, porque  se quieren tener informaciones adicio -\nnales asociadas a la comarca: la superfici e y el n\u00famero de habitantes. Es preciso \nque comarca  sea una entidad para poder reflejar estas informaciones adicionales \ncomo atributos de la entidad.\nLa entidad comarca  tendr\u00e1 que estar, evidenteme nte, interrelaci onada con las \nentidades ni\u00f1o y casa-colonias . Observad que de este modo, adem\u00e1s, se hace pa -\ntente que las comarcas de residencia de los ni\u00f1os y las comarcas de situaci\u00f3n \nde las casas son informaciones de un mismo tipo.\n2)Otra decisi\u00f3n que hay que tomar es si el concepto actividad  se debe mode -\nlizar como una entidad o como un atributo. Actividad  no tiene informaciones \nadicionales asociadas; no tiene, por lo tanto, m\u00e1s atributos que los que for -\nman la clave. Aun as\u00ed, es necesario que actividad  sea una entidad para que, me -\ndiante la interrelaci\u00f3n oferta , se pueda indicar que una casa de colonias ofrece \nactividades.\nObservad que las actividades ofertadas no se pueden expresar como un atribu -\nto de casa-colonias , porque una casa puede ofrece r muchas actividades y, en \neste caso, el atributo no podr\u00eda tomar un valor \u00fanico.\n3)Otra elecci\u00f3n dif\u00edcil, que con frecuenci a se presenta al dise\u00f1ar un modelo \nER, consiste en modelizar una informaci\u00f3n determinada como una entidad o CASA-COLONIAS\nnombre-casa , capacidad\nACTIVIDAD\nnombre-actividad\nNI\u00d1O\nc\u00f3digo-ni\u00f1o , nombre, apellido, tel\u00e9fono\nCOMARCA\nnombre-comarca , superficie, n\u00famero-habitantes\n\uf8e9 FUOC \u2022 71Z799014MO 21 Introducci\u00f3n al dise\u00f1o de bases de datos\ncomo una interrelaci\u00f3n. Por ejemplo, podr\u00edamos haber establecido que oferta , \nen lugar de ser una interrelaci\u00f3n, fues e una entidad; lo habr\u00edamos hecho as\u00ed:\nLa entidad oferta  representada en la figura ante rior tiene los atributos que pre -\nsentamos a continuaci\u00f3n:\nEsta soluci\u00f3n no acaba de reflejar adecuadamente la realidad. Si analizamos la \nclave de oferta , podemos ver que se identifica con nombre-casa , que es la clave \nde la entidad casa-colonias , y con nombre-actividad , que es la clave de la entidad \nactividad . Esto nos debe hacer sospechar qu e oferta, de hecho, corresponde a \nuna asociaci\u00f3n o interrelaci\u00f3n entre casas  y actividades . En consecuencia, re -\nflejaremos la realidad con m\u00e1s exactitud si modelizamos oferta  como una in -\nterrelaci\u00f3n entre estas entidades.\n4)Finalmente, un aspecto que hay que cu idar durante el dise\u00f1o conceptual \nes el de evitar las redundancias. Por ejemplo, si hubi\u00e9semos interrelacionado \ncomarca  con actividad  para saber qu\u00e9 actividades se realizan en las casas de \ncada una de las comarcas, habr\u00edamos tenido informaci\u00f3n redundante. La in -\nterrelaci\u00f3n oferta  junto con la interrelaci\u00f3n situaci\u00f3n  ya permiten saber, de for -\nma indirecta, qu\u00e9 actividades se hacen en las comarcas.\n2.1.5. Interrelaciones n-arias\nLas interrelaciones n-arias, igual que las binarias, pueden tener diferentes tipos \nde conectividad. En este subapartado analizaremos pr imero el caso particular \nde las interrelaciones ternarias y, a co ntinuaci\u00f3n, trataremos las conectivida -\ndes de las interrelaciones n-arias en general. \nConectividad de las in terrelaciones ternariasOFERTA\nnombre-casa, nombre-actividad, nivel\nCada una de las tres entidades asociadas con una interrelaci\u00f3n ternaria \npuede estar conectada con conectivid ad \u201cuno\u201d o bien con conectividad \n\u201cmuchos\u201d. En consecuencia, las inte rrelaciones ternar ias pueden tener \ncuatro tipos de conectividad: M:N:P, M:M:1, N:1:1  y 1:1:1.\nObservad que usamos M, N y P \npara representar \u201cmuchos\u201d, \ny 1 para representar \u201cuno\u201d.\uf8e9 FUOC \u2022 71Z799014MO 22 Introducci\u00f3n al dise\u00f1o de bases de datos\nAnalizaremos c\u00f3mo se decide cu\u00e1l es la conectividad adecuada de una inte -\nrrelaci\u00f3n ternaria mediante  el siguiente ejemplo. Consideremos una interre -\nlaci\u00f3n que denominamos clase y que asocia las entidades asignatura , aula y \nhora-semanal . Esta interrelaci\u00f3n permite regi strar clases presenciales. Una \nclase corresponde a una asignatura determinada, se imparte en un aula de -\nterminada y a una hora de la semana determinada. Por ejemplo, podemos registrar que se hace clase de la asigna tura IBD en el aula  D222 el martes a \nlas 9, tal y como se muestra en la figura de la p\u00e1gina siguiente. El atributo \nduraci\u00f3n  nos permite saber cu\u00e1ntas horas dura la clase.\nPara decidir si el lado de la entidad asignatura  se conecta con \u201cuno\u201d o con \u201cmu -\nchos\u201d , es necesario preguntarse si, dadas un aula y una hora-semanal , se puede \nhacer clase de s\u00f3lo una o bien de muchas asignaturas en aquellas aula y hora. La respuesta ser\u00eda que s\u00f3lo se puede ha cer clase de una asignatura en una mis\n-\nma aula y hora. Esto nos indica que asignatura  se conecta con \u201cuno\u201d, tal y \ncomo reflejamos en la figura siguiente:\nComo nos indica este ejemplo, para decidir c\u00f3mo se debe conectar una de las en -\ntidades, es necesario pregun tarse si, ya fijadas ocurrencias concretas de las otras \ndos, es posible conectar s\u00f3 lo \u201cuna\u201d o bien \u201cmuchas\u201d ocurrencias de la primera \nentidad. \nUtilizaremos el mismo procedimiento pa ra determinar c\u00f3mo se conectan las \notras dos entidades del ejemplo. Una vez fijadas una asignatura y un aula, es posible que se haga clase de aquella asig natura en aquella au la, en varias horas \nde la semana; entonces, hora-semana  se conecta con \u201cmuc hos\u201d. Finalmente, la \n\uf8e9 FUOC \u2022 71Z799014MO 23 Introducci\u00f3n al dise\u00f1o de bases de datos\nentidad aula se conecta con \u201cuno\u201d, teniendo en cuenta que, fijadas una asig -\nnatura y una hora de la semana, s\u00f3lo se puede hace r una clase de aquella asig -\nnatura a aquella hora. La conectividad resultante, de este modo, es N:1:1.\nCaso general: conectividad  de las interrelaciones n-arias\nLo que hemos explicado sobre la conect ividad para las in terrelaciones terna -\nrias es f\u00e1cilmente genera lizable a interrelaciones n-arias.\nPara decidir si una de las entidades se conecta con \u201cuno\u201d o con \u201cmuchos\u201d, es \nnecesario preguntarse si, fijadas ocurrencias concretas de las otras n \u2013 1 entidades, \nes posible conectar s\u00f3lo una o bien much as ocurrencias de la  primera entidad: \n\u2022 Si la respuesta es que s\u00f3lo una,  entonces se conecta con \u201cuno\u201d.\n\u2022 Si la respuesta es que muchas, la  entidad se conecta con \u201cmuchos\u201d.\n2.1.6. Interrelaciones recursivas\nEjemplo de interrelaci\u00f3n recursiva\nSi, para una entidad persona , queremos tener constancia de qu\u00e9 personas est\u00e1n actualmente \ncasadas entre ellas, ser\u00e1 necesario definir la si guiente interrelaci\u00f3n, que asocia dos veces la en -\ntidad persona :Una interrelaci\u00f3n n-aria puede tener n + 1 tipos de conectividad, tenien -\ndo en cuenta que cada una de las n entidades puede estar conectada con \n\u201cuno\u201d o con \u201cmuchos\u201d en la interrelaci\u00f3n*.\nUna interrelaci\u00f3n recursiva  es una interrelaci\u00f3n en la que alguna en -\ntidad est\u00e1 asociada m\u00e1s de una vez.\n* Recordad que para \nlas interrelaciones ternarias \nhay cuatro tipos posibles \nde conectividad.\n\uf8e9 FUOC \u2022 71Z799014MO 24 Introducci\u00f3n al dise\u00f1o de bases de datos\nUna interrelaci\u00f3n recursiva puede ser tanto binaria como n-aria:\n1) Interrelaci\u00f3n re cursiva binaria:  interrelaci\u00f3n en la que las ocurrencias \nasocian dos instancias de la misma entidad*. Las interrelaciones binarias re -\ncursivas pueden tener cone ctividad 1:1, 1:N o M:N, como todas las binarias. \nEn esta interrelaci\u00f3n tambi\u00e9n es posible expresar la dependencia de existencia \nigual que en el resto de la s interrelaciones binarias.\nEjemplo de interrelaci \u00f3n recursiva binaria\nLa interrelaci\u00f3n boda tiene conectividad 1:1 porque un marido est\u00e1 casado  con una sola mu -\njer y una mujer est\u00e1 casada con un solo marido. Tambi\u00e9n tiene un c\u00edrculo en los dos lados \n(seg\u00fan la dependencia de existencia), porque puede haber personas que no est\u00e9n casadas.\nEn una interrelaci\u00f3n recursiva, puede interesar distinguir los diferentes pa -\npeles que una misma entidad tiene en la interrelaci\u00f3n. Con este objetivo, se \npuede etiquetar cada l\u00ednea de la interr elaci\u00f3n con un rol. En las interrelacio -\nnes no recursivas normalmente no se es pecifica el rol; puesto que todas las \nentidades interrelacionadas son de clases  diferentes, sus diferencias de rol se \nsobreentienden.\nRoles diferentes\nUna ocurrencia de la interrelaci\u00f3n boda asocia a dos personas concretas. Para reflejar el papel \ndiferente que tiene cada una de ellas en la interr elaci\u00f3n, una de las personas tendr\u00e1 el rol de \nmarido y la otra tendr\u00e1 el rol de mujer.\nAlgunas interrelaciones recu rsivas no presentan dife renciaci\u00f3n de roles; en -\ntonces, las l\u00edneas de la in terrelaci\u00f3n no se etiquetan.\nNo-diferencia de roles\nConsideremos una interrelaci\u00f3n amistad que asocia a personas concretas que son amigas. A \ndiferencia de lo que suce d\u00eda en la interrelaci\u00f3n boda, donde una de las personas es el marido \ny la otra la mujer, en este caso no hay difere nciaci\u00f3n de roles entre las dos personas interre -\nlacionadas. A continuaci\u00f3n se mu estra esta interrelaci\u00f3n. Obse rvad que su conectividad es \nM:N, teniendo en cuenta que una persona pued e tener muchos amigos y, al mismo tiempo, \npuede haber muchas personas  que la consideran amiga.* \u00c9ste es el caso de la \ninterrelaci\u00f3n boda  anterior.\n\uf8e9 FUOC \u2022 71Z799014MO 25 Introducci\u00f3n al dise\u00f1o de bases de datos\n2) Interrelaci\u00f3n recursiva n-aria:  interrelaci\u00f3n recursiva en la que las ocu -\nrrencias asocian m\u00e1s de dos instancias.\nEjemplo de interrelaci\u00f3n recursiva ternaria\nConsideremos una interrelaci\u00f3n que registra todas las bodas que se han producido a lo \nlargo del tiempo entre un conjunto de person as determinado. Esta interrelaci\u00f3n permite \ntener constancia no s\u00f3lo de las bodas vigentes, sino de todas las bodas realizadas en un \ncierto periodo de tiempo.\nEsta interrelaci\u00f3n es recursiva y ternaria. Una oc urrencia de la interrelaci\u00f3n asocia a una per -\nsona que es el marido, a otra que es la mujer y la fecha de su boda. La conectividad es N:1:1. \nA los lados del marido y de la mujer les corresponde un 1, po rque un marido o una mujer, \nen una fecha determinada, se casa con una sola persona. Al lado de la  entidad fecha le corres -\nponde una N, porque se podr\u00eda dar el caso de que hubiese, en  fechas diferentes, m\u00e1s de una \nboda entre las mismas personas.\n2.1.7. Entidades d\u00e9biles\nLas entidades que hemos considerado hasta ahora tienen un conjunto de atribu -\ntos que forman su claves primarias y que permiten identificarlas completamente. \nEstas entidades se denominan, de forma m\u00e1s espec\u00edfica, entidades fuertes . En \neste subapartado consideraremos otro tipo de entidades que denominaremos en-\ntidades d\u00e9biles .\nUna entidad d\u00e9bil se representa con un rect\u00e1ngulo doble, y la interrelaci\u00f3n \nque ayuda a identificarla se representa con una doble l\u00ednea. \nEjemplo de entidad d\u00e9bil\nConsideremos las entidades edificio  y despacho  de la figura siguiente. Supongamos que puede \nhaber despachos con el mismo n\u00famero en edific ios diferentes. Entonces, su n\u00famero no iden -\ntifica completamente un despacho. Para identificar completamente un despacho, es necesa -\nrio tener en cuenta en qu\u00e9 edificio est\u00e1 situad o. De hecho, podemos identificar un despacho \nmediante la interrelaci\u00f3n situaci\u00f3n , que lo asocia a un \u00fanico edificio. El nombre del edificio \ndonde est\u00e1 situado junto con el n\u00famero de despacho lo identifican completamente.Una entidad d\u00e9bil  es una entidad cuyos atributos no la identifican \ncompletamente, sino que s\u00f3lo la id entifican de forma parcial. Esta en -\ntidad debe participar en una inte rrelaci\u00f3n que ayuda a identificarla.\n\uf8e9 FUOC \u2022 71Z799014MO 26 Introducci\u00f3n al dise\u00f1o de bases de datos\nEn el ejemplo anterior, la interrelaci\u00f3n situaci\u00f3n  nos ha permitido completar \nla identificaci\u00f3n de  los despachos. Para toda enti dad d\u00e9bil, siempre debe haber \nuna \u00fanica interrelaci\u00f3n que permita comp letar su identificaci\u00f3n. Esta interre -\nlaci\u00f3n debe ser binaria con conectividad 1:N, y la entidad d\u00e9bil debe estar en \nel lado N. De este modo, una ocurrencia  de la entidad d\u00e9bil est\u00e1 asociada con \nuna sola ocurrencia de la entidad del lado 1, y ser\u00e1  posible completar su iden -\ntificaci\u00f3n de forma \u00fanica. Adem\u00e1s, la entidad del lado 1 debe ser obligatoria \nen la interrelaci\u00f3n porque, si no fuese as\u00ed, alguna ocurrenc ia de la entidad d\u00e9 -\nbil podr\u00eda no estar interrelacionada con ninguna de sus ocurrencias y no se po -\ndr\u00eda identificar completamente. \n2.2. Extensiones del modelo ER\nEn este subapartado estudiaremos al gunas construcciones avanzadas que ex -\ntienden el modelo ER estudiado hasta ahora.\n2.2.1. Generalizaci\u00f3n/especializaci\u00f3n\nEn algunos casos, hay ocurrencias de un a entidad que tienen caracter\u00edsticas pro -\npias espec\u00edficas que nos interesa modeli zar. Por ejemplo, pu ede ocurrir que se \nquiera tener constancia de qu\u00e9 coche de  la empresa tienen asignado los emplea -\ndos que son directivos; tambi\u00e9n que, de los empleados t\u00e9cnicos, interese tener \nuna interrelaci\u00f3n con una entidad proyecto  que indique en qu\u00e9 proyectos trabajan \ny se desee registrar su titulaci\u00f3n. Finalm ente, que convenga conocer la antig\u00fcedad \nde los empleados administrativos. As\u00edm ismo, habr\u00e1 algunas caracter\u00edsticas comu -\nnes a todos los empleados: todos se iden tifican por un DNI, tienen un nombre, \nun apellido, una direcci\u00f3n y un n\u00famero de tel\u00e9fono.\nLa generalizaci\u00f3n/especializaci\u00f3n  permite reflejar el hecho de que \nhay una entidad general, que denominamos entidad superclase , que se \npuede especializar en entidades subclase:\n\uf8e9 FUOC \u2022 71Z799014MO 27 Introducci\u00f3n al dise\u00f1o de bases de datos\nDenotamos la generalizaci\u00f3 n/especializaci\u00f3n con una flecha que parte de las \nentidades subclase y que se dirige a la entidad superclase. \nEjemplo de entidades superclase y subclase\nEn la figura siguiente est\u00e1n re presentadas la entidad superclase , que corresponde al empleado \ndel ejemplo anterior, y las entida des subclase, que corresponden al directivo, al t\u00e9cnico y al \nadministrativo del mismo ejemplo.\nEn la generalizaci\u00f3n/especi alizaci\u00f3n, las caracter\u00edsti cas (atributos o interrela -\nciones) de la entidad superclase se prop agan hacia las entidades subclase. Es lo \nque se denomina herencia de propiedades .\nEn el dise\u00f1o de una generalizaci\u00f3n/especi alizaci\u00f3n, se puede seguir uno de los \ndos procesos siguientes:\n1)Puede ocurrir que el dise\u00f1ador primero identifique la necesidad de la enti -\ndad superclase y, posterio rmente, reconozca las caracter\u00edsticas espec\u00edficas que \nhacen necesarias las entidades subclase. En estos casos se dice que ha seguido un proceso de especializaci\u00f3n .\n2)La alternativa es que el dise\u00f1ador mode lice en primer lugar las entidades sub -\nclase y, despu\u00e9s, se d\u00e9 cuenta de sus caracter\u00edsticas comunes e identifique la en -\ntidad superclase. Entonces se dice que ha seguido un proceso de generalizaci\u00f3n .a)La entidad superclase  nos permite modelizar las caracter\u00edsticas co -\nmunes de la entidad vista de una forma gen\u00e9rica.\nb)Las entidades subclase  nos permiten modelizar  las caracter\u00edsticas \npropias de sus especializaciones.\nEs necesario que se cumpla que toda ocurrencia de una entidad subclase sea tambi\u00e9n una ocurrencia de su entidad superclase.\n\uf8e9 FUOC \u2022 71Z799014MO 28 Introducci\u00f3n al dise\u00f1o de bases de datos\nLa generalizaci\u00f3n/especializac i\u00f3n puede ser de dos tipos: \na) Disjunta.  En este caso no puede suceder que una misma ocurrencia apa -\nrezca en dos entidades subclase difere ntes. Se denota gr\u00e1ficamente con la \netiqueta D.\nb) Solapada . En este caso no tiene lugar la restricci\u00f3n anterior. Se denota gr\u00e1 -\nficamente con la etiqueta S.\nAdem\u00e1s, una generalizaci\u00f3n/especi alizaci\u00f3n tambi\u00e9n puede ser: \n1) Total.  En este caso, toda ocurrencia de la entidad superclase debe pertene -\ncer a alguna de las entidades subclase. Esto se denota con la etiqueta T.\n2) Parcial.  En este caso no es necesario que se cumpla la condici\u00f3n anterior. Se \ndenota con la etiqueta P. \nLa generalizaci\u00f3n/especializaci\u00f3n de los empleados\nLa generalizaci\u00f3n/especializaci\u00f3n de los empleados es total porque suponemos que todo em -\npleado debe ser directivo, t\u00e9cnico o administrativo. Se denota con la etiqueta T.\n2.2.2. Entidades asociativas\nEn este subapartado vere mos un mecanismo que nos permite considerar una \ninterrelaci\u00f3n entre entidades como si fuese una entidad.\nLa utilidad de una entidad asociativa co nsiste en que se puede interrelacionar \ncon otras entidades y, de forma indirect a, nos permite tener interrelaciones en \nlas que intervienen interre laciones. Una entidad asociativa se denota recua -\ndrando el rombo de la interre laci\u00f3n de la que proviene. La entidad que resulta de considerar  una interrelaci\u00f3n entre entidades \ncomo si fuese una entidad es una entidad asociativa , y tendr\u00e1 el mismo \nnombre que la interrelaci\u00f3n  sobre la que se define.\nNuestro ejemplo  \nde los empleados...\n... corresponde a una generali-\nzaci\u00f3n/especializaci\u00f3n  \ndisjunta porque ning\u00fan  \nempleado puede ser de m\u00e1s  \nde un tipo. Se denota con la etiqueta D.\n\uf8e9 FUOC \u2022 71Z799014MO 29 Introducci\u00f3n al dise\u00f1o de bases de datos\nEjemplo de entidad asociativa\nLa figura siguiente muestra un ejemplo de entidad asociativa:\nRecorrido es una interrelaci\u00f3n de conectividad M:N que registra las ciudades por donde han \npasado los diferentes viajes organizados por una empresa de reparto de paquetes. Considera -\nmos recorrido  una entidad asociativa con el fin de interrelacionarla con la entidad cliente ; de \neste modo nos ser\u00e1 posible reflejar por orden de qu\u00e9 clientes se han hecho repartos en una \nciudad del recorrido de un viaj e, as\u00ed como el n\u00famero de paqu etes cargados y descargados si -\nguiendo sus indicaciones.\nEl mecanismo de las entidades asociativa s subsume el de las entidades d\u00e9biles \ny resulta todav\u00eda m\u00e1s potente. Es deci r, siempre que utilicemos una entidad \nd\u00e9bil podremos sustituirla por una en tidad asociativa, pero no al rev\u00e9s.\nEjemplo de sustituci\u00f3n de una entidad d\u00e9bil por una asociativa\nA continuaci\u00f3n se muestra la entidad d\u00e9bil despacho , que tiene la interrelaci\u00f3n asignaci\u00f3n  con \nla entidad empleado .\nPodr\u00edamos modelizar este caso haciendo que despacho  fuese una entidad asociativa si consi -\nderamos una nueva entidad n\u00famero-despacho  que contiene simplemente n\u00fameros de despa -\nchos. Entonces, la entidad asociativa despacho  se obtiene de la interrelaci\u00f3n entre edificio  y \nn\u00famero-despacho .\n\uf8e9 FUOC \u2022 71Z799014MO 30 Introducci\u00f3n al dise\u00f1o de bases de datos\nAunque las entidades d\u00e9biles se puedan sustituir por el mecanismo de las en -\ntidades asociativas, es adecuado mantener las en el modelo ER porque resultan \nmenos complejas y son suficientes para modelizar muchas de las situaciones que se producen en el mundo real. \n2.3. Ejemplo: base de datos del personal de una entidad bancaria\nEn este subapartado veremos un ejemplo de dise\u00f1o conceptual de una base de \ndatos mediante el modelo ER.\nSe trata de dise\u00f1ar una base de datos para la gesti\u00f3n del personal de una enti -\ndad bancaria determinada que dispone de muchos empleados y de una amplia red de agencias. La siguiente descripci\u00f3n resume los requisitos  de los usuarios \nde la futura base de datos:\na)Los empleados se identifican por un c\u00f3digo de empleado, y tambi\u00e9n desea -\nmos conocer su DNI, su NSS, su nombre  y su apellido. Ser\u00e1 importante regis -\ntrar su ciudad de residencia, considerando que hay ciudades donde no reside \nning\u00fan empleado.\nb)Interesa saber en qu\u00e9 ciudades est\u00e1n ubicadas las diversas agencias de la \nentidad bancaria. Estas agen cias bancarias se identifi can por la ciudad donde \nest\u00e1n y por un nombre que permite dist inguir las agencias de una misma ciu -\ndad. Se quiere tener constancia del n\u00famero de habitantes de las ciudades, as\u00ed \ncomo de la direcci\u00f3n y el n\u00famero de te l\u00e9fono de las agencias. Se debe consi -\n\uf8e9 FUOC \u2022 71Z799014MO 31 Introducci\u00f3n al dise\u00f1o de bases de datos\nderar que la base de datos tambi\u00e9n incluye ciudades donde no hay ninguna \nagencia.\nc)Un empleado, en un momento determinado, trabaja en una sola agencia, \nlo cual no impide que pueda ser trasladado a otra o, incluso, que vuelva a tra -\nbajar en una agencia donde ya hab\u00eda trab ajado anteriormente. Se quiere tener \nconstancia del historia l del paso de los empleados por las agencias.\nd)Los empleados pueden tener t\u00edtulos acad\u00e9micos (aunque no todos los tie -\nnen). Se quiere saber qu\u00e9 t\u00ed tulos tienen los empleados.\ne)Cada empleado tiene una categor\u00eda la boral determinada (auxiliar, oficial \nde segunda, oficial de primera, etc.). A cada categor\u00eda le corresponde un sueldo \nbase determinado y un prec io por hora extra tambi\u00e9n determinado. Se quiere \ntener constancia de la categor\u00eda actual de cada empleado, y del sueldo base y \nel precio de la hora ex tra de cada categor\u00eda. \nf)Algunos empleados (no todos) est\u00e1n afili ados a alguna cent ral sindical. Se \nha llegado al pacto de descontar de la n\u00f3mina mensual la cuota sindical a los \nafiliados a cada centra l. Esta cuota es \u00fanica para  todos los afiliados a una cen -\ntral determinada. Es nece sario almacenar las afiliacion es a una central de los \nempleados y las cuotas correspondientes a las diferentes centrales sindicales.\ng)Hay dos tipos de empleados diferentes:\n\u2022 Los que tienen contrato fijo, cu ya antig\u00fcedad queremos conocer.\n\u2022 Los que tienen contrato temporal, de lo s cuales nos interesa saber las fechas \nde inicio y finalizaci\u00f3n de su \u00faltimo contrato.\nSi un empleado temporal pasa a ser fijo, se le asigna un nuevo c\u00f3digo de emplea -\ndo; consideraremos que un empleado fijo nunca pasa a ser temporal. Todo lo que se ha indicado hasta ahora (traslados, categor\u00edas, afiliaci\u00f3n sindical, etc.) es \naplicable tanto a empleados fijos como a temporales.\nh)Los empleados fijos tienen la posibilid ad de pedir diferentes tipos preesta -\nblecidos de pr\u00e9stamos (por matrimonio , por adquisici\u00f3n de vivienda, por es -\ntudios, etc.), que pueden ser concedidos  o no. En principio, no hay ninguna \nlimitaci\u00f3n a la hora de pedir varios pr\u00e9s tamos a la vez, siempre que no se pida \nm\u00e1s de uno del mismo tipo al mismo tiem po. Se quiere regi strar los pr\u00e9stamos \npedidos por los empleados, y hacer consta r si han sido concedidos o no. Cada \ntipo de pr\u00e9stamo tiene establecidas di ferentes condiciones;  de estas condicio -\nnes, en particular, nos interesar\u00e1 saber el tipo de inter\u00e9s y el periodo de vigen -\ncia del pr\u00e9stamo.\uf8e9 FUOC \u2022 71Z799014MO 32 Introducci\u00f3n al dise\u00f1o de bases de datos\nLa siguiente figura muestra un diagra ma ER que satisfac e los requisitos an -\nteriores:\nLos atributos de las entidades que figuran en el diagrama son los siguientes (las \nclaves primarias se han subrayado):\nEMPLEADO\nc\u00f3digo-emplado , dni, nss, nombre, apellido\nFIJO (entidad subc lase de empleado)\nc\u00f3digo-empleado , antig\u00fcedad\nTEMPORAL (entidad su bclase de empleado)\nc\u00f3digo-empleado , fecha-inicio-cont,  fecha-final-cont\nCIUDAD\nnombre-ciudad , n\u00famero-hab\n\uf8e9 FUOC \u2022 71Z799014MO 33 Introducci\u00f3n al dise\u00f1o de bases de datos\nA continuaci\u00f3n, comentaremos los aspe ctos que pueden resultar m\u00e1s comple -\njos de este modelo ER:\n1)La entidad agencia se ha considerado una entidad d\u00e9bil porque su atributo \nnombre-agencia  s\u00f3lo permite distinguir las agen cias situadas en una misma ciu -\ndad, pero para identificar de forma total una agencia, es necesario saber en qu\u00e9 \nciudad est\u00e1 situada. De este modo, la interrelaci\u00f3n situaci\u00f3n  es la que nos per -\nmite completar la identi ficaci\u00f3n de la entidad agencia .\n2)La interrelaci\u00f3n petici\u00f3n  es ternaria y asocia a empleados fijos que hacen pe -\nticiones de pr\u00e9stamos, tipos de pr\u00e9sta mos pedidos por los empleados y fechas \nen las que se hacen estas peticiones.\n3)El lado de la entidad fecha  se conecta con \u201cmucho s\u201d porque un mismo em -\npleado puede pedir un mismo tipo de pr\u00e9stamo varias veces en fechas distin -\ntas. La entidad fijo s e  c o n e c t a  c o n  \u201c m u c h o s \u201d  p o r q u e  u n  t i p o  d e  p r \u00e9 s t a m o  \ndeterminado puede ser pedido en una misma fecha por va rios empleados. \nTambi\u00e9n la entidad tipo-pr\u00e9stamo  se conecta con \u201cmuchos\u201d porque es posible \nque un empleado en una fecha determinad a pida m\u00e1s de un pr\u00e9stamo de tipo \ndiferente.\n4)El atributo concedido/no  indica si el pr\u00e9stamo se ha concedido o no. Es un \natributo de la interrelaci\u00f3n porque su  valor depende al mismo tiempo del em -\npleado fijo que hace la petici\u00f3n, del tipo de pr\u00e9stamo pedido y de la fecha de \npetici\u00f3n.\n5)La interrelaci\u00f3n traslado  tambi\u00e9n es una interrelaci\u00f3n ternaria que permite re -\ngistrar el paso de los empleados por las distintas agencias. Un traslado concreto \nasocia a un empleado, una agencia donde \u00e9l trabajar\u00e1 y una fecha inicial en la que \nempieza a trabajar en la agencia. El atributo de la interrelaci\u00f3n fecha-fin  indica en \nqu\u00e9 fecha finaliza su asignaci\u00f3n a la agencia ( fecha-fin  tendr\u00e1 el valor nulo cuando AGENCIA (entidad d\u00e9bil: nombre-age ncia la identifi ca parcialmente,\nse identifica comp letamente con la ci udad de situaci\u00f3n)\nnombre-agencia , direcci\u00f3n, tel\u00e9fono\nT\u00cdTULO\nnombre-t\u00edtulo\nCATEGOR\u00cdA\nnombre-categ , sueldo-base, hora-extra\nCENTRAL-SINDICAL\ncentral , cuota\nTIPO-PR\u00c9STAMO\nc\u00f3digo-pr\u00e9stamo , tipo-inter\u00e9s, per\u00edodo-vigencia\nFECHA\nfecha\uf8e9 FUOC \u2022 71Z799014MO 34 Introducci\u00f3n al dise\u00f1o de bases de datos\nun empleado trabaja en una agencia en el momento actual y no se sabe cu\u00e1ndo \nse le trasladar\u00e1). Observad que  fecha-fin  debe ser un atributo de la interrelaci\u00f3n. Si \nse colocase en una de las tres entidades interrelacionadas, no podr\u00eda ser un atribu -\nto univaluado.\nConviene observar que esta interrelaci\u00f3n  no registra todas y cada una de las \nfechas en las que un empleado est\u00e1 asig nado a una agencia, sino s\u00f3lo la fecha \ninicial y la fecha final de la asignaci\u00f3n . Es muy habitual qu e, para informacio -\nnes que son ciertas durante todo un periodo de tiempo, se registre en la base \nde datos \u00fanicamente el inic io y el final del periodo.\nNotad que la entidad agencia  se ha conectad o con \u201cuno\u201d en la interrelaci\u00f3n \ntraslado , porque no puede ocurrir que, en una fecha, un empleado determina -\ndo sea trasladado a m\u00e1s de una agencia.\n6)Finalmente, comentaremos la generalizaci\u00f3n/especia lizaci\u00f3n de la entidad \nempleado . Los empleados pueden ser de dos tipos; se quieren registrar propie -\ndades diferentes para cada uno de lo s tipos y tambi\u00e9n se requieren algunas \npropiedades comunes a todos los empleados. Por este motivo, es adecuado uti -\nlizar una generalizaci\u00f3n/especializaci\u00f3n.\uf8e9 FUOC \u2022 71Z799014MO 35 Introducci\u00f3n al dise\u00f1o de bases de datos\n3. Dise\u00f1o l\u00f3gico: la transformaci\u00f3n del modelo ER  \nal modelo relacional\nEn este apartado trataremos el dise\u00f1o l\u00f3gico de una base de datos relacional. \nPartiremos del resultado de la etapa del dise\u00f1o conceptual expresado median -\nte el modelo ER y veremos c\u00f3mo se puede transformar en una estructura de datos del modelo relacional. \n3.1. Introducci\u00f3n a la tran sformaci\u00f3n de entidades  \ne interrelaciones\nEn el caso de las interrelaciones, es necesario tener en cuenta su grado y su co -\nnectividad para poder decidir cu\u00e1l es la transformaci\u00f3n adecuada:\n1)Las interrelaciones binarias 1:1 y 1:N dan lugar a cl aves for\u00e1neas.\n2)Las interrelaciones bina rias M:N y todas las n-arias se traducen en nuevas \nrelaciones.\nEn los subapartados siguie ntes explicaremos de form a m\u00e1s concreta las trans -\nformaciones necesarias para obtener un esquema relacional a partir de un mo -\ndelo ER. M\u00e1s adelante proporcionamos una tabla que resume los aspectos  m\u00e1s \nimportantes de cada una de las transformaciones para dar una visi\u00f3n global \nsobre ello. Finalmente, describimos su aplicaci\u00f3n en un ejemplo. \n3.2. Transformaci\u00f3n de entidadesLos elementos b\u00e1sicos del modelo ER son las entidades y las interre -\nlaciones:\na)Las entidades, cuando se traducen al modelo relacional, originan re-\nlaciones .\nb)Las interrelaciones, en cambio, cu ando se transforman, pueden dar \nlugar a claves for\u00e1neas  de alguna relaci\u00f3n ya obtenida o pueden dar \nlugar a una  nueva relaci\u00f3n .\nEmpezaremos el proceso transformando todas las entidades de un mo -\ndelo ER adecuadamente. Cada entidad del modelo ER se transforma en \nuna relaci\u00f3n del modelo relacional. Los atributos de la entidad ser\u00e1n \natributos de la relaci\u00f3n y, de forma an\u00e1loga, la clave primaria de la en -\ntidad ser\u00e1 la clave prim aria de la relaci\u00f3n.\nEncontrar\u00e9is la tabla de las \ntransformaciones en el subapartado 3.10. de esta unidad; en el subapartado 3.11. veremos el ejemplo de aplicaci\u00f3n.\n\uf8e9 FUOC \u2022 71Z799014MO 36 Introducci\u00f3n al dise\u00f1o de bases de datos\nEjemplo de transformaci\u00f3n de una entidad\nSeg\u00fan esto, la entidad de la figura del margen se transforma en la relaci\u00f3n que tenemos a con -\ntinuaci\u00f3n:\nSi una entidad interviene en alguna in terrelaci\u00f3n binaria 1:1 o 1:N, puede ser \nnecesario a\u00f1adir nuevos atributos a la relaci\u00f3n obtenida a partir de la entidad. \nEstos atributos formar\u00e1n claves  for\u00e1neas de la relaci\u00f3n. \n3.3. Transformaci\u00f3n de interrelaciones binarias\nPara transformar una interrelaci\u00f3n binari a es necesario tene r en cuenta su co -\nnectividad, y si las entidades son obligat orias u opcionales en la interrelaci\u00f3n.\n3.3.1. Conectividad 1:1\nEjemplo de transformaci\u00f3n de una interrelaci\u00f3n binaria 1:1EMPLEADO( DNI, NSS, nombre, apellido, sueldo)\nUna vez transformadas todas las entida des en relaciones, es preciso trans -\nformar todas las interrelaciones en las que intervienen estas entidades.\nNuestro punto de partida es que las entidades que intervienen en la in -\nterrelaci\u00f3n 1:1 ya se han transformado en relaciones con sus correspon -\ndientes atributos.\nEntonces s\u00f3lo ser\u00e1 necesario a\u00f1adir a cualquiera de estas dos relaciones \nuna clave for\u00e1nea que refere ncie a la otra relaci\u00f3n.\nVeremos las transformaciones  \nde las interrelaciones binarias  \nen el siguiente subapartado.\n\uf8e9 FUOC \u2022 71Z799014MO 37 Introducci\u00f3n al dise\u00f1o de bases de datos\nPara la interrelaci\u00f3n de la figura anterior, tenemos dos opciones de transformaci\u00f3n:\n\u2022 Primera opci\u00f3n:\n\u2022 Segunda opci\u00f3n:\nAmbas transformaciones nos permiten saber en  qu\u00e9 ciudad hay una delegaci\u00f3n, y qu\u00e9 dele -\ngaci\u00f3n tiene una ciudad. De este  modo, reflejan correctamente el  significado de la interrela -\nci\u00f3n situaci\u00f3n  del modelo ER.\nEn la primera transformaci\u00f3n, dado que una dele gaci\u00f3n est\u00e1 situada en una sola ciudad, el \natributo nombre-ciudad  tiene un \u00fanico valor para cada valor de la clave primaria { nombre-del }. \nObservad que, si pudiese tener varios valores, la  soluci\u00f3n no ser\u00eda correcta seg\u00fan la teor\u00eda re -\nlacional.\nEn la segunda transformaci\u00f3n, teniendo en cuenta que una ciudad tiene una sola delega -\nci\u00f3n, el atributo nombre-del  tambi\u00e9n toma un solo valor para cada valor de la clave primaria \n{nombre-ciudad }.\nTambi\u00e9n es necesario tener en cuenta que, en las dos transformaciones , la clave for\u00e1nea que \nse les a\u00f1ade se convierte en una clave alternat iva de la relaci\u00f3n porque no admite valores \nrepetidos. Por ejemplo, en la segunda trans formaci\u00f3n no puede haber m\u00e1s de una ciudad \ncon la misma delegaci\u00f3n; de este modo, nombre-del debe ser diferente para todas las tuplas \nde CIUDAD .\n3.3.2. Conectividad 1:N\nEjemplo de transformaci\u00f3n de una interrelaci\u00f3n binaria 1:NDELEGACI\u00d3N( nombre-del , ..., nombre-ciudad)\ndonde {nombre-ciudad} referencia CIUDAD\nCIUDAD( nombre-ciudad , ...)\nDELEGACI\u00d3N( nombre-del , ...)\nCIUDAD( nombre-ciudad , ..., nombre-del)\ndonde {nombre-del} referencia DELEGACI\u00d3N\nPartimos del hecho de que las entidades que intervienen en la interrela -\nci\u00f3n 1:N ya se han trasformado en relaciones con sus correspondientes \natributos. En este caso s\u00f3lo es nece sario a\u00f1adir en la relaci\u00f3n correspon -\ndiente a la entidad del lado N, una cl ave for\u00e1nea que referencie la otra re -\nlaci\u00f3n.\n\uf8e9 FUOC \u2022 71Z799014MO 38 Introducci\u00f3n al dise\u00f1o de bases de datos\nLa interrelaci\u00f3n de la figura  anterior se transforma en:\nEsta soluci\u00f3n nos permite saber en qu\u00e9 despac ho est\u00e1 asignado cada empleado, y tambi\u00e9n \nnos permite consultar, para cada despacho, qu \u00e9 empleados hay. Es decir, refleja correctamen -\nte el significado de la interrelaci\u00f3n asignaci\u00f3n .\nTeniendo en cuenta que un empleado est\u00e1 asignado a un \u00fanico despacho, el atributo desp\ntiene un valor \u00fanico para cada valor de la clave primaria { emp}. Si hubi\u00e9semos puesto la \nclave for\u00e1nea { emp} en la relaci\u00f3n DESPACHO , la soluci\u00f3n habr\u00eda sido incorrecta, porque \nemp habr\u00eda tomado varios valores, uno para cada uno de los distintos empleados que pue -\nden estar asignados a un despacho.\n3.3.3. Conectividad M:N\nEjemplo de transformaci\u00f3n de una interrelaci\u00f3n binaria M:N\nLa interrelaci\u00f3n de la figura  anterior se transforma en:\nObservad que la clave de evaluacion  debe constar tanto de la clave de estudiante  como de la \nclave de asignatura para identificar comple tamente la relaci\u00f3n.\nLa soluci\u00f3n que hemos presentado re fleja correctamente la interrelaci\u00f3n evaluaci\u00f3n  y su atri -\nbuto nota. Permite saber, para cada estudiante, qu\u00e9 notas obtiene de las varias asignaturas y, \npara cada asignatura, qu\u00e9 notas tienen los diferentes es tudiantes de aquella asignatura.DESPACHO( desp, ...)\nEMPLEADO( emp, ..., desp)\ndonde {desp}referencia DESPACHO\nUna interrelaci\u00f3n M:N se transforma en una relaci\u00f3n. Su clave primaria \nestar\u00e1 formada por los atributos de la  clave primaria de las dos entidades \ninterrelacionadas. Los atributos de la interrelaci\u00f3n ser\u00e1n atributos de la \nnueva relaci\u00f3n.\nESTUDIANTE(est, ...)\nASIGNATURA( asig, ...)\nEVALUACI\u00d3N( est,asig , nota)\ndonde {est} referencia ESTUDIANTE\ny {asig} referencia ASIGNATURA\n\uf8e9 FUOC \u2022 71Z799014MO 39 Introducci\u00f3n al dise\u00f1o de bases de datos\nEn el caso M:N no podemos utilizar clav es for\u00e1neas para transformar la inte -\nrrelaci\u00f3n, porque obtendr\u00ed amos atributos que necesitar\u00edan tomar varios valo -\nres, y esto no se permite en el modelo relacional. \n3.3.4. Influencia de la dependencia de existencia  \nen la transformaci\u00f3n de las interrelaciones binarias\nLa dependencia de existencia, o m\u00e1s co ncretamente, el hecho de que alguna \nde las entidades sea opcional en una interrelaci\u00f3n se debe tener en cuenta al \nhacer la transformaci\u00f3n de algunas relaciones binarias 1:1 y 1:N.\nEjemplo de transformaci\u00f3n de una entidad opcional en la interrelaci\u00f3n\nEn el ejemplo siguiente, la entidad departamento  es opcional en direcci\u00f3n  y, por lo tanto, pue -\nde haber empleados que no sean di rectores de ning\u00fan departamento.\nEn principio, hay dos opciones de transformaci\u00f3n:\n\u2022 Primera opci\u00f3n:\n\u2022 Segunda opci\u00f3n:\nLa segunda transformaci\u00f3n da lugar a una clav e for\u00e1nea que puede tomar valores nulos (por -\nque puede haber empleados que no  son directores de ning\u00fan de partamento). Entonces ser\u00e1 \npreferible la primera transforma ci\u00f3n, porque no provoca la apar ici\u00f3n de valores nulos en la \nclave for\u00e1nea y, de este modo, nos ahorra espacio de almacenamiento.Si una de las entidades es opcional en la interrelaci\u00f3n, y la transforma -\nci\u00f3n ha consistido en poner una clave for\u00e1nea en la relaci\u00f3n que corres -\nponde a la otra entidad, entonces es ta clave for\u00e1nea puede tomar valores \nnulos.\nDEPARTAMENTO( dep, ..., emp-dir)\ndonde {emp-dir} referencia EMPLEADO\nEMPLEADO( emp, ...)\nDEPARTAMENTO( dep, ...)\nEMPLEADO( emp, ..., dep)\ndonde {dep} referencia DEPARTAMENTO\ny dep puede tomar valores nulos\n\uf8e9 FUOC \u2022 71Z799014MO 40 Introducci\u00f3n al dise\u00f1o de bases de datos\nEn las interrelaciones 1:N, el hecho de que la entidad del lado 1 sea opcional \ntambi\u00e9n provoca que la clave for\u00e1nea de la transformaci\u00f3n pueda tener valo -\nres nulos. En este caso, sin embargo, no  se pueden evitar estos valores nulos \nporque hay una \u00fanica transformaci\u00f3n posible.\n3.4. Transformaci\u00f3n de interrelaciones ternarias\nLa transformaci\u00f3n de las interrelaciones ternarias pr esenta similitudes impor -\ntantes con la transformaci\u00f3n de las bina rias M:N. No es posible representar la \ninterrelaci\u00f3n mediante claves for\u00e1neas, sino que es necesario usar una nueva relaci\u00f3n. Para que la nueva relaci\u00f3n re fleje toda la informaci\u00f3n que modeliza \nla interrelaci\u00f3n, es necesa rio que contenga las claves primarias de las tres en\n-\ntidades interrelacionad as y los atributos de la interrelaci\u00f3n.\nA continuaci\u00f3n analizaremos cu\u00e1l debe ser la clave primaria de la nueva rela -\nci\u00f3n seg\u00fan la conectividad. Empezaremos por el caso M:N:P y acabaremos con \nel caso 1:1:1. \n3.4.1. Conectividad M:N:P\nEjemplo de transformaci\u00f3n de una interrelaci\u00f3n ternaria M:N:P\nAnalizaremos la transformaci\u00f3n con un ejemplo:As\u00ed pues, la transformaci\u00f3n de una interrelaci\u00f3n ternaria siempre da lu -\ngar a una nueva relaci\u00f3n, que tendr\u00e1 como atributos las claves primarias \nde las tres entidades interrelacionadas y todos los atributos que tenga la interrelaci\u00f3n. La clave primaria de la nueva relaci\u00f3n depende de la co\n-\nnectividad de la interrelaci\u00f3n.\nCuando la conectividad de la interrel aci\u00f3n es M:N:P, la relaci\u00f3n que se ob -\ntiene de su transformaci\u00f3n tiene como  clave primaria todos los atributos \nque forman las claves primarias de las tres entidades interrelacionadas.\n\uf8e9 FUOC \u2022 71Z799014MO 41 Introducci\u00f3n al dise\u00f1o de bases de datos\nLa interrelaci\u00f3n anteri or se transforma en:\nPara identificar completamente la relaci\u00f3n , la clave debe constar de la clave de estudiante , \nde la clave de asignatura  y de la clave de semestre . Si nos faltase una de las tres, la clave de \nla relaci\u00f3n podr\u00eda tener valo res repetidos. Consideremos, por  ejemplo, que no tuvi\u00e9semos \nla clave de semestre . Dado que semestre  est\u00e1 conectada con \u201cmuchos\u201d en la interrelaci\u00f3n, \npuede haber estudiantes que han sido evaluado s de una misma asignatura en m\u00e1s de un \nsemestre. Entonces, para estos casos habr\u00eda valores repetidos en la clave de la relaci\u00f3n \nEVALUACION-SEMESTRAL .\nObservad que, del mismo modo que es necesaria la clave de semestre, tambi\u00e9n lo son la de \nestudiante  y la de asignatura .\n3.4.2. Conectividad M:N:1\nEjemplo de transformaci\u00f3n de una interrelaci\u00f3n ternaria M:N:1\nLo ilustraremos con un ejemplo:\nEsta interrelaci\u00f3n refleja los destinos que se dan a los maestros de escuela en los diferentes \ncursos. El 1 que figura en el lado de escuela  significa que un maestro no puede ser destinado \na m\u00e1s de una escuela en un mismo curso.\nEl ejemplo de la figura se transforma en:ESTUDIANTE( est, ...)\nASIGNATURA( asig, ...)\nSEMESTRE( sem, ...)\nEVALUACI\u00d3N-SEMESTRAL( est, asig, sem, nota)\ndonde {est} referencia ESTUDIANTE,\n{asig} referencia ASIGNATURA\ny {sem} referencia SEMESTRE\nCuando la conectividad de  la interrelaci\u00f3n es M:N:1, la relaci\u00f3n que se \nobtiene de su transformaci\u00f3n tiene como clave primaria todos los atri -\nbutos que forman las claves primaria s de las dos entidades de los lados \nde la interrelaci\u00f3n et iquetados con M y con N.\nMAESTRO( c\u00f3digo-maestro , ...)\nCURSO( c\u00f3digo-curso , ...)\nESCUELA( c\u00f3digo-esc , ...)\nDESTINO( c\u00f3digo-maestro, c\u00f3digo-curso , c\u00f3digo-esc)\ndonde {c\u00f3digo-maestro} referencia MAESTRO\n{c\u00f3digo-curso} referencia CURSO\ny {c\u00f3digo-esc} referencia ESCUELA\n\uf8e9 FUOC \u2022 71Z799014MO 42 Introducci\u00f3n al dise\u00f1o de bases de datos\nNo es necesario que la clave incluya c\u00f3digo-esc  para identificar completamente la relaci\u00f3n. Si \nse fijan un maestro y un curso, no puede haber m\u00e1s de una escuela de destino y, por lo tanto, \nno habr\u00e1 claves repetidas.\n3.4.3. Conectividad N:1:1\nAs\u00ed pues, hay dos posibles claves para la relaci\u00f3n que se obtiene. Son dos claves \ncandidatas entre las cuales el dise\u00f1ador deber\u00e1 escoger la primaria.\nEjemplo de transformaci\u00f3n de una interrelaci\u00f3n ternaria N:1:1\nVeamos un ejemplo de ello:\n1)Una posible transformaci\u00f3n es la siguiente:\nEn este caso, la clave, a pesar de no incluir el atributo asig, identifica completamente la rela -\nci\u00f3n porque para una hora-semanal y un aula determinadas hay una \u00fanica asignatura de la \nque se hace clase a esa hora y en esa aula.\n2) La segunda transformaci\u00f3 n posible es esta otra:Cuando la conectividad de  la interrelaci\u00f3n es N:1: 1, la relaci\u00f3n que se \nconsigue de su transformaci\u00f3n tiene como clave primaria los atributos que forman la clave primaria de la entidad del lado N y los atributos que \nforman la clave primaria de cualquiera de las dos entidades que est\u00e1n conectadas con 1.\nHORA-SEMANAL( c\u00f3digo-hora , ...)\nAULA( c\u00f3digo-aula , ...)\nASIGNATURA( asig, ...)\nCLASE ( c\u00f3digo-hora, c\u00f3digo-aula , asig, duraci\u00f3n)\ndonde {c\u00f3digo-hora} referencia HORA-SEMANAL,\n{c\u00f3digo-aula} referencia AULA\ny {asig} referencia ASIGNATURA\nHORA-SEMANAL( c\u00f3digo-hora , ...)\nAULA( c\u00f3digo-aula , ...)\nASIGNATURA( asig, ...)\nCLASE ( c\u00f3digo-hora, c\u00f3digo-aula, asig, duraci\u00f3n)\ndonde {c\u00f3digo-hora} referencia HORA-SEMANAL,\n{c\u00f3digo-aula} referencia AULA\ny {asig} referencia ASIGNATURA\n\uf8e9 FUOC \u2022 71Z799014MO 43 Introducci\u00f3n al dise\u00f1o de bases de datos\nAhora la clave incluye el atributo  asig y, en cambio, no incluye el atributo c\u00f3digo-aula . La re -\nlaci\u00f3n tambi\u00e9n queda completamente identifica da porque, para una asignatura y hora-sema -\nnal determinadas, de aq uella asignatura se da clase en  una sola aula a aquella hora.\n3.4.4. Conectividad 1:1:1\nAs\u00ed pues, hay tres claves ca ndidatas para la relaci\u00f3n.\nEjemplo de transformaci\u00f3n de una interrelaci\u00f3n ternaria 1:1:1\nVeamos un ejemplo de ello:\nEsta interrelaci\u00f3n registra inform aci\u00f3n de defensas de proyectos de fin de carrera. Intervienen \nen ella el estudiante que presenta el proyecto , el proyecto presentado y el tribunal evaluador.\nLa transformaci\u00f3n del ejemplo anterior se muestra a continuaci\u00f3n:\nPara la nueva relaci\u00f3n DEFENSA, tene mos las tres posibilidades siguientes:\n\u2022 Primera opci\u00f3n:\n\u2022 Segunda opci\u00f3n:Cuando la conectividad de la interrela ci\u00f3n es 1:1:1, la relaci\u00f3n que se \nobtiene de su transformaci\u00f3n tiene como clave primaria los atributos que forman la clave primaria de dos entidades cualesquiera de las tres interrelacionadas.\nTRIBUNAL( trib, ...)\nESTUDIANTE( est, ...)\nPROYECTO-FIN-CARRERA( pro, ...)\nDEFENSA( trib, est , pro, fecha-defensa)\ndonde {trib} referencia TRIBUNAL,\n{est} referencia ESTUDIANTE\ny {pro} referencia PROYECTO-FIN-CARRERA\nDEFENSA( trib, pro , est, fecha-defensa)\ndonde {trib} referencia TRIBUNAL,\n{est} referencia ESTUDIANTE\ny {pro} referencia PROYECTO-FIN-CARRERA\nHemos considerado que, \u2026\n... si dos estudiantes presentan \nun mismo proyecto de fin de carrera, el tribunal ser\u00e1 necesa-riamente diferente.\uf8e9 FUOC \u2022 71Z799014MO 44 Introducci\u00f3n al dise\u00f1o de bases de datos\n\u2022 Tercera opci\u00f3n:\nEn los tres casos, es posible comprobar que la clave identifica completamente la relaci\u00f3n si \nse tiene en cuenta la conect ividad de la interrelaci\u00f3n defensa .\n3.5. Transformaci\u00f3n de interrelaciones n-arias\nLa transformaci\u00f3n de las interrelaciones n-arias se puede ver como una gene -\nralizaci\u00f3n de lo que hemos ex plicado para las ternarias. \nPodemos distinguir los casos siguientes:\na)Si todas las entidades est\u00e1n conectadas  con \u201cmuchos\u201d, la clave primaria de \nla nueva relaci\u00f3n estar\u00e1 formada por todos los atribu tos que forman las claves \nde las n entidades interrelacionadas.\nb)Si una o m\u00e1s entidades est\u00e1n conectadas con \u201cuno\u201d, la clave primaria de la \nnueva relaci\u00f3n estar\u00e1 fo rmada por las claves de n \u2013 1 de las entidades interre -\nlacionadas, con la condici\u00f3n de que la entidad, cuya clave no se ha incluido, \ndebe ser una de las que est\u00e1 conectada con \u201cuno\u201d.\n3.6. Transformaci\u00f3n de interrelaciones recursivas\nLas transformaciones de las interrelacio nes recursivas son similares a las que \nhemos visto para el rest o de las interrelaciones.DEFENSA( est, pro , trib, fecha-defensa)\ndonde {trib} referencia TRIBUNAL,\n{est} referencia ESTUDIANTE\ny {pro} referencia PROYECTO-FIN-CARRERA\nEn todos los casos, la transf ormaci\u00f3n de una interrelaci\u00f3n n-aria consis -\ntir\u00e1 en la obtenci\u00f3n de una nueva re laci\u00f3n que contiene todos los atribu -\ntos que forman las claves primarias de las n entidades interrelacionadas y \ntodos los atributos de la interrelaci\u00f3n.\nDe este modo, si una interrelaci\u00f3n re cursiva tiene conectividad 1:1 o 1:N, \nda lugar a una clave for\u00e1nea, y si tiene conectividad M:N o es n-aria, ori -\ngina una nueva relaci\u00f3n.\n\uf8e9 FUOC \u2022 71Z799014MO 45 Introducci\u00f3n al dise\u00f1o de bases de datos\nMostraremos la transformaci\u00f3n de algu nos ejemplos concretos de interrelacio -\nnes recursivas para ilustrar los de talles de la afirmaci\u00f3n anterior. \nEjemplo de transformaci\u00f3n de una interrelaci\u00f3n recursiva binaria 1:1\nLa interrelaci\u00f3n de la figura anterior es recu rsiva, binaria y tiene conectividad 1:1. Las in -\nterrelaciones 1:1 originan una clave for\u00e1nea que se pone en la relaci\u00f3n correspondiente \na una de las entidades interrelacionadas. En  nuestro ejemplo, s\u00f3lo hay una entidad inte -\nrrelacionada, la entidad persona . Entonces, la clave for\u00e1nea deber\u00e1 estar en la relaci\u00f3n \nPERSONA . Esta clave for\u00e1nea deber\u00e1 referenciar a la misma relaci\u00f3n para que refleje una \ninterrelaci\u00f3n entre una ocurrencia de persona y otra ocurrencia de persona. As\u00ed, obten -\ndremos:\nLa clave for\u00e1nea { c\u00f3digo-conyuge } referencia la relaci\u00f3n PERSONA  a la que pertenece.\nConviene tener en cuenta que, en casos como  \u00e9ste, los atributos de la clave for\u00e1nea no \npueden tener los mismos nombres que los atri butos de la clave primaria que referencian \nporque, seg\u00fan la teor\u00eda relacional, una rela ci\u00f3n no puede tener nombres de atributos re -\npetidos.\nEjemplo de transformaci\u00f3n de una interrelaci\u00f3n recursiva M:N\nVeamos a continuaci\u00f3n un ejemplo en el que interviene una interrelaci\u00f3n recursiva y con \nconectividad M:N.\nLas interrelaciones M:N se traducen en nuevas re laciones que tienen como clave primaria las \nclaves de las entida des interrelacionadas.\nEn nuestro ejemplo, la interrelaci\u00f3n vincula oc urrencias de persona con otras ocurrencias de \npersona . En este caso, la clave primaria de la nuev a relaci\u00f3n estar\u00e1 formada por la clave de la PERSONA ( c\u00f3digo-per , ..., c\u00f3digo-conyuge)\ndonde {c\u00f3digo-conyuge} referencia PERSONA\ny c\u00f3digo-conyuge admite valores nulos\n\uf8e9 FUOC \u2022 71Z799014MO 46 Introducci\u00f3n al dise\u00f1o de bases de datos\nentidad persona  dos veces. Convendr\u00e1 dar nombres difere ntes a todos los atributos de la nue -\nva relaci\u00f3n. De este modo, la traducci\u00f3n del ejemplo anterior ser\u00e1:\nEjemplo de transformaci\u00f3n de  una interrelaci\u00f3n recursiva n-aria N:1:1\nFinalmente, analizaremos un ejemplo en el que la interrelaci\u00f3n recursiva es n-aria:\nLa anterior interrelaci\u00f3n boda es recursiva, ternaria y tiene conectividad N:1:1. Las inte -\nrrelaciones N:1:1 originan siempre una nueva relaci\u00f3n que contiene, adem\u00e1s de los atri -\nbutos de la interrelaci\u00f3n, todos los atributo s que forman la clave primaria de las tres \nentidades interrelacionadas.\nEn nuestro ejemplo, la interrelaci\u00f3n asocia ocurrencias de persona  con otras ocurrencias de \npersona  y con ocurrencias de fecha . Entonces, la clave de persona  tendr\u00e1 que figurar dos veces \nen la nueva relaci\u00f3n, y la clave de fecha , solo una.\nLa clave primaria de la relaci\u00f3n que se obtien e para interrelaciones N: 1:1 est\u00e1 formada por la \nclave de la entidad del lado N y por la cl ave de una de las enti dades de los lados 1.\nEn nuestro ejemplo, en los dos lados 1 de la interrelaci\u00f3n tenemos la misma entidad: persona . \nLa clave primaria estar\u00e1 formad a por la clave de la entidad fecha  y por la clave de la entidad \npersona .\nSeg\u00fan todo esto, la transformaci\u00f3n ser\u00e1 la siguiente:\n3.7. Transformaci\u00f3n de entidades d\u00e9bilesPERSONA ( c\u00f3digo-per , ...)\nAMISTAD ( c\u00f3digo-per , c\u00f3digo-per-amiga )\ndonde {c\u00f3digo-per} referencia PERSONA\ny {c\u00f3digo-per-amiga} referencia PERSONA\nPERSONA( c\u00f3digo-per , ...)\nFECHA( fecha-bod , ...)\nBODA ( fecha-bod, c\u00f3digo-per , c\u00f3digo-conyuge)\ndonde {fecha-bod} referencia FECHA,\n{c\u00f3digo-per} referencia PERSONA\ny {c\u00f3digo-conyuge} referencia PERSONA\nLas entidades d\u00e9biles se traducen al modelo relacional igual que el resto \nde entidades, con una peque\u00f1a difere ncia. Estas entidades siempre est\u00e1n \nen el lado N de una interrelaci\u00f3n 1:N que completa su identificaci\u00f3n.\nAs\u00ed pues, la clave for\u00e1nea originada por esta interrelaci\u00f3n 1:N debe for -\nmar parte de la clave primaria de la  relaci\u00f3n correspondiente a la enti -\ndad d\u00e9bil.\n\uf8e9 FUOC \u2022 71Z799014MO 47 Introducci\u00f3n al dise\u00f1o de bases de datos\nEjemplo de transformaci\u00f3n de entidad d\u00e9bil\nLo explicaremos con un ejemplo:\nEste ejemplo se transforma tal y como se muestra a continuaci\u00f3n:\nObservad que la clave for\u00e1nea { nombre } forma parte tambi\u00e9n de la clave primaria de DESPA -\nCHO. Si no fuese as\u00ed, y la clave prim aria contuviese s\u00f3lo el atributo n\u00famero , los despachos no \nquedar\u00edan totalmente identifica dos, teniendo en cuenta que puede haber despachos situados \nen edificios diferentes que tengan el mismo n\u00famero.\n3.8. Transformaci\u00f3n de la ge neralizaci\u00f3n/especializaci\u00f3n\nEjemplo de transformaci\u00f3n de la generalizaci\u00f3n/especializaci\u00f3n\nVeamos un ejemplo (consultad el gr\u00e1fico en la  p\u00e1gina siguiente) que contiene una generali -\nzaci\u00f3n/especializaci\u00f3n y, tambi\u00e9n, una interrel aci\u00f3n M:N en la que interviene una de las en -\ntidades subclase. Este ejemplo se traduce al mode lo relacional como se indica a continuaci\u00f3n:EDIFICIO( nombre , direcci\u00f3n)\nDESPACHO( nombre, n\u00famero , superficie)\ndonde {nombre} referencia EDIFICIO\nCada una de las entidades superclase y subclase que forman parte de \nuna generalizaci\u00f3n/especializaci\u00f3n se transforma en una relaci\u00f3n:\na)La relaci\u00f3n de la entidad superclase  tiene como clave primaria la cla -\nve de la entidad superclase y co ntiene todos los atributos comunes.\nb)Las relaciones de las entidades subc lase tienen como  clave primaria \nla clave de la entidad superclase y contienen los atri butos espec\u00edficos \nde la subclase.\nEMPLEADO( DNI, nombre, direcci\u00f3n, tel\u00e9fono)\nDIRECTIVO( DNI, coche)\ndonde {DNI} referencia EMPLEADO\n\uf8e9 FUOC \u2022 71Z799014MO 48 Introducci\u00f3n al dise\u00f1o de bases de datos\nConviene observar que los atributos co munes se han situado en la relaci\u00f3n EMPLEADO  y que \nlos atributos espec\u00edficos se han situado en la relaci\u00f3n de su entidad subclase. De este modo, \ncoche  est\u00e1 en DIRECTIVO , t\u00edtulo  en T\u00c9CNICO  y antig\u00fcedad  en ADMINISTRATIVO .\nPor otro lado, la in terrelaci\u00f3n espec\u00edfica para los empleados t\u00e9cnicos denominada trabaja \nse transforma en la relaci\u00f3n TRABAJA . Observad que esta relaci \u00f3n tiene una clave for\u00e1nea \nque referencia s\u00f3lo a los empl eados t\u00e9cnicos, y no a los empl eados directivos o administra -\ntivos.\n3.9. Transformaci\u00f3n de entidades asociativas\nEjemplo de transformaci\u00f3n de una entidad asociativa\nVeamos un ejemplo, que incluye una entidad asociativa interrelacion ada con otra entidad:ADMINISTRATIVO ( DNI, antig\u00fcedad)\ndonde {DNI} referencia EMPLEADO\nT\u00c9CNICO ( DNI, t\u00edtulo)\ndonde {DNI} referencia EMPLEADO\nPROYECTO( pro, ...)\nTRABAJA( DNI, pro , superficie)\ndonde {DNI} referencia T\u00c9CNICO\ny {pro} referencia PROYECTO\nUna entidad asociativa tiene su orig en en una interrelaci\u00f3n. En conse -\ncuencia, sucede que la transformaci\u00f3n  de la interrelaci\u00f3n originaria es, \nal mismo tiempo, la transformaci\u00f3n de la entidad asociativa.\n\uf8e9 FUOC \u2022 71Z799014MO 49 Introducci\u00f3n al dise\u00f1o de bases de datos\nLa transformaci\u00f3n del ejemplo anterior ser\u00e1:\nTal y como se puede observar, la traducci\u00f3n de la interrelaci\u00f3n recorrido  es, al mismo tiempo, \nla traducci\u00f3n de su entidad asociativa.\nLa relaci\u00f3n REPARTO  nos ilustra la transformaci\u00f3n de una interrelaci\u00f3n en la que participa \nuna entidad asociativa. Puesto que se trata de una interrelaci\u00f3n M:N entre recorrido  y ciudad , \nuna parte de la clave primaria de REPARTO  referencia la clave de RECORRIDO , y el resto, la \nclave de CIUDAD .\n3.10. Resumen de la transformaci\u00f3n del modelo ER  \nal modelo relacional\nLa tabla que mostramos a continuaci\u00f3n re sume los aspectos m\u00e1s b\u00e1sicos de las \ntransformaciones que hemos descrito en las secciones anteriores, con el obje -\ntivo de presentar una visi\u00f3n r\u00e1pida de los mismos: \n3.11. Ejemplo: base de datos del personal de una entidad bancaria\nEn este apartado aplicaremos las transf ormaciones que hemos explicado en el \ncaso pr\u00e1ctico de la base de datos del personal de una entidad bancaria. Antes \nhemos presentado el dise\u00f1o conceptual de esta base de datos. A continuaci\u00f3n, \nveremos su transformaci\u00f3n al modelo relacional.\nEmpezaremos por transforma r todas las entidades en relaciones y todas las in -\nterrelaciones 1:1 y 1:N en claves for\u00e1neas de estas relaciones.CIUDAD( nombre-ciudad , ...)\nVIAJE( id-viaje , ...)\nRECORRIDO ( nombre-ciudad , id-viaje )\ndonde {nombre-ciudad} referencia CIUDAD\ne {id-viaje} referencia VIAJE\nCLIENTE { c\u00f3digo-cliente , ...}\nREPARTO( nombre-ciudad, id-viaje, c\u00f3digo-cliente , paq-car, paq-desc)\ndonde {nombre-ciudad, id-viaje} referencia RECORRIDO\ny {c\u00f3digo-cliente} referencia CLIENTE\nElemento del modelo ER Transformaci\u00f3n al modelo relacional\nEntidad Relaci\u00f3n\nInterrelaci\u00f3n 1:1 Clave for\u00e1nea\nInterrelaci\u00f3n 1:1 Clave for\u00e1nea\nInterrelaci\u00f3n M:N Relaci\u00f3n\nInterrelaci\u00f3n n-aria Relaci\u00f3n\nInterrelaci\u00f3n recursivaComo en las interrelaciones no recursivas:\n\u2022 Clave for\u00e1nea para binarias 1:1 y 1:N\n\u2022 Relaci\u00f3n para binarias M:N y n-arias\nEntidad d\u00e9bilLa clave for\u00e1nea de la interrelaci\u00f3n identificadora \nforma parte de la clave primaria\nGeneralizaci\u00f3n/especializaci\u00f3n\u2022 Relaci\u00f3n para la entidad superclase\n\u2022 Relaci\u00f3n para cada una de las entidades subclase\nEntidad asociativaLa transformaci\u00f3n de la in terrelaci\u00f3n que la origina \nes a la vez su transformaci\u00f3n\nHemos presentado el dise\u00f1o \nconceptual de la base de datos  \ndel personal de la entidad bancaria  \nen el subapartado 2.3 de esta unidad did\u00e1ctica.\n\uf8e9 FUOC \u2022 71Z799014MO 50 Introducci\u00f3n al dise\u00f1o de bases de datos\nObservad que, en la transformaci\u00f3n de la generalizaci\u00f3n/esp ecializaci\u00f3n corres -\npondiente a la entidad empleado , hemos situado los atributos comunes a la rela -\nci\u00f3n EMPLEADO  y los atributos espec\u00edficos se han situado en las relaciones FIJO\ny TEMPORAL .\nEn la relaci\u00f3n AGENCIA , el atributo nombre-ciudad  es una clave for\u00e1nea y al \nmismo tiempo forma parte de la clave primaria porque agencia  es una entidad \nd\u00e9bil que requiere la interrelaci\u00f3n situacion  para ser identificada.\nVeamos ahora las relaciones que se obtien en a partir de la transformaci\u00f3n de \nlas interrelaciones binarias y n-arias:\nPara elegir las claves prim arias adecuadas, se ha teni do en cuenta la conectivi -\ndad de las interrelaciones.EMPLEADO( c\u00f3digo-empleado , DNI, NSS, nombre, apellido, nombre-\ncateg, central, ciudad-res)\ndonde {nombre-categ} referencia CATEGOR\u00cdA,\n{central} referencia CENTRAL-SINDICAL,\nel atributo central admite valores nulos\ny {ciudad-res} referencia CIUDAD\nFIJO( c\u00f3digo-empleado , antig\u00fcedad)\ndonde {c\u00f3digo-empleado } referencia EMPLEADO\nTEMPORAL( c\u00f3digo-empleado , fecha-inicio-cont,  fecha-final-cont)\ndonde {c\u00f3digo-empleado } referencia EMPLEADO\nCIUDAD( nombre-ciudad , n\u00famero-hab)\nAGENCIA( nombre-ciudad, nombre-agencia , direcci\u00f3n, tel\u00e9fono)\ndonde {nombre-ciudad} referencia CIUDAD\nT\u00cdTULO( nombre-t\u00edtulo )\nCATEGOR\u00cdA( nombre-categor\u00eda , sueldo-base, hora-extra)\nCENTRAL-SINDICAL( central , cuota)\nTIPO-PR\u00c9STAMO( c\u00f3digo-pr\u00e9stamo , tipo-inter\u00e9s, per\u00edodo-vigencia)\nFECHA( fecha )\nTITULACI\u00d3N( c\u00f3digo-empleado, nombre-t\u00edtulo )\ndonde {c\u00f3digo-empleado } referencia EMPLEADO\ny {nombre-t\u00edtulo} referencia T\u00cdTULO\nTRASLADO( c\u00f3digo-empleado, fecha , nombre-ciudad, nombre-agencia, \nfecha-fin)\ndonde {c\u00f3digo-empleado} referencia EMPLEADO,\n{nombre-ciudad, nombre-age ncia} referencia AGENCIA\ny {fecha} referencia FECHA\nPETICI\u00d3N( c\u00f3digo-empleado, c\u00f3digo-pr\u00e9stamo, fecha , concedido/no)\ndonde {c\u00f3digo-emplea do) referencia FIJO\n{c\u00f3digo-pr\u00e9stamo} refe rencia TIPO-PR\u00c9STAMO\ny {fecha} referencia FECHA\uf8e9 FUOC \u2022 71Z799014MO 51 Introducci\u00f3n al dise\u00f1o de bases de datos\nResumen\nEsta unidad es una introducci\u00f3n a un tema de gran inter\u00e9s: el dise\u00f1o de bases \nde datos .\nEn primer lugar, hemos exp licado qu\u00e9 se entiende por dise\u00f1ar una base de datos\ny hemos analizado las etapas en las qu e se puede descomponer el proceso de \ndise\u00f1o:\n\u2022l a  etapa del dise\u00f1o conceptual ,\n\u2022l a  etapa del dise\u00f1o l\u00f3gico ,\n\u2022l a  etapa del dise\u00f1o f\u00edsico .\nEn el resto de la unidad hemos tratado el  dise\u00f1o conceptual y el dise\u00f1o l\u00f3gico \nde la base de datos. No hemos estudiado el dise\u00f1o f\u00edsico porque requiere unos conocimientos previos de estructuras de  implementaci\u00f3n f\u00edsica que hacen in\n-\nadecuado explicarlo en este curso. \nPara el dise\u00f1o conceptual he mos adoptado el enfoque del  modelo ER , un mo -\ndelo de datos muy utilizad o y comprensible. Hemos de scrito las diversas cons -\ntrucciones que proporciona y hemos dado ejemplos de aplicaci\u00f3n a casos \npr\u00e1cticos.\nEn lo que respecta al dise\u00f1o l\u00f3gico, lo hemos centrado en el  caso de utilizaci\u00f3n \nde la tecnolog\u00eda relacional . De este modo, hemos ex plicado c\u00f3mo se puede \ntransformar un modelo conceptual expr esado mediante el modelo ER en una \nestructura de datos del modelo relacional.\n\uf8e9 FUOC \u2022 71Z799014MO 53 Introducci\u00f3n al dise\u00f1o de bases de datos\nEjercicios de autoevaluaci\u00f3n\n1.Haced un dise\u00f1o conceptual de una base de da tos mediante el modelo ER que satisfaga los \nrequisitos que se re sumen a continuaci\u00f3n:\na)Un directivo de un club de f\u00fatbol quiere dis poner de una base de datos que le permita con -\ntrolar datos que le interesan sobre competicione s, clubes, jugadores, entrenadores, etc. de \n\u00e1mbito estatal.\nb)Los clubes disputan cada tem porada varias competiciones (lig a, copa, etc.) entre s\u00ed. Nues -\ntro directivo desea informaci\u00f3n hist\u00f3rica de las clasificaciones obtenidas por los clubes en las \ndiferentes competiciones a lo largo de todas la s temporadas. La clasific aci\u00f3n se especificar\u00e1 \nmediante un n\u00famero de posici\u00f3n: 1 significa campe\u00f3n, 2 significa subcampe\u00f3n, etc.\nc)Los distintos clubes est\u00e1n agrupados en las fe deraciones regionales correspondientes. Toda \nfederaci\u00f3n tiene como m\u00ednimo un club. Quiere saber el nombre y la fecha de creaci\u00f3n de las \nfederaciones as\u00ed como el nombre y el n\u00famero de socios de los clubes.\nd)Es muy importante la informaci\u00f3n sobre jugado res y entrenadores. Se identificar\u00e1n por un \nc\u00f3digo, y quiere saber el nombre, la direcci\u00f3n, el n\u00famero de tel\u00e9fono y la fecha de nacimien -\nto de todos. Es necesario mencionar que algu nos entrenadores pueden haber sido jugadores \nen su juventud. De los jugadores, adem\u00e1s, quiere saber el peso, la altura, la especialidad o las \nespecialidades y qu\u00e9 dominio tienen de ellas (g rado de especialidad). Todo jugador debe te -\nner como m\u00ednimo una especialidad, pero puede haber especialidades en las que no haya nin -\ng\u00fan jugador. De los entrenadores le interesa  la fecha en que iniciaron su carrera como \nentrenadores de f\u00fatbol.\ne)De todas las personas que figura n en la base de datos (jugad ores y entrenadores), quiere co -\nnocer el historial de contrataciones por parte de  los diferentes clubes, incluyendo el importe y \nla fecha de baja de cada contrataci\u00f3n. En un  momento determinado, una persona puede estar \ncontratada por un \u00fanico club, pe ro puede cambiar de club posteriormente e, incluso, puede \nvolver a un club en el que ya hab\u00eda trabajado.\nf)Tambi\u00e9n quiere registrar las ofertas que las pe rsonas que figuran en la base de datos han \nrecibido de los clubes durante su vida deportiva (y de las que se ha enterado). Considera b\u00e1 -\nsico tener constancia del importe de las ofertas. Se debe tener en cuenta que, en un momento \ndeterminado, una persona puede recibir muchas ofertas, siempre que provengan de clubes \ndistintos.\n2.Haced un dise\u00f1o conceptual de una base de da tos mediante el modelo ER que satisfaga los \nrequisitos que se re sumen a continuaci\u00f3n:\na)Se quiere dise\u00f1ar una base de datos para faci litar la gesti\u00f3n de una empresa dedicada al \ntransporte internacional de mercanc\u00edas que opera en todo el \u00e1mbito europeo.\nb)La empresa dispone de varias delegaciones re partidas por toda la geograf\u00eda europea. Las \ndelegaciones se identifican por un nombre, y se  quiere registrar tambi\u00e9n su n\u00famero de tel\u00e9 -\nfono. En una determinada ciudad no hay nunca m\u00e1s de una delegaci\u00f3n. Se desea conocer la \nciudad donde est\u00e1 situada cada delegaci\u00f3n. Se debe suponer que no hay ciudades con el nom -\nbre repetido (por lo menos en el \u00e1mbito de esta base de datos).\nc)El personal de la empresa se pu ede separar en dos grandes grupos:\n\u2022 Administrativos, sobre los cuales interesa saber su nivel de estudios.\n\u2022 Conductores, sobre los que interesa saber el a\u00f1o en el que obtuvieron el  carnet de conducir \ny el tipo de ca rnet que tienen.\nDe todo el personal de la empresa, se quiere conocer el c\u00f3digo de empleado (que lo identifica), \nsu nombre, su n\u00famero de tel\u00e9 fono y el a\u00f1o de nacimiento. Todos los empleados est\u00e1n asigna -\ndos a una delegaci\u00f3n determinada.  Se quiere tener constancia hist\u00f3rica de este hecho teniendo \nen cuenta que pueden ir cambiando de delegaci\u00f3n (incluso pueden volver a una delegaci\u00f3n \ndonde ya hab\u00edan estado anteriormente).\nd)La actividad de la empresa consiste en efectu ar los viajes pertinentes para transportar las \nmercanc\u00edas seg\u00fan las peticiones de sus clientes. Todos los clientes se identifican por un c\u00f3di -\ngo de cliente. Se quiere conocer, adem\u00e1s, el nombre y el tel\u00e9fono de contacto de cada uno de ellos.\ne)La empresa, para llevar a cabo su actividad,  dispone de muchos camiones identificados \npor un c\u00f3digo de cami\u00f3n. Se quiere tener constancia de la matr\u00edcula, la marca y la tara de los camiones.\nf)Los viajes los organiza siempre una delegaci\u00f3n, y se identifican mediante un c\u00f3digo de via -\nje, que es interno de cada delegaci\u00f3n (y que se puede repetir en delegaciones diferentes). Para \ncada uno de los viajes que se  han hecho, es necesario saber:\n\u2022 Qu\u00e9 cami\u00f3n se ha utilizado (ya que cada viaje se hace con un solo cami\u00f3n).\n\u2022 Qu\u00e9 conductor o conductores han ido (considera ndo que en viajes larg os pueden ir varios \nconductores). Se quiere saber tambi\u00e9n el importe de las dietas pagadas a cada conductor \n(teniendo en cuenta que las dietas pueden se r diferentes para los diferentes conductores \nde un mismo viaje).\n\u2022 El recorrido del viaje; es decir, la fecha y la hora en que el cami\u00f3n llega a cada una de las \nciudades donde deber\u00e1 cargar o descargar. Supondremos que un viaje no pasa nunca dos \nveces por una misma ciudad.\uf8e9 FUOC \u2022 71Z799014MO 54 Introducci\u00f3n al dise\u00f1o de bases de datos\n\u2022 El n\u00famero de paquetes cargados y de paquet es descargados en cada ciudad, y para cada \nuno de los clientes. En un mismo viaje se pued en dejar y/o recoger paquetes en diferentes \nciudades por encargo de un mi smo cliente. Tambi\u00e9n, en un mismo viaje, se pueden dejar \ny/o recoger paquetes en una misma ciudad  por encargo de diferentes clientes.\n3.Haced un dise\u00f1o conceptual de una base de da tos mediante el modelo ER que satisfaga los \nrequisitos que se re sumen a continuaci\u00f3n:\na)Es necesario dise\u00f1ar una base de datos para una empresa inmobiliaria con el objetivo de \ngestionar la informaci\u00f3n relativa a su cartera de pisos en venta.\nb)Cada uno de los pisos que tienen  pendientes de vender tiene asignado un c\u00f3digo de piso \nque lo identifica. Adem\u00e1s de este  c\u00f3digo, se quiere conocer la di recci\u00f3n del piso, la superficie, \nel n\u00famero de habitaciones y el precio. Tienen estos pisos clasificados por zonas (porque a sus \nclientes, en ocasiones, s\u00f3lo les interesan los pi sos de una zona determinada) y se quiere saber \nen qu\u00e9 zona est\u00e1 situado cada piso. Las zonas ti enen un nombre de zona que es diferente para \ncada una de una misma poblaci\u00f3n, pero que pu eden coincidir en zonas de poblaciones dife -\nrentes. En ocasiones sucede que en algunas de las zonas no tienen ning\u00fan piso pendiente de \nvender.\nc)Se quiere tener el n\u00famero de habitantes de las poblaciones. Se quie re saber qu\u00e9 zonas son \nlim\u00edtrofes, (porque, en caso de no disponer de pisos en una zona  que desea un cliente, se le \npuedan ofrecer los que tengan en otras zonas lim \u00edtrofes). Es necesario considerar que pueden \nexistir zonas sin ninguna zona lim\u00edtrofe en algunas poblaciones peque\u00f1as que constan de una \nsola zona.\nd)Se disponen de diferentes caracter\u00edsticas codificadas de los pisos, como por ejemplo tener \nascensor, ser exterior, tener terraza, etc. Cada caracter\u00edstica se identifica mediante un c\u00f3digo \ny tiene una descripci\u00f3n. Para cada caracter\u00edstica y cada piso se quiere sabe r si el piso satisface \nla caracter\u00edstica o no. Adem\u00e1s, quieren tener constancia del propietario o los propietarios de cada piso.\ne)Tambi\u00e9n necesitan disponer de informaci\u00f3n relativa a sus clientes actuales que buscan \npiso (si dos o m\u00e1s personas busc an piso conjuntamente, s\u00f3lo se guarda informaci\u00f3n de una \nde ellas como cliente de la empresa). En partic ular, interesa saber las zonas donde busca piso \ncada cliente (s\u00f3lo en caso de que tenga alguna zona de preferencia).\nf)A cada uno de estos clientes le asignan un ve ndedor de la empresa para que se ocupe de \natenderlo. A veces, estas asignaciones var\u00edan co n el tiempo y se cambia al vendedor asignado \na un determinado cliente. Tambi\u00e9n es posible que a un cliente se le vuelva a asignar un ven -\ndedor que ya hab\u00eda tenido con anterioridad. Se quiere tener constancia de las asignaciones \nde los clientes actu ales de la empresa.\ng)Los vendedores, clientes y propietarios se iden tifican por un c\u00f3digo de persona. Se quiere \nregistrar, de todos, su nombre, direcci\u00f3n y n\u00fa mero de tel\u00e9fono. Adem\u00e1s, se quiere disponer \ndel n\u00famero de Seguridad Social y el sueldo de los vendedores, y del NIF de los propietarios. Puede haber personas que sean al mismo tiempo clientes y propietarios,  o bien vendedores \ny propietarios, etc.\nh)Finalmente, para ayudar a programar y consultar las visitas que los clientes hacen a los pi -\nsos en venta, se quiere guardar informaci\u00f3n de todas las visitas correspondientes a los clientes \ny a los pisos actuales de la empres a. De cada visita hay que saber el cliente que la hace, el piso \nque se va a ver y la hora concreta en que se inicia la visita. Entendemos que la hora de la visita est\u00e1 formada por la fecha, la hora del d\u00eda y el  minuto del d\u00eda (por ejemplo, 25-FEB-98, 18:30). \nHay que considerar que un mism o cliente puede visitar un mismo piso varias veces para ase\n-\ngurarse de si le gusta o no, y tambi\u00e9n que para evitar conflictos no se  programan nunca visitas \nde clientes diferentes a un mismo piso y a la misma hora.\n4.Transformad a relacional el dise\u00f1o conceptu al que hab\u00e9is obtenido en el ejercicio 1.\n5.Transformad a relacional el dise\u00f1o conceptu al que hab\u00e9is obtenido en el ejercicio 2.\n6.Transformad a relacional el dise\u00f1o conceptu al que hab\u00e9is obtenido en el ejercicio 3.\uf8e9 FUOC \u2022 71Z799014MO 55 Introducci\u00f3n al dise\u00f1o de bases de datos\nSolucionario\nEjercicios de autoevaluaci\u00f3n\n1.La siguiente figura muestra un diagrama ER qu e satisface los requisitos que se han descrito:\nLos atributos de las entidades que figuran en el diagrama son los siguientes (las claves prima -\nrias se han subrayado):\nCOMPETICI\u00d3N\nnombre-comp\nTEMPORADA\nc\u00f3digo-temp\nFEDERACI\u00d3N\nnombre-fed , fecha-creaci\u00f3n\nCLUB\nnombre-club , n\u00famero-socios\nPERSONA\nc\u00f3digo-persona , nombre, direcci\u00f3n, tel\u00e9fono, fecha-nacimiento\nJUGADOR (entidad subclase de persona)\nc\u00f3digo-persona , peso, altura\nENTRENADOR (entidad subclase de persona)\nc\u00f3digo-persona , fecha-inicio-carrera\nESPECIALIDAD\nnombre-esp\nFECHA\nfecha\n\uf8e9 FUOC \u2022 71Z799014MO 56 Introducci\u00f3n al dise\u00f1o de bases de datos\n2.La siguiente figura muestra un diagrama ER qu e satisface los requisitos que se han descrito:\nLos atributos de las entidades que figuran en el diagrama son los siguientes (las claves prima -\nrias se han subrayado):\nCIUDAD\nnombre-ciudad\nDELEGACI\u00d3N\nnombre-del , tel\u00e9fono\nEMPLEADO\nc\u00f3digo-empleado , nombre, tel\u00e9fono, a\u00f1o-nacimiento\nCONDUCTOR (subclase de empleado)\nc\u00f3digo-empleado , a\u00f1o-carnet, tipo-carnet\nADMINISTRATIVO (subclase de empleado)  \nc\u00f3digo-empleado , nivel-estudios\nFECHA\nfecha\nVIAJE (entidad d\u00e9bil: c\u00f3digo-viaje la identifica parcialmente, se iden -\ntifica completamente con la delegaci\u00f3n de organizaci\u00f3n).\nc\u00f3digo-viaje\nCAMION\nc\u00f3digo-camion , matr\u00edcula, marca, tara\nCLIENTE\nc\u00f3digo-cliente , nombre, tel\u00e9fono-contacto\n\uf8e9 FUOC \u2022 71Z799014MO 57 Introducci\u00f3n al dise\u00f1o de bases de datos\n3.La figura que pod\u00e9is ver a continuaci\u00f3n muestra  un diagrama ER que satisface los requisitos \nque se han descrito:\nLos atributos de las entidades que figuran en el diagrama son los siguientes (las claves prima -\nrias se han subrayado):\nPOBLACI\u00d3N\nnombre-pobl , n\u00famero-hab\nZONA (entidad d\u00e9bil: nombre-zona la identifica parcialmente, se \nidentifica completamente con la poblaci\u00f3n de localizaci\u00f3n)\nnombre-zona\nPISO\nc\u00f3digo-piso , direcci\u00f3n, superficie, n\u00famero-habitaciones, precio\nCARACTERISTICA\nc\u00f3digo-car , descripci\u00f3n\nPERSONA\nc\u00f3digo-persona , nombre, direcci\u00f3n, tel\u00e9fono\nVENDEDOR (entidad subclase de persona)\nc\u00f3digo-persona , nss, sueldo\nCLIENTE (entidad su bclase de persona)\nc\u00f3digo-persona\nPROPIETARIO (entidad subclase de persona)\nc\u00f3digo-persona , nif\nFECHA\nfecha\nHORA (entidad d\u00e9bil: hora-minuto la identifica parcialmente, se \nidentifica completamente co n la fecha de pertenencia)\nhora-minuto\n\uf8e9 FUOC \u2022 71Z799014MO 58 Introducci\u00f3n al dise\u00f1o de bases de datos\n4.El resultado de la transformaci\u00f3n a relacional  del modelo ER propues to como soluci\u00f3n del \nejercicio 1 consta de las siguientes relaciones:\n5.El resultado de la transformaci\u00f3n a relacional  del modelo ER propues to como soluci\u00f3n del \nejercicio 2 consta de las siguientes relaciones:COMPETICI\u00d3N( nombre-comp )\nTEMPORADA( c\u00f3digo-temp )\nFEDERACI\u00d3N( nombre-fed , fecha-creaci\u00f3n)\nCLUB( nombre-club , n\u00famero-socios, nombre-fed)\ndonde {nombre-fed} referencia FEDERACI\u00d3N\nPERSONA( c\u00f3digo-persona , nombre, direcci\u00f3n, tel\u00e9fono, fecha-nacimiento)\nJUGADOR( c\u00f3digo-persona , peso, altura)\ndonde {c\u00f3digo-persona} referencia PERSONA\nENTRENADOR( c\u00f3digo-persona , fecha-inicio-carrera)\ndonde {c\u00f3digo-persona} referencia PERSONA\nESPECIALIDAD( nombre-esp )\nFECHA( fecha )\nHABILIDAD( c\u00f3digo-persona, nombre-esp , grado)\ndonde {c\u00f3digo-persona} referencia JUGADOR\ny {nombre-esp} refe rencia ESPECIALIDAD\nCLASIFICACI\u00d3N( nombre-comp, c\u00f3digo-temp, nombre-club , num-posici\u00f3n)\ndonde {nombre-comp} referencia COMPETICI\u00d3N,\n{c\u00f3digo-temp} referencia TEMPORADA\ny {nombre-club} referencia CLUB\nCONTRATO( c\u00f3digo-persona, fecha , nombre-club, importe-cont, fecha-baja)\ndonde {c\u00f3digo-persona} referencia PERSONA,\n{fecha} referencia FECHA\ny {nombre-club} referencia CLUB\nOFERTA( c\u00f3digo-persona, fecha, nombre-club , importe-oferta)\ndonde {c\u00f3digo-persona} referencia PERSONA,\n{fecha} referencia FECHA\ny {nombre-club} referencia CLUB\nCIUDAD( nombre-ciudad )\nDELEGACI\u00d3N( nombre-del , tel\u00e9fono, nombre-ciudad)\ndonde {nombre-ciudad} referencia CIUDAD\nEMPLEADO( c\u00f3digo-empleado , nombre, tel\u00e9fono, a\u00f1o-nacimiento)\nCONDUCTOR( c\u00f3digo-empleado , a\u00f1o-carnet, tipo-carnet)\ndonde {c\u00f3digo-empleado} referencia EMPLEADO\nADMINISTRATIVO ( c\u00f3digo-empleado , nivel-estudios)\ndonde {c\u00f3digo-empleado} referencia EMPLEADO\nFECHA( fecha )\nVIAJE( nombre-del, c\u00f3digo-viaje , c\u00f3digo-cami\u00f3n)\ndonde {nombre-del} referencia DELEGACI\u00d3N\ny {c\u00f3digo-cami\u00f3n} referencia CAMI\u00d3N\nCAMI\u00d3N( c\u00f3digo-cami\u00f3n , matr\u00edcula, marca, tara)\nCLIENTE( c\u00f3digo-cliente , nombre, tel\u00e9fono-contacto)\nASIGNACION( c\u00f3digo-empleado, fecha , nombre-del, fecha-fin)\ndonde {c\u00f3digo-empleado} referencia EMPLEADO,\n{nombre-del} referencia DELEGACI\u00d3N\ny {fecha} referencia FECHA\nCONDUCCI\u00d3N( c\u00f3digo-empleado, nombre-del, c\u00f3digo-viaje , importe-dietas)\ndonde {c\u00f3digo-empleado} referencia CONDUCTOR\ny {nombre-del, c\u00f3digo-viaje} referencia VIAJE\nRECORRIDO( nombre-ciudad, nombre-del, c\u00f3digo-viaje , fecha, hora)\ndonde {nombre-ciudad} referencia CIUDAD\ny {nombre-del, c\u00f3digo-viaje} referencia VIAJE\nREPARTO ( nombre-ciudad, nombre-del, c\u00f3digo-viaje, c\u00f3digo-cliente , \npaquetes-car, paquetes-desc)\ndonde {nombre-ciudad, nombre-del, c\u00f3digo-viaje} referencia RECORRIDO\ny {c\u00f3digo-cliente} referencia CLIENTE\uf8e9 FUOC \u2022 71Z799014MO 59 Introducci\u00f3n al dise\u00f1o de bases de datos\n6.El resultado de la transformaci\u00f3n a relacional  del modelo ER propues to como soluci\u00f3n del \nejercicio 3 consta de las siguientes relaciones:\nPara la interrelaci\u00f3n visita , hay dos transformaciones posibles:\n1)\n2)\nGlosario\natributo de una entidad\nPropiedad que interesa de una entidad.\natributo de una interrelaci\u00f3n\nPropiedad que interesa de una interrelaci\u00f3n.\nconectividad de una interrelaci\u00f3n\nExpresi\u00f3n del tipo de correspon dencia entre las ocurrencias de  entidades asociadas con la \ninterrelaci\u00f3n.POBLACI\u00d3N( nombre-pobl , nombre-hab)\nZONA( nombre-pobl, nom-zona )\ndonde {nombre-pobl} referencia POBLACI\u00d3N\nPISO( c\u00f3digo-piso , direcci\u00f3n, superficie, n\u00famero-habitaciones, precio,  \nnombre-pobl, nombre-zona)\ndonde {nombre-pobl, nombre -zona} referencia ZONA\nCARACTER\u00cdSTICA( c\u00f3digo-car , descripci\u00f3n)\nPERSONA( c\u00f3digo-persona , nombre, direcci\u00f3n, tel\u00e9fono)\nVENDEDOR( c\u00f3digo-persona , nss, sueldo)\ndonde {c\u00f3digo-persona} referencia PERSONA\nCLIENTE( c\u00f3digo-persona )\ndonde {c\u00f3digo-persona} referencia PERSONA\nPROPIETARIO( c\u00f3digo-persona , nif)\ndonde {c\u00f3digo-persona} referencia PERSONA\nFECHA( fecha )\nHORA( fecha, hora-minuto ) \ndonde {fecha} referencia FECHA\nASIGNACI\u00d3N( c\u00f3digo-cliente, fecha , c\u00f3digo-vendedor, fecha-fin)\ndonde {c\u00f3digo-cliente} referencia CLIENTE,\n{fecha} referencia FECHA\ny {c\u00f3digo-vendedor} referencia VENDEDOR\nPREFERENCIA( c\u00f3digo-persona, nombre-pobl, nombre-zona )\ndonde {c\u00f3digo-personal} referencia CLIENTE\ny {nombre-pobl, nom-zona} referencia ZONA\nSATISFACCI\u00d3N( c\u00f3digo-piso, c\u00f3digo-car , satisface/no)\ndonde {c\u00f3digo-piso} referencia PISO\ny {c\u00f3digo-car} referencia CARACTER\u00cdSTICA\nLIM\u00cdTROFE( nombre-pobl, nombre-zona, nomb re-pobl-lim, nombre-zona-lim )\ndonde {nombre-pobl, nombre -zona} referencia ZONA\ny {nombre-pobl-lim, nombre -zona-lim} referencia ZONA\nPROPIEDAD( c\u00f3digo-piso, c\u00f3digo-persona )\ndonde {c\u00f3digo-piso} referencia PISO\ny {c\u00f3digo-persona} referencia PROPIETARIO\nVISITA( fecha, hora-minuto, c\u00f3digo-piso , c\u00f3digo-persona)\ndonde {fecha, hora-minuto} referencia HORA,\n{c\u00f3digo-persona} referencia CLIENTE\ny {c\u00f3digo-piso} referencia PISO\nVISITA( fecha, hora-minuto, c\u00f3digo-persona , c\u00f3digo-piso)\ndonde {fecha, hora-minuto} referencia HORA,\n{c\u00f3digo-persona} referencia CLIENTE\ny {c\u00f3digo-piso} referencia PISO\uf8e9 FUOC \u2022 71Z799014MO 60 Introducci\u00f3n al dise\u00f1o de bases de datos\ndise\u00f1o conceptual\nEtapa del dise\u00f1o de una base de datos que obtiene una estructura de la informaci\u00f3n de la fu -\ntura BD independiente de la tecnolog\u00eda que se quiere utilizar.\ndise\u00f1o f\u00edsico\nEtapa del dise\u00f1o de una base de datos que transf orma la estructura obte nida en la etapa del \ndise\u00f1o l\u00f3gico con el objetivo de conseguir un a mayor eficiencia y que, adem\u00e1s, la completa \ncon aspectos de implementaci\u00f3n f\u00edsica que depender\u00e1n del SGBD que se debe utilizar.\ndise\u00f1o l\u00f3gico\nEtapa del dise\u00f1o de una base de datos que pa rte del resultado del dise\u00f1o conceptual y lo \ntransforma de modo que se adapte al modelo del SGBD con el que se desea implementar la \nbase de datos.\nentidad\nObjeto del mundo real que podem os distinguir del resto de los objetos y del cual nos intere -\nsan algunas propiedades.\nentidad asociativa\nEntidad resultante de considerar una interrela ci\u00f3n entre entidades como una nueva entidad.\nentidad d\u00e9bil\nEntidad cuyos atributos no la identifican completamente, sino que s\u00f3lo la identifican de for -\nma parcial.\nentidad obligatoria en una interrelaci\u00f3n binaria\nEntidad tal que una ocurrencia de la otra entida d que interviene en la interrelaci\u00f3n s\u00f3lo puede \nexistir si se da como m\u00ednimo una ocurrencia de  la entidad obligatoria a la que est\u00e1 asociada.\nentidad opcional en una interrelaci\u00f3n binaria\nEntidad tal que una ocurrencia de la otra enti dad que interviene en la interrelaci\u00f3n puede \nexistir aunque no haya ninguna ocurrencia de la entidad opcional a la que est\u00e1 asociada.\ngeneralizaci\u00f3n/especializaci\u00f3n\nConstrucci\u00f3n que permite re flejar que existe una entidad general, denominada entidad super -\nclase, que se puede especializar en entidades su bclase. La entidad superclase nos permite mo -\ndelizar las caracter\u00edsticas comunes de la entidad vista a un nivel gen\u00e9rico, y con las entidades \nsubclase podemos modelizar las caracter\u00eds ticas propias de sus especializaciones.\ngrado de una interrelaci\u00f3n\nN\u00famero de entidades que asocia la interrelaci\u00f3n.\ninterrelaci\u00f3n\nAsociaci\u00f3n entre entidades.\ninterrelaci\u00f3n recursiva\nInterrelaci\u00f3n en la que alguna enti dad est\u00e1 asociada m\u00e1s de una vez.\nBibliograf\u00eda\nBatini, C.; Ceri, S.; Navathe, S.B.  (1992). Conceptual Database Design: An Entity-Relationship \nApproach . Reading, Massachusetts: Addison Wesley.\nTeorey, T.J.  (1999). Database Modeling & Design. The Fundamental Principles  (3\u00aa ed.). San \nFrancisco: Morgan Kaufmann Publishers, Inc.Bases de datos  \nen MySQL\nLuis Alberto Casillas Santill\u00e1n  \nMarc Gibert Ginest\u00e0  \n\u00d3scar P\u00e9rez Mora\n\uf8e9 FUOC \u2022 71Z799014MO Bases de datos en MySQL\n\u00cdndice\nIntroducci\u00f3n .............................................................................................. 5\nObjetivos ..................................................................................................... 6\n1. Caracter\u00edsticas de MySQL .................................................................. 7\n1.1. Prestaciones ...................................................................................... 7\n1.2. Limitaciones ..................................................................................... 8\n2. Acceso a un servidor MySQL ............................................................. 9\n2.1. Conect\u00e1ndose con el servidor .......................................................... 9\n2.1.1. Servidores y clientes ............................................................... 9\n2.1.2. Conectarse y desconectarse .................................................... 10\n2.2. Introducci\u00f3n de sentencias .............................................................. 10\n2.2.1. Sentencias ............................................................................... 11\n2.2.2. Comandos en m\u00faltiples l\u00edneas ............................................... 11\n2.2.3. Cadenas de caracteres ............................................................. 12\n2.2.4. Expresiones y variables .......................................................... 13\n2.2.5. Expresiones ............................................................................. 14\n2.3. Proceso por lotes ............................................................................... 14\n2.4. Usar bases de datos ........................................................................... 17\n3. Creaci\u00f3n y manipulaci\u00f3n de tablas ................................................ 20\n3.1. Crear tablas ....................................................................................... 20\n3.2. Tipos de datos ................................................................................... 23\n3.2.1. Tipos de datos num\u00e9ricos ...................................................... 23\n3.2.2. Cadenas de caracteres ............................................................. 24\n3.2.3. Fechas y horas ........................................................................ 25\n3.3. Modificar tablas ................................................................................ 25\n3.3.1. Agregar y eliminar columnas ................................................. 25\n3.3.2. Modificar columnas ............................................................... 26\n3.4. Otras opciones .................................................................................. 27\n3.4.1. Copiar tablas .......................................................................... 27\n3.4.2. Tablas temporales ................................................................... 27\n4. Consultas ............................................................................................... 28\n4.1. La base de datos demo ...................................................................... 28\n4.2. Consultar informaci\u00f3n ..................................................................... 29\n4.2.1. Funciones auxiliares ............................................................... 30\n4.2.2. La sentencia EXPLAIN ............................................................ 31\n4.3. Manipulaci\u00f3n de filas ....................................................................... 33\n5. Administraci\u00f3n de MySQL ................................................................ 35\n5.1. Instalaci\u00f3n de MySQL ....................................................................... 35\uf8e9 FUOC \u2022 71Z799014MO Bases de datos en MySQL\n5.2. Usuarios y privilegios ........................................................................ 38\n5.2.1. La sentencia GRANT .............................................................. 39\n5.2.2. Especificaci\u00f3n de lugares origen de la conexi\u00f3n ................... 40\n5.2.3. Especificaci\u00f3n de bases de datos y tablas ............................... 41\n5.2.4. Especificaci\u00f3n de columnas ................................................... 42\n5.2.5. Tipos de privilegios ................................................................ 42\n5.2.6. Opciones de encriptaci\u00f3n ...................................................... 44\n5.2.7. Limites de uso ........................................................................ 44\n5.2.8. Eliminar privilegios ................................................................ 45\n5.2.9. Eliminar usuarios ................................................................... 45\n5.2.10. La base de datos de privilegios: mysql ................................. 45\n5.3. Copias de seguridad .......................................................................... 48\n5.3.1. mysqlhotcopy ........................................................................ 50\n5.3.2. mysqldump ............................................................................ 50\n5.3.3. Restaurar a partir de respaldos ............................................... 51\n5.4. Reparaci\u00f3n de tablas ......................................................................... 52\n5.4.1. myisamchk ............................................................................. 54\n5.5. An\u00e1lisis y optimizaci\u00f3n .................................................................... 55\n5.5.1. Indexaci\u00f3n .............................................................................. 55\n5.5.2. Equilibrio ...... ............. ............ ............. .......... .......... .......... ...... 57\n5.5.3. La cache de consultas de MySQL ........................................... 58\n5.6. Replicaci\u00f3n ....................................................................................... 59\n5.6.1. Preparaci\u00f3n previa .................................................................. 60\n5.6.2. Configuraci\u00f3n del servidor maestro ...................................... 60\n5.6.3. Configuraci\u00f3n del servidor esclavo ........................................ 61\n5.7. Importaci\u00f3n y exportaci\u00f3n de datos ................................................ 62\n5.7.1. mysqlimport ........................................................................... 63\n5.7.2. mysqldump ............................................................................ 63\n6. Clientes gr\u00e1ficos ................................................................................... 65\n6.1. mysqlcc ............................................................................................. 65\n6.2. mysql-query-browser ........................................................................ 66\n6.3. mysql-administrator ......................................................................... 67\nResumen ...................................................................................................... 70\nBibliograf\u00eda ................................................................................................ 71\uf8e9 FUOC \u2022 71Z799014MO 5 Bases de datos en MySQL\nIntroducci\u00f3n\nMySQL es un sistema gestor de bases de datos (SGBD, DBMS por sus siglas en \ningl\u00e9s) muy conocido y ampliamente us ado por su simplicidad y notable ren -\ndimiento. Aunque carece de algunas ca racter\u00edsticas avanza das disponibles en \notros SGBD del mercado, es una opci\u00f3n atractiva tanto para aplicaciones co -\nmerciales, como de entretenimiento pr ecisamente por su facilidad de uso y \ntiempo reducido de puesta en marcha. Esto y su libre distribuci\u00f3n en Internet \nbajo licencia GPL le otorgan como be neficios adicionales (no menos impor -\ntantes) contar con un alto grado de  estabilidad y un r\u00e1pido desarrollo.\nMySQL est\u00e1 disponible para m\u00faltiples plataformas, la seleccionada para los \nejemplos de este libro es GNU/Linux. Sin embargo, las diferencias con cual -\nquier otra plataforma son pr\u00e1cticament e nulas, ya que la herramienta utiliza -\nda en este caso es el cliente mysql-client, que permite interactuar con un \nservidor MySQL (local o remoto) en modo texto. De este modo es posible rea -\nlizar todos los ejercicios sobre un servid or instalado localmente o, a trav\u00e9s de \nInternet, sobre un servidor remoto.\nPara la realizaci\u00f3n de todas las actividades, es  imprescindible que disponga -\nmos de los datos de acceso del usuario administrador de la base de datos. Aun -\nque en algunos de ellos los privilegios  necesarios ser\u00e1n menores, para los \ncap\u00edtulos que tratan la administraci\u00f3n del SGBD ser\u00e1 imprescindible disponer \nde las credenciales de administrador.\nNota\nLas sentencias o comandos escrit os por el usuario estar\u00e1n en fuente monoespaciada , y las \npalabras que tienen un significado especial en MySQL estar\u00e1n en negrita . Es importante ha -\ncer notar que estas \u00faltimas no siempre son pala bras reservadas , sino comandos o sentencias \nde mysql-client .\nLa versi\u00f3n de MySQL que se ha utilizado durante la redac ci\u00f3n de este material, y \nen los ejemplos, es la 4.1, la \u00faltima ve rsi\u00f3n estable en ese momento, aunque no \nhabr\u00e1 ning\u00fan problema en ejecutarlos en versiones an teriores, hasta la 3.23.Nota\nPodremos utilizar la licencia \nGPL de MySQL siempre que el programa que lo use tambi\u00e9n lo sea, en caso contrario se debe adquirir la \u201clicencia co-mercial\u201d, entre 250 y 500 \u20ac,  \nen el momento de escribir este material.\uf8e9 FUOC \u2022 71Z799014MO 6 Bases de datos en MySQL\nObjetivos\nAdquirir las habilidades y conocimiento s de MySQL necesarios para utilizar y \nadministrar este SGBD (sistema gestor de bases de datos).\uf8e9 FUOC \u2022 71Z799014MO 7 Bases de datos en MySQL\n1. Caracter\u00edsticas de MySQL\nEn este apartado enumeraremos las pres taciones que caracterizan a este SGBD, \nas\u00ed como las deficiencias de dise\u00f1o, lim itaciones o partes de l est\u00e1ndar a\u00fan no \nimplementadas.\n1.1. Prestaciones\nMySQL es un SGBD que ha ganado popularidad por una serie de atractivas ca -\nracter\u00edsticas:\n\u2022 Est\u00e1 desarrollado en C/C++.\n\u2022 Se distribuyen ejecutables para cerca de diecinueve plataformas diferentes.\n\u2022 La API se encuentra disponible en C, C++, Eiffel , Java, Perl, PHP, Python, \nRuby y TCL.\n\u2022 Est\u00e1 optimizado para equipos de m\u00faltiples procesadores.\n\u2022 Es muy destacable su velocidad de respuesta.\n\u2022 Se puede utilizar como cliente-serv idor o incrustado  en aplicaciones.\n\u2022 Cuenta con un rico conj unto de tipos de datos.\n\u2022 Soporta m\u00faltiples m\u00e9todos de almacenamiento de las tablas, con prestacio -\nnes y rendimiento diferentes para po der optimizar el SGBD a cada caso \nconcreto.\n\u2022 Su administraci\u00f3n se basa en usuarios y privilegios.\n\u2022 Se tiene constancia de casos en lo s que maneja cincuenta millones de re -\ngistros, sesenta mil tablas y cinco millones de columnas.\n\u2022 Sus opciones de conectividad abarcan TCP/IP, sockets  UNIX y sockets  NT, \nadem\u00e1s de soportar completamente ODBC.\n\u2022 Los mensajes de error pueden estar en espa\u00f1ol y hacer ordenaciones correc -\ntas con palabras acentuadas o con la letra \u2019\u00f1\u2019.\n\u2022 Es altamente confiable en cuan to a estabilidad se refiere.\nPara todos aquellos que son adeptos a la filosof\u00eda de UNIX y del lenguaje \nC/C++, el uso de MySQL les ser\u00e1 muy familiar, ya que su dise\u00f1o y sus inter -\nfaces son acordes a esa filosof\u00eda: \u201ccrear  herramientas que hagan una sola cosa \ny que la hagan bien\u201d. MySQL tiene como  principal objetivo ser una base de \ndatos fiable y eficiente. Ninguna caracter\u00edstica es implementada en MySQL si \nantes no se tiene la certeza que funciona r\u00e1 con la mejor velocidad de respuesta \ny, por supuesto, sin causar  problemas de estabilidad.\nLa influencia de C/C++ y UNIX se puede observar de igual manera en su sin -\ntaxis. Por ejemplo, la uti lizaci\u00f3n de expresiones regula res, la diferenciaci\u00f3n de \nfunciones por los par\u00e9ntesis , los valores l\u00f3gicos como 0 y 1, la utilizaci\u00f3n del \ntabulador para completar sent encias, por mencionar algunos.\uf8e9 FUOC \u2022 71Z799014MO 8 Bases de datos en MySQL\n1.2. Limitaciones\nAl comprender sus principios de dise\u00f1o, se puede explicar mejor las razones \nde algunas de sus carencias. Por ejemplo, el soporte de transacciones o la inte -\ngridad referencial (la gesti\u00f3n de claves  for\u00e1neas) en MySQL est\u00e1 condicionado \na un esquema de almacenamiento de tabla concreto, de forma que si el usuario \nno va a usar transacciones, puede usar el esquema de almacenamiento \u201ctradi -\ncional\u201d (MyISAM) y obtendr\u00e1 mayor rend imiento, mientras que si su aplica -\nci\u00f3n requiere transacciones, deber\u00e1 us ar el esquema que lo permite (InnoDB), \nsin ninguna otra restricci\u00f3n o implicaci\u00f3n.\nOtras limitaciones so n las siguientes:\n\u2022 No soporta procedimientos almacenados (se incluir\u00e1n en la pr\u00f3xima \nversi\u00f3n 5.0).\n\u2022 No incluye disparadores (se inclui r\u00e1n en la pr\u00f3xima versi\u00f3n 5.0).\n\u2022 No incluye vistas (se incluir\u00e1 n en la pr\u00f3xima versi\u00f3n 5.0).\n\u2022 No incluye caracter\u00edsticas de objetos como tipos de datos estructurados de -\nfinidos por el usuario, herencia etc.Nota\nEl esquema de tabla que hay \nque usar se decide para cada una en el momento de su crea-ci\u00f3n, aunque puede cambiarse posteriormente. Actualmente, MySQL soporta varios esque-mas y permite la incorporaci\u00f3n de esquemas definidos por el \nusuario.\uf8e9 FUOC \u2022 71Z799014MO 9 Bases de datos en MySQL\n2. Acceso a un servidor MySQL\nEn este apartado veremos las distintas formas de acceso a un servidor MySQL \nexistente que nos proporciona el propio  SGBD. El acceso desde lenguajes de \nprogramaci\u00f3n o herramientas en modo gr\u00e1fico se tratar\u00e1 en otros apartados.\n2.1. Conect\u00e1ndose con el servidor\nPara conectarse con el servidor deberemos asegurarnos de que \u00e9ste est\u00e1 funcio -\nnando y de que admite conexiones, sean \u00e9stas locales (el SGBD se est\u00e1 ejecu -\ntando en la misma m\u00e1quina que in tenta la conexi\u00f3n) o remotas. \nAdicionalmente, deberemos di sponer de las credenciales necesarias para la co -\nnexi\u00f3n. Distintos tipos de credenciales nos permitir\u00e1n  distintos niveles de acce -\nso. Para simplificar, supondremos que disponemos de las credenciales (usuario \ny contrase\u00f1a) del administrador de la base de datos (normalmente, usuario root\ny su contrase\u00f1a). En el apartado que co ncierne a la administraci\u00f3n de MySQL, \nse comenta detalladamente los aspectos re lacionados con el sistema de usuarios, \ncontrase\u00f1as y privilegios del SGBD.\n2.1.1. Servidores y clientes\nEl servidor MySQL es el servicio mysqld , que puede recibir so licitudes de clien -\ntes locales o remoto s a trav\u00e9s TCP/IP, sockets  o pipes  en forma de ficheros loca -\nles a la m\u00e1quina en que se est\u00e1 ejecutan do. En la distribuci\u00f3n se incluye un \ncliente llamado mysql-client , al que en adelante no s referiremos simplemente \ncomo mysql  (as\u00ed es como se llama el programa ejecutable). Si se invoca sin pa -\nr\u00e1metros, mysql  realiza una conexi\u00f3n al servidor  local utilizando el nombre del \nusuario UNIX que lo ha invocado, y supo ne que este usuario no requiere con -\ntrase\u00f1a. La conexi\u00f3n a un servidor remo to y un nombre de usuario espec\u00edficos \nrequiere de al menos dos argumentos:\n\u2022 -h para especificar el nombre del servidor.\n\u2022 -u para el nombre del usuario.\nPara que el programa client e pregunte la contrase\u00f1a de conexi\u00f3n al usuario, \ndeberemos proporcionar adicionalmente el par\u00e1metro -p.\n$ mysql -h servidor.misitio.org -u <usuario> -pNota\nEl servidor MySQL es mysqld .  \nA \u00e9l se pueden conectar m\u00falti-ples clientes. mysql  es el cliente \nen modo texto que proporcio-na el propio SGBD.\uf8e9 FUOC \u2022 71Z799014MO 10 Bases de datos en MySQL\n2.1.2. Conectarse y desconectarse\nSi se tiene alg\u00fan problema para realizar  la conexi\u00f3n, es ne cesario consultar con \nel administrador del sistema, que nos proporcionar\u00e1 un nombre de usuario, \ncontrase\u00f1a y el nombre del servidor, se g\u00fan sea necesario, y nos informar\u00e1 de \nlas restricciones que tiene nuestra cuenta.\nLa administraci\u00f3n y seguridad de MySQL est\u00e1 dise\u00f1ada sobre un esquema de usuarios y privilegios. Los usuarios debe n ser creados por el administrador con \nsus respectivos privilegios y restricciones. Es el administrador quien decide si \nlos nombres de los usuarios de MySQL se corresponden o no a los del sistema \noperativo.\nApariencia de  mysql al ingresar en el modo interactivo:\nCon el comando help obtenemos una serie de opciones (veremos las m\u00e1s uti -\nlizadas).\nPara salir del cliente podemos escribir \u2019 \\q\u2019 o \u2018quit\u2019:\nTanto para el comando quit como para el comando help, el punto y coma al \nfinal es opcional.\n2.2. Introducci\u00f3n de sentencias\nEl cliente de MySQL en modo interact ivo nos permite tanto la introducci\u00f3n \nde sentencias SQL para trabajar con la base de datos (crear tablas, hacer con -\nsultas y ver sus resultados, etc.) como la ejecuci\u00f3n de comandos propios del \nSGBD para obtener informaci\u00f3n sobre las tablas, \u00edndices, etc. o ejecutar opera -\nciones de administraci\u00f3n.Nota\nLos usuarios del sistema opera-\ntivo y los de MySQL no son los mismos, aunque el administra-dor de MySQL (con fines pr\u00e1c-ticos) pueda utilizar los mismos nombres para las cuentas de los usuarios MySQL.\nWelcome to the MySQL monitor. Commands end with ; or \\g.\nYour MySQL connection id is 5 to server version: 3.23.49-log\nType \u2019help;\u2019 or \u2019\\h\u2019 for help. Type \u2019\\c\u2019 to clear the buffer.\nmysql>\nmysql> quit;\nSentencias\nLas sentencias en mysql  pue-\nden abarcar m\u00faltiples l\u00edneas y terminan con punto y coma.\uf8e9 FUOC \u2022 71Z799014MO 11 Bases de datos en MySQL\n2.2.1. Sentencias\nA continuaci\u00f3n presentamos un a ejecuci\u00f3n de la sentencia select con cuatro \ncolumnas de datos:\nEn esta consulta se solicita, a trav\u00e9s de funciones incorporadas en el SGBD, el nom -\nbre del usuario actual de MySQL, el n\u00famero  de conexi\u00f3n al servidor, la versi\u00f3n del \nservidor y la base de datos en uso. Las funciones se reconocen por los par\u00e9ntesis al final. mysql entrega sus resultados en tablas, en la que el primer rengl\u00f3n son los en\n-\ncabezados de las columnas. Es importante no dejar espacio entre el nombre de una \nfunci\u00f3n y los par\u00e9ntesis, de otro modo, mysql marcar\u00e1 un mensaje de error.\nLa \u00faltima l\u00ednea entregada por mysql informa sobre el n\u00famero de filas encon -\ntrado como resultado de la consulta y el  tiempo estimado que llev\u00f3 su realiza -\nci\u00f3n. Esta medida de tiempo no se debe considerar muy precisa para medir el \nrendimiento del servidor, se trata simp lemente de un valor aproximado que \npuede verse alterado po r m\u00faltiples factores.\nObservamos que la columna con el nombre de la base de datos actual esta va -\nc\u00eda. Esto es natural, ya que no hemos creado a\u00fan ninguna base de datos ni le \nhemos indicado al gestor sobre cu\u00e1l queremos trabajar. \n2.2.2. Comandos en m\u00faltiples l\u00edneas\nLos comandos pueden expand irse en varias l\u00edneas por comodidad, sobre todo \nal escribir largas sentencias SQL. El c liente no enviar\u00e1 la sentencia SQL al ser -\nvidor hasta encontrar el punto y coma, de este modo, el comando anterior \npuede escribirse as\u00ed:mysql> select user(), connection_id(), version(), database();\n+--------------+-----------------+-------------+------------+\n|   user() | CONNECTION_ID() | version()  | database() |\n+--------------+-----------------+-------------+------------+\n| yo@localhost |    4 | 3.23.49-log |   |\n+--------------+-----------------+-------------+------------+\n1 row in set (0.00 sec)\nmysql>\nmysql> select user(),\n-> connection_id(),\n-> version(),\n-> database();\n+--------------+-----------------+-------------+------------+\n|   user() | CONNECTION_ID() | version()  | database() |\n+--------------+-----------------+-------------+------------+\n| yo@localhost |    4 | 3.23.49-log |   |\n+--------------+-----------------+-------------+------------+\n1 row in set (0.00 sec)\nmysql>\uf8e9 FUOC \u2022 71Z799014MO 12 Bases de datos en MySQL\nObs\u00e9rvese el indicador de mysql que se transforma en ->, signo que significa \nque el comando a\u00fan no es t\u00e1 completo. Tambi\u00e9n pued en escribirse varios co -\nmandos en una sola l\u00ednea, cada uno de be llevar su respec tivo punto y coma:\nSe ejecutar\u00e1n en el orden que est\u00e1n escr itos. Los comandos se pueden cancelar \ncon la combinaci\u00f3n \\c, con lo que el cliente nos volver\u00e1 a mostrar el indica -\ndor para que escribamos de nuevo la sentencia.  \n2.2.3. Cadenas de caracteres\nLas cadenas de caracteres pueden delim itarse mediante comillas dobles o sim -\nples. Evidentemente, debe n cerrarse con el mismo delimitador con el que se \nhan abierto.mysql> select now(); select user();\n+-----------------------+\n| CONNECTION_ID() |\n+-----------------------+\n|    4 |\n+-----------------------+\n1 row in set (0.00 sec)\n+-----------------------+\n|   user() |\n+-----------------------+\n|  yo@localhost |\n+-----------------------+\n1 row in set (0.01 sec)\nmysql>\nmysql> select now(),\n-> uso\n-> ver \\c\nmysql>\nIndicadores de mysql\nIndicador Significado\nmysql> Espera una nueva sentencia\n-> La sentencia a\u00fan no se ha terminado con ;\n\u201c> Una cadena en comillas do bles no se ha cerrado\n'> Una cadena en comillas simples no se ha cerrado\nmysql> select \u201cHola mundo\u201d,\u2019Felicidades\u2019;\uf8e9 FUOC \u2022 71Z799014MO 13 Bases de datos en MySQL\ny pueden escribirse en diversas l\u00edneas:\nAl principio, es com\u00fan olvidar el punt o y coma al introducir un comando y, \ntambi\u00e9n, olvidar cerrar las comillas. Si \u00e9ste es el caso, hay que recordar que \nmysql  no interpreta lo que est\u00e1 entre com illas, de tal modo que para utilizar el \ncomando de cancelaci\u00f3n \u2019\\ c\u2019 es preciso antes cerr ar las comillas abiertas:\n2.2.4. Expresiones y variables\nMySQL  dispone de variables de sesi\u00f3n, visibles \u00fanicamente durante la co -\nnexi\u00f3n actual. \u00c9stas pueden almacenar valores de tipos enteros, flotantes o ca -\ndenas, pero no tablas . Se definen como en el siguiente ejemplo:\nLa variable local @x tiene ahora el va lor 1 y puede utilizarse en expresiones:\nLas variables locales permiten almacenar datos entr e consultas y, en la pr\u00e1cti -\nca, es recomendable utiliz arlas exclusivamente con este fin, por ejemplo:mysql> select \u201c\u00c9ste es un texto\n\u201c> en dos renglones\u201d;\nmysql> select \u201c\u00c9ste es un texto\n\u201c> \\c\n\u201c> \u201c \\c\nmysql>\nmysql> select @x := 1;\nmysql> select @x, sqrt(@x), sin(@x), @x + 10, @x > 10;\n+------+----------+----------+---------+---------+\n| @x | sqrt(@x) | sin(@x)  | @x + 10 | @x > 10 |\n+------+----------+----------+---------+---------+\n| 1 | 1.000000 | 0.841471 |  11 |  0 |\n+------+----------+----------+---------+---------+\n1 row in set (0.01 sec)\nmysql> select @hora_ingreso := now();\nmysql> mysql> select now() - @ingreso;\n+-------------------+\n| now() - @ingreso |\n+-------------------+\n|  20040124138051 |\n+-------------------+\n1 row in set (0.00 sec)\uf8e9 FUOC \u2022 71Z799014MO 14 Bases de datos en MySQL\n2.2.5. Expresiones\nHay que tener cuidado con el uso de la s variables locales por los motivos si -\nguientes:\n\u2022 Se eval\u00faan en el servidor al ser enviadas por el cliente.\n\u2022 Se realizan conversiones de tipo impl\u00edcitas.\nLas variables no requiere n declaraci\u00f3n y, por omis i\u00f3n, contienen el valor \nNULL que significa \u201causencia de valor\u201d, observad en la siguiente consulta los \nresultados de utili zar valores nulos:\nLa raz\u00f3n de este comportamiento es que no es posible realizar ninguna opera -\nci\u00f3n cuando se desconoce alg\u00fan valor. La entrada de valores NULL siempre \nsignificar\u00e1 salida de valores NULL.  \n2.3. Proceso por lotes\nMySQL  puede procesar por lotes las sentenci as contenidas en un archivo de \ntexto. Cada sentencia deber\u00e1 terminar en ';' igual que si la escribi\u00e9ramos en el \ncliente. La sintaxis  es la siguiente:\nEn este caso, se realizar\u00e1 una conexi\u00f3n con el servidor, nos pedir\u00e1 la contrase\u00f1a del usuario \n\u2018juan\u2019 y, si \u00e9sta es correcta, ejecutar \u00e1 los comandos incluidos en el archivo demo.sql , uno a \nuno y por el mismo orden. Imprimir\u00e1 los resultados  (o errores) en la salida est\u00e1ndar (o de \nerror) y terminar\u00e1. De este modo evitaremos la  molestia de procesarlo s uno por uno de forma \ninteractiva.mysql> do @ingreso := now();\nmysql> select @y,\n-> sqrt( @y ),\n-> @y + 10,\n-> @y < 1 ;\n+------+------------+---------+--------+\n| @y | sqrt( @y ) | @y + 10 | @y < 1 |\n+------+------------+---------+--------+\n| NULL |  NULL |  NULL  | NULL  |\n+------+------------+---------+--------+\n1 row in set (0.00 sec)\n$ mysql -u juan -h servidor.misitio.org -p < demo.sqlNota\nEl comando do eval\u00faa expre-\nsiones sin mostrar los resulta-dos en pantalla. Se puede evaluar cualquier expresi\u00f3n que admite el comando select .\nNota\nEn una expresi\u00f3n donde cual-\nquiera de sus elementos sea NULL, autom\u00e1ticamente entre-gar\u00e1 como resultado el valor NULL.\uf8e9 FUOC \u2022 71Z799014MO 15 Bases de datos en MySQL\nOtra forma de procesar un archivo es mediante el comando source  desde el \nindicador interactivo de MySQL:\nEl archivo demo.sql  crea una nueva base de datos.\nEl usuario debe tener permisos para crea r bases de datos si quiere que sea pro -\ncesado el archivo demo.sql . Si el administrador crea la base de datos por noso -\ntros, ser\u00e1 necesario editarlo, comentando  la l\u00ednea donde se crea la base de \ndatos con el s\u00edmbolo \u2019#\u2019 al inicio:\nEs necesario procesar el  contenido del fichero demo.sql tal como los transcribi -\nmos aqu\u00ed, con el fin de poder realizar los ejemplos del resto del apartado. Si se \nobserva su contenido, posiblemente muchas cosas se expliquen por s\u00ed mismas, \nde cualquier manera, ser\u00e1n explicadas en este apartado. Tambi\u00e9n pueden eje -\ncutarse sus \u00f3rdenes en el cliente directamente.   mysql> source demo.sql\n# create database demo;\nContenido del fichero demo.sql\n#drop database demo;\ncreate database demo;\nuse demo;\n--- \n--- Estructura de la tabla productos\n---\ncreate table productos (\nparte  varchar(20),\ntipo  varchar(20) ,\nespecificaci\u00f3n varchar(20) ,\npsugerido   float(6,2),\nclave int(3)  zerofill not null auto_increment, \nprimary key (clave)\n);\ninsert into productos (parte,tipo,especificaci\u00f3n,psugerido) values\n('Procesador','2 GHz','32 bits',null),\n('Procesador','2.4 GHz','32 bits',35),\n('Procesador','1.7 GHz','64 bits',205),\n('Procesador','3 GHz','64 bits',560),\n('RAM','128MB','333 MHz',10),\n('RAM','256MB','400 MHz',35),\n('Disco Duro','80 GB','7200 rpm',60),\uf8e9 FUOC \u2022 71Z799014MO 16 Bases de datos en MySQL\n('Disco Duro','120 GB','7200 rpm',78),\n('Disco Duro','200 GB','7200 rpm',110),\n('Disco Duro','40 GB','4200 rpm',null),\n('Monitor','1024x876','75 Hz',80),\n('Monitor','1024x876','60 Hz',67)\n;\n--\n-- Estructura de la tabla 'proveedor'\n--\ncreate table proveedores (\nempresa   varchar(20) not null,\npago    set('cr\u00e9dito','efectivo'),\nprimary key (empresa)\n);\n--\n-- Valores de la tabla 'proveedor'\n--\ninsert into proveedores (empresa,pago) values \n('Tecno-k','cr\u00e9dito'),\n('Patito','efectivo'),\n('Nacional','cr\u00e9dito,efectivo')\n;\ncreate table ganancia(\nventa  enum('Por mayor','Por menor'),\nfactor  decimal(2,2)\n);\ninsert into ganancia values\n('Por mayor',1.05),\n('Por menor',1.12)\n;\ncreate table precios (\nempresa  varchar(20) not null,\nclave  int(3) zerofill not null, \nprecio  float(6,2), \nforeign key (empresa)  references proveedores,\nforeign key (clave)   references productos\n);\ninsert into precios values\n('Nacional',001,30.82),\n('Nacional',002,32.73),\n('Nacional',003,202.25),\n('Nacional',005,9.76),\n('Nacional',006,31.52),\n('Nacional',007,58.41),\n('Nacional',010,64.38),\n('Patito',001,30.40),\n('Patito',002,33.63),\n('Patito',003,195.59),\n('Patito',005,9.78),\n('Patito',006,32.44),\uf8e9 FUOC \u2022 71Z799014MO 17 Bases de datos en MySQL\nSi se desea llevar un registro de todas las operaciones de una sesi\u00f3n, se puede \nutilizar la expresi\u00f3n siguie nte; de este modo se gu ardar\u00e1n todos los comandos \ny sus resultados en archivo_registro.txt :\nPara cancelar la captura, basta con teclear lo siguiente:\n2.4. Usar bases de datos\nLa siguiente consulta in forma sobre la base de datos actualmente en uso.\nEl campo esta vac\u00edo porque no estamo s haciendo uso de ninguna base de da -\ntos. Para ver las bases de datos existentes  en el sistema, se debe efectuar la si -\nguiente consulta:('Patito',007,59.99),\n('Patito',010,62.02),\n('Tecno-k',003,198.34),\n('Tecno-k',005,9.27),\n('Tecno-k',006,34.85),\n('Tecno-k',007,59.95),\n('Tecno-k',010,61.22),\n('Tecno-k',012,62.29)\n;\nmysql> tee archivo_registro.txt\nmysql> notee\nmysql> select database();\n+------------+\n| database() |\n+------------+\n| |\n+------------+\n1 row in set (0.13 sec)\nmysql> show databases ;\n+-------------+\n|  Database |\n+-------------+\n|   demo |\n|  mysql |\n|   test |\n+-------------+\n3 rows in set (0.01 sec)\uf8e9 FUOC \u2022 71Z799014MO 18 Bases de datos en MySQL\nMySQL  nos muestra el listado de las bases de datos definidas en el servidor. \nDebe aparecer la base de datos demo que creamos con el archivo demo.sql. Para \npoder trabajar con ella, tenemos que abrirla:\nNota\nEs posible realizar consultas en una base de datos sin utilizar el comando use, en ese caso, \ntodos los nombres de las tablas deben llevar el nombre de la base de datos a que pertenecen \nde la forma: demo.productos .\nOtra posibilidad consiste en proporcionar el nombre de la base de datos al ini -\nciar una sesi\u00f3n interactiva con mysql:\nLa consulta de las tablas qu e contiene la base de datos demo  se realiza con la \nsentencia show  de la siguiente manera:  \nAsimismo, podemos consul tar las columnas de cada una de las tablas:mysql> use demo ;\n$ mysql demo -u juan -p\nmysql> show tables ;\n+----------------+\n| Tables_in_demo |\n+----------------+\n|   partes |\n|  proveedores |\n+----------------+\n2 rows in set (0.00 sec)use\nEl comando use base_de_datos  \npermite abrir una base de  \ndatos para su uso.\nNota\nEl comando show  es \u00fatil para \nmostrar informaci\u00f3n sobre las bases de datos, tablas, varia-bles y otra informaci\u00f3n sobre  \nel SGBD. Podemos utilizar help show  en el int\u00e9rprete de \ncomandos para obtener todas las variantes de esta sentencia.\nmysql> describe productos;\n+---------------+----------------------+------+------+----------+------------------+\n| Field  | Type | Null  | Key  | Default  | Extra  |\n+---------------+----------------------+------+------+----------+------------------+\n| parte | varchar(20) | YES | | NULL | |\n| tipo | varchar(20) | YES | | NULL | |\n| especificicaci\u00f3n | varchar(20) | YES | | NULL | |\n| Field | float(6,2) | YES | | NULL | |\n| Field | int(3) unsigned zerofill | YES | PRI | NULL | auto_increment |\n+---------------+----------------------+------+------+----------+------------------+\n5 rows in set (0.00 sec)\uf8e9 FUOC \u2022 71Z799014MO 19 Bases de datos en MySQL\nPara crear una nueva base de datos usaremos la sentencia create database :\nPara eliminar una base de da tos, usaremos la sentencia drop database :\nMySQL es sensible al uso de may\u00fasculas  y min\u00fasculas, tanto en la definici\u00f3n \nde bases de datos, como de tablas o columnas. mysql> create database  prueba;\nmysql> drop database  prueba;\uf8e9 FUOC \u2022 71Z799014MO 20 Bases de datos en MySQL\n3. Creaci\u00f3n y manipulaci\u00f3n de tablas\n3.1. Crear tablas\nUna vez realizada la conexi\u00f3n con el servidor MySQL y despu\u00e9s de abrir una \nbase de datos, podemos crear tablas en ella de la siguiente manera:\nEn este caso, la sentencia create table  construye una nueva tabla en la base \nde datos en uso. La tabla contiene tres columnas, nombre , direcci\u00f3n y tel\u00e9fono , \ntodas de tipo car\u00e1cter y de longitudes 30, 40 y 15 respectiva mente. Si se inten -\nta guardar en ellas valores que sobrepas en esos l\u00edmites, ser\u00e1n truncados para \npoderlos almacenar. Por ese motivo, es importante reservar espacio suficiente \npara cada columna. Si se prev\u00e9 que mu chos registros ocupar\u00e1n s\u00f3lo una frac -\nci\u00f3n del espacio reservado, se puede utilizar el tipo varchar , similar a char , \ncon la diferencia de que el valor ocupar \u00e1 un espacio menor al especificado si \nla cadena es m\u00e1s corta que el m\u00e1ximo indicado, ahorrando as\u00ed espacio de al -\nmacenamiento.\nLos nombres de las columnas admiten caracteres acentuados. \nLas tablas pueden  eliminarse con drop table :\nAlternativamente, se puede ut ilizar la sintaxis siguiente:mysql> create table  personas (\n-> nombre char(30),\n-> direcci\u00f3n char(40),\n-> tel\u00e9fono char(15)\n-> );\nQuery OK, 0 rows affected (0.02 sec)\nmysql> drop table  personas;\nQuery OK, 0 rows affected (0.01 sec)\nmysql> drop table if exists personas;\n\uf8e9 FUOC \u2022 71Z799014MO 21 Bases de datos en MySQL\nAtributos de columna\nVe\u00e1moslo con un ejemplo:\nEn este caso la tabla contiene cuatro columnas, de las cuales nombre y edo_civil \npermiten valores nulos, en edo_civil est\u00e1 impl\u00edcito al no de clarar lo contrario. \nLa columna num_registro no acepta valores nulos po rque est\u00e1 definida como \nclave primaria.  \nAunque la creaci\u00f3n de una clave primar ia puede declararse como atributo de \ncolumna, es conveniente de finirla como restricci\u00f3n de tabla, como se ver\u00e1 en -\nseguida. \nTambi\u00e9n es posible indicar restricciones sobre la tabla y no sobre columnas es -\npecificas:Atributo Significado\nnullSe permiten valores nulos, atributo por omisi\u00f3n si no se especifica  \nlo contrario.\nnot null No se permiten valores nulos.\ndefault  valor Valor por omisi\u00f3n que se asigna a la columna.\nauto_incrementEl valor se asigna autom\u00e1ticament e incrementando en uno el m\u00e1ximo \nvalor registrado hasta ahora. Se aplica s\u00f3lo a las columnas marcadas como clave primaria.\nprimary keySe\u00f1ala al campo como clave primaria, impl\u00edcitamente tambi\u00e9n  \nlo declara como not null .\nmysql> create table  personas (\n-> nombre varchar(40) not null ,\n-> direcci\u00f3n varchar(50) null,\n-> edo_civil char(13) default \u2019Soltero\u2019,\n-> num_registro int primary key auto_increment ,\n-> );\nQuery OK, 0 rows affected (0.01 sec)\nmysql> create table  personas (\n-> nombre varchar(40) not null ,\n-> nacimiento date not null ,\n-> pareja varchar(40),\n-> proveedor int not null ,\n->\n-> primary key (nombre,nacimiento),\n-> unique (pareja),\n-> foreign key  (proveedor) references  proveedores\n-> );\nQuery OK, 0 rows affected (0.01 sec)Nota\nLa definici\u00f3n de columnas tie-\nne el siguiente formato:\nnombre_columna tipo  \natributos.\n\uf8e9 FUOC \u2022 71Z799014MO 22 Bases de datos en MySQL\nRestricciones de tabla\nSe definen tres restricciones sobre la tabla despu\u00e9s de la definici\u00f3n de cuatro \ncolumnas:\n\u2022 La primera restricci\u00f3n se refiere a la clave primaria, compuesta por las co -\nlumnas nombre y nacimiento : no puede haber dos personas que se llamen \nigual y que hayan nacido en la mism a fecha. La clave primaria permite \nidentificar de manera un\u00edvoca cada registro de la tabla.\n\u2022 La segunda restricci\u00f3n define que la pa reja de una persona debe ser \u00fanica: \ndos personas no pueden tener la misma pareja. Todo intent o de insertar un \nnuevo registro donde el nombre de la  p a r e j a  y a  e x i s t a , ser\u00e1 rechazado. \nCuando se restringe una columna con unique , los valores null reciben un \ntrato especial, pues se perm iten m\u00faltiples valores nulos .\n\u2022 La tercera restricci\u00f3n afecta a la columna proveedor , s\u00f3lo puede tomar valo -\nres que existan en la clav e primaria de la tabla proveedores .\nLas restricciones de tabla pueden defini rse con un identifica dor \u00fatil para hacer \nreferencias posteriore s a la restricci\u00f3n:\nkey / index\nLa definici\u00f3n de \u00edndices puede hacerse tambi\u00e9n en el momento de creaci\u00f3n de la tabla, me -\ndiante la palabra clave key (o index), a la qu e deberemos proporcionar el nombre que vamos \na asignar a esta clave y las columnas que la forman, entre par\u00e9ntesis. Existen modificadores \nopcionales sobre el \u00edndice que nos permiten especificar si se trata de un \u00edndice \u00fanico o m\u00fal -\ntiple (seg\u00fan puedan existir o no varios valores iguales del \u00edndice en la tabla).\nEn versiones recientes de MySQL existen otros tipos de \u00edndices (espaciales, de texto comple -\nto, etc.) para tipos de datos concretos y que ofrecen prestaciones adicionales.Restricci\u00f3n Significado\nprimary keyDefine la o las columnas que servir\u00e1n como clave primaria.  \nLas columnas que forman parte de la clave primaria deben  \nde ser not null .\nuniqueDefine las columnas en las que no pueden duplicarse valores. \nSer\u00e1n las claves candidatas del modelo relacional.\nforeign key (columna ) \nreferences tabla \n(columna2 ) Define que los valores de columna  se permitir\u00e1n s\u00f3lo si existen \nen tabla(columna2).  Es decir, columna  hace referencia a los \nregistros de tabla , esto asegura que no se realicen referencias  \na registros que no existen.\nmysql> create table  personas (\n-> nombre varchar(40) not null ,\n-> nacimiento date not null ,\n-> pareja varchar(40),\n-> proveedor int not null ,\n->\n-> constraint  clave primary key  (nombre,nacimiento),\n-> constraint  monogamo unique (pareja),\n-> constraint  trabaja_en foreign key  (proveedor) references\nproveedores\n-> );Claves for\u00e1neas\nLas restricciones de tabla  \nforeign key  no tienen efecto \nalguno en MySQL 4.0 y ante-riores, ya que esta caracter\u00edsti-ca no est\u00e1 implementada. Se admite en la sintaxis por com-patibilidad, ya que ser\u00e1 imple-mentada en una versi\u00f3n posterior. En la versi\u00f3n 4.1, est\u00e1 soportada si se utiliza  \nel tipo de tabla InnoDB.\uf8e9 FUOC \u2022 71Z799014MO 23 Bases de datos en MySQL\n3.2. Tipos de datos\nMySQL cuenta con un rico conjunto de tipos de datos para las columnas, que \nes necesario conocer para elegir mejor c\u00f3mo definir las tablas. Los tipos de da -\ntos se pueden clasificar en tres grupos:\n\u2022N u m \u00e9 r i c o s .\n\u2022 Cadenas de caracteres\n\u2022 Fechas y horas\nEl valor null es un caso especial de dato, ya que al significar ausencia de valor \nse aplica a todos los tipos de columna. Los siguientes s\u00edmbolos se utilizan en \nla definici\u00f3n y descripci\u00f3n de los tipos de datos en MySQL:\n\u2022M - El ancho de la columna en n\u00famero de caracteres.\n\u2022D - N\u00famero de decimales que hay que mostrar.\n\u2022L - Longitud o tama\u00f1o real de una cadena.\n\u2022[ ] - Lo que se escriba entre ellos es opcional.\n3.2.1. Tipos de datos num\u00e9ricos\nLos tipos de datos num\u00e9ricos comprenden dos categor\u00edas, los enteros y los n\u00fa -\nmeros con punto flotante.\nN\u00fameros enteros\nLa principal diferencia entre cada uno de  los tipos de enteros es su tama\u00f1o, que \nva desde 1 byte de almacenamiento hasta los 8 bytes. Las columnas de tipo en -\ntero pueden recibir dos atributos adicionales, que deben especificarse inmedia -\ntamente despu\u00e9s del nombre del tipo:\n\u2022unsigned. Indica que el entero no podr\u00e1 almacenar valores negativos. Es \nresponsabilidad del usuario verificar, en  este caso, que los resultados de las \nrestas no sean negativos, porque  MySQL los convierte en positivos.\n\u2022zerofill. Indica que la columna, al ser mo strada, rellenar\u00e1 con ceros a la iz -\nquierda los espacios vac\u00ed os. Esto de acuerdo al valor especificado por M en \nla declaraci\u00f3n del tipo. Un a columna con el atributo zerofill es al mismo \ntiempo unsigned aunque no se especifique.\nEjemplo\nEl comando anterior crea una tabla con dos columnas. Ambas ocupar\u00e1n un espacio de 4 \nbytes, pero al mostrarse, la columna x ocupar\u00e1 un espacio de 4 d\u00edgitos y la columna y, de 5.create table  n\u00fameros (\nx int(4) zerofill not null ,\ny int(5) unsigned\n);\uf8e9 FUOC \u2022 71Z799014MO 24 Bases de datos en MySQL\nTanto zerofill como unsigned deben escribirse siempre antes que cualquier \notro atributo de columna. \nTipos enteros\nN\u00fameros con punto flotante\nMySQL cuenta con los tipos float y double , de 4 y 8 bytes de almacenamiento. \nAdem\u00e1s incluye el tipo decimal, que se almacena como una cadena de carac -\nteres y no en formato binario.\nN\u00fameros de punto flotante\n3.2.2. Cadenas de caracteres\nCadenas de caracteres\nSi observamos la tabla, vemos que el \u00fan ico tipo de dato que siempre utiliza el \ntama\u00f1o especificado por M es el tipo char . Por este motivo, se ofrece el tipo \nvarchar que ocupa s\u00f3lo el espacio requer ido por el valor de la columna.\nEjemploTipo Espacio de almacenamiento Significado\ntinyint [(M)]  1 byte Entero muy peque\u00f1o\nsmallint [(M)] 2 bytes Entero peque\u00f1o\nmediumint [(M)] 3 bytes Entero mediano\nint[(M)]  4 bytes Entero\nbigint [(M)] 8 bytes Entero grande\nTipoEspacio\nde almacenamientoSignificado\nfloat 4 bytes Simple precisi\u00f3n\ndouble 8 bytes Doble precisi\u00f3n\ndecimal M + 2 bytesCadena de caracteres representando un n\u00famero flotante\nTipo EquivalenteTama\u00f1o\nm\u00e1ximoEspacio\nde almacenamiento\nchar[(M)] M bytes M bytes\nvarchar [(M)] M bytes L+1 bytes\ntinytext  tinyblob 28\u22121 bytes L+1 bytes\ntext blob 216\u22121 bytes L+2 bytes\nmediumtext mediumblob 224\u22121 bytes L+3 bytes\nlongtext longblob 232\u22121 bytes L+4 bytes\nenum (\u2019v1\u2019,\u2019v2\u2019,. . . ) 65535 valores 1 o 2 bytes\nset(\u2019v1\u2019,\u2019v2\u2019,. . . ) 64 valores 1 a 8 bytes\ncreate table  persona(\ncomentario char(250),\nrecado varchar(250)\n);\n\uf8e9 FUOC \u2022 71Z799014MO 25 Bases de datos en MySQL\nLa columna comentario  ocupar\u00e1 250 bytes de espacio de almacenamiento, sin importar el va -\nlor almacenado. Por el contrario, la columna recado  ocupar\u00e1 s\u00f3lo el espacio necesario seg\u00fan \nel valor asignado; por ejemplo, la cadena \u201c Instalar MySQL \u201d tiene 14 bytes de longitud, y el \ncampo recado  ocupar\u00eda 15 bytes para almacenarla.\nLos tipos text y blob son equivalentes , pero text respeta las may\u00fasculas, mi -\nn\u00fasculas y caracteres acentuados en la ordenaci\u00f3n.\nEjemplo del uso de los tipos enumerados o enum\nLa columna edo_civil  de la tabla en la sentencia anteri or, solo podr\u00e1 almacenar los valores \n\u2019soltero \u2019, \u2019casado \u2019, \u2019viudo \u2019, \u2019divorciado \u2019, que son especificados por el tipo enum . La columna \nocupar\u00e1 el espacio de un byte, ya que los valores enum son repres entados internamente \npor n\u00fameros.\n3.2.3. Fechas y horas\nFechas y horas\n3.3. Modificar tablas\n3.3.1. Agregar y eliminar columnas\nAlterar la estructura de una tabla es un a tarea m\u00e1s frecuente de lo que uno pue -\nde imaginar en un pr incipio. La sentencia alter table  permite una amplia \ngama de formas de modifi car una tabla. La siguient e sentencia nos recuerda \nun poco a la estructura de la sentencia create table , en donde modificamos la \ntabla personal creada en la secci\u00f3n anterior.   create table  persona(\nedo_civil enum(\u2019soltero\u2019,\u2019casado\u2019,\u2019viudo\u2019,\u2019divorciado\u2019)\n);\nTipoEspacio \nde almacenamientoRango\ndate 3 bytes  \u20191000-01-01\u2019 al \u20199999-12-31\u2019\ntime 3 bytes  \u2019-838:59:59\u2019 a \u2019838:59:59\u2019\ndatetime 8 bytes \u20191000-01-01 00:00:00\u2019 a \u20199999-12-31 23:59:59\u2019\ntimestamp[(M)] 4 bytes 19700101000000 al a\u00f1o 2037\nyear[(M)] 1 byte 1901 a 2155\nmysql> alter table  personal add (\n-> mascota char(30) default \u2019perro\u2019,\n-> pasatiempo char (20) not null\n-> );Nota\nSiempre es posible consultar la \nestructura de una tabla con el comando describe tabla .\uf8e9 FUOC \u2022 71Z799014MO 26 Bases de datos en MySQL\nDespu\u00e9s de ejecutar la sentencia anteri or, aparecen dos nuevas columnas en \nla tabla. Si queremos agregar una sola  columna, podemos us ar la sintaxis si -\nguiente:\nEste formato de alter table  permite, adem\u00e1s, insert ar las columnas antes \n(before ) o despu\u00e9s ( after ) de una columna en cuesti\u00f3n.\nLas columnas no deseadas pued en eliminarse con la opci\u00f3n drop .\n3.3.2. Modificar columnas\nLa modificaci\u00f3n de una columna con la opci\u00f3n modify es parecida a volver a \ndefinirla.\nDespu\u00e9s de la sentencia anterior, los atributos y tipo de la columna han cam -\nbiado por los especificados. Lo que no se  puede cambiar con esta sintaxis es el \nnombre de la columna. Para el lo, se debe utilizar la opci\u00f3n change:\nLa columna que se llamaba nom cambia a nombre .\nCon el mismo comando alter table podemos incluso realizar la ordenaci\u00f3n f\u00ed -\nsica de una tabla bajo una columna espec\u00edfica:  mysql> alter table  personal add capital int not null\n-> after nom;\nmysql> alter table  personal drop pasatiempo;\nmysql> alter table  personal modify\n-> mascota char (14) default \u2019gato\u2019;\nmysql> alter table  personal change nom\n-> nombre char(20);\nmysql> alter table  personal order by  nom;\nQuery OK, 0 rows affected (0.06 sec)\nRecords: 0 Duplicates: 0 Warnings: 0Nota\nEn general, una tabla no puede \ndurar mucho tiempo con un order  respecto a una colum-\nna, ya que las inserciones no se realizar\u00e1n respetando el orden establecido. Solamente en ta-blas que no van a ser actualiza-das es \u00fatil aplicar este comando.\uf8e9 FUOC \u2022 71Z799014MO 27 Bases de datos en MySQL\nFinalmente, podemos cambia r de nombre la tabla:\n3.4. Otras opciones\n3.4.1. Copiar tablas\nAunque no existe un coma ndo expl\u00edcito para copiar tablas de una base de da -\ntos a otra, es posibl e utilizar el comando rename table para este prop\u00f3sito; \nbasta con especificar la base de datos a la que pertenece una tabla:\nTambi\u00e9n es posible crear una tabla nueva con el contenido de otra ya existente \n(copiando los datos):\nLa siguiente sentencia es equivalente, pero  no copia los datos de la tabla origen:\n3.4.2. Tablas temporales\nMySQL permite la creaci\u00f3n de tablas temp orales, visibles exclusivamente en la se -\nsi\u00f3n abierta, y guardar datos entre consul tas. La creaci\u00f3n de una tabla temporal \ns\u00f3lo requiere la utiliz aci\u00f3n de la palabra temporary  en cualquier formato del co -\nmando create  table . La utilidad de las tablas temp orales se limita a consultas com -\nplejas que deben generar resultados in termedios que debemos consultar (hacer \n'join' con ellas) varias veces o en consultas separadas. Internamente, MySQL ge -\nnera tambi\u00e9n tablas temporales para resolver determinadas consultas:mysql> alter table  personal rename gente;\nmysql> rename table  base_uno.tabla to base_dos.tabla; \nmysql> create table  nueva_tabla select * from otra_tabla;\nmysql> create table  nueva_tabla like otra_tabla;\nmysql> create temporary  table nueva_tabla ...rename table\nEl comando rename  \ntable  viejo_nombre  to \nnuevo_nombre  es una forma  \nalternativa de cambiar el  \nnombre a una tabla.\uf8e9 FUOC \u2022 71Z799014MO 28 Bases de datos en MySQL\n4. Consultas\nComo ya hemos explicado, las consultas sobre la base de datos se ejecutan me -\ndiante sentencias SELECT introducidas en el propio progra ma cliente y los re -\nsultados se presentan en forma de tabla.\n4.1. La base de datos demo\nEn esta secci\u00f3n utilizarem os la base de datos demo que hemos creado con el \ncomando source demo.sql . As\u00ed que, antes de estudiar las consultas en MySQL, \nrevisaremos brevemente la estructura de esta base de datos, que consta de las \nsiguientes tablas:  \nLas cuatro tablas representan, de manera ficticia , la base de datos de un distribuidor de equi -\npos de procesamiento. Est\u00e1n dise\u00f1adas para serv ir de ejemplo a los casos presentados en este \ncap\u00edtulo, por lo que no necesariamente ser\u00e1n \u00fatiles en la vida real.\nEn nuestro ejemplo imaginario repr esentamos la siguiente situaci\u00f3n.\n\u2022 Nuestro vendedor tiene una relaci\u00f3n de proveedores que venden sus produc -\ntos a cr\u00e9dito, en efectivo o ambos. Las compras a cr\u00e9dito pagan intereses, \npero son \u00fatiles porque no siempre es posible pagar en efectivo. Se utiliza una \ncolumna de tipo conjunto para pago, que puede tomar los valores \u2019 cr\u00e9dito \u2019, \n\u2019efectivo \u2019 o ambos:\nLos productos que se distribuyen son partes de equipo de c\u00f3mputo. Para la \nmayor\u00eda de los productos en el mercado, los fabricantes sugieren un precio de \nventa al p\u00fablico que, aunque no es obligatorio, los consumidores no est\u00e1n dis -\npuestos a pagar m\u00e1s. Las claves de los productos son asignadas para control mysql> show tables ;\n+----------------+\n| Tables_in_demo |\n+----------------+\n|  ganancia |\n|   precios |\n|  productos |\n|  proveedores |\n+----------------+\ncreate table  proveedores (\nempresa varchar(20) not null ,\npago set(\u2019cr\u00e9dito\u2019,\u2019efectivo\u2019),\nprimary key  (empresa)\n);Pode\u00eds ver la creaci\u00f3n de la base de \ndatos demo  en el apartado \u201cProceso \npor lotes\u201d de esta misma unidad did\u00e1ctica.\n\uf8e9 FUOC \u2022 71Z799014MO 29 Bases de datos en MySQL\ninterno con un n\u00famero consecutivo. Con estas especificaciones, la tabla pro-\nductos se define de la manera siguiente:\n\u2022 La empresa define una pol\u00edtica para las ganancias m\u00edni mas que se deben \nobtener en ventas: el 5% al por mayor y el 12% al por menor. Estos valores \nse almacenan en la tabla ganancias , donde se decidi\u00f3 incluir una columna \nde nombre factor , con el n\u00famero por el que se multiplica el precio de compra \npara obtener el precio de venta. Los tipos de venta \u2018 Por mayor \u2019 y \u2018Por menor \u2019\nse definen con un tipo de datos enum :\n\u2022 La lista de precios se define a partir de la empresa proveedor y el producto, \nasign\u00e1ndole un precio. Por ese motivo, las columnas empresa  y clave  se de -\nfinen como foreign key .\n4.2. Consultar informaci\u00f3n\nMySQL ofrece un conjunto muy amplio de funciones auxiliares (tanto est\u00e1nda -\nres como propias) que nos pueden ayudar mucho en determinados momentos, \ndejando parte del trabajo de manipular los resultados al propio gestor. Debido \nal r\u00e1pido ritmo en el desarrollo de este SGBD, es muy conveniente consultar \nsiempre la documentaci\u00f3n de nuestra versi\u00f3n para conocer sus posibilidades \nconcretas. create table  productos (\nparte varchar(20),\ntipo varchar(20) ,\nespecificaci\u00f3n varchar (20) ,\npsugerido float(6,2),\nclave int(3) zerofill not null auto_increment ,\nprimary key (clave)\n);\ncreate table  ganancia(\nventa enum(\u2019Por mayor\u2019,\u2019Por menor\u2019),\nfactor decimal (2,2)\n);\ncreate table  precios (\nempresa varchar(20) not null ,\nclave int(3) zerofill not null ,\nprecio float(6,2),\nforeign key  (empresa) references  proveedores,\nforeign key  (clave) references  productos\n);\n\uf8e9 FUOC \u2022 71Z799014MO 30 Bases de datos en MySQL\nEn el m\u00f3dulo 3 de este curso ya estudiam os en detalle el Lenguaje SQL, por lo \nque no vamos a extendernos aqu\u00ed en su  uso y posibilidades . \u00danicamente mos -\ntraremos los aspectos dest acables, facilidades o limit aciones que ofrece MySQL \nrespecto a \u00e9l.\n4.2.1. Funciones auxiliares\nLas funciones auxiliares que podemos utiliz ar en nuestras consultas (tanto en \nla proyecci\u00f3n de las columnas como en  condiciones en su selecci\u00f3n) se pue -\nden clasificar seg\u00fan el tipo de datos con el que trabajan.\nEjemplo\nAlgunos ejemplos de la s funciones m\u00e1s usadas:\nOperadores l\u00f3gicos\nComparaci\u00f3n. Aparte de los est\u00e1ndares =, !=, <, >, IS NULL, IS NOT NULL, \nBETWEN, IN, destacan COALESCE, INTE RVAL, LEAST, GREATEST para tra -\nbajar con listas de valores.\nControl del flujo de ejecuci\u00f3n\n\u2022 CASE .. WHEN .. THEN .. ELSE .. END:  Similar a la estr uctura que crear\u00eda -\nmos mediante cualquier lenguaje de programaci\u00f3n:mysql> select concat(parte,\u2019 \u2019,tipo) as producto,\n-> psugerido as \u2019precio sugerido\u2019,\n-> psugerido + 10 as precio_con_envio\n-> from productos;\n+--------------------+-----------------+------------------+\n|   producto | precio sugerido | precio_con_envio |\n+--------------------+-----------------+------------------+\n| Procesador 2 GHz |    NULL  |    NULL |\n| Procesador 2.4 GHz |   35.00  |    45.00 |\n| Procesador 1.7 GHz |   205.00  |   215.00 |\n| Procesador 3 GHz |   560.00  |   570.00 |\n|     RAM 128MB |   10.00  |    20.00 |\n|     RAM 256MB |   35.00  |    45.00 |\n| Disco Duro 80 GB |   60.00  |    70.00 |\n| Disco Duro 120 GB |   78.00  |    88.00 |\n| Disco Duro 200 GB |   110.00  |   120.00 |\n| Disco Duro 40 GB |    NULL  |    NULL |\n| Monitor 1024x876 |   80.00  |    90.00 |\n| Monitor 1024x876 |   67.00  |    77.00 |\n+--------------------+-----------------+------------------+\n12 rows in set (0.00 sec)\nmysql> SELECT CASE WHEN 1>0 THEN 'true' ELSE 'false' END;\n+--------------------------------------------+\n| CASE WHEN 1>0 THEN 'true' ELSE 'false' END |\n+--------------------------------------------+\n| true |\n+--------------------------------------------+\n1 row in set (0.00 sec)\uf8e9 FUOC \u2022 71Z799014MO 31 Bases de datos en MySQL\n\u2022I F ( e x p r 1 ,expr2 ,expr3): T\u00edpica estructura condic ional, si la expr1 es cierta, \ndevuelve la expr2, en ca so contrario, la expr3:\nFunciones para trabajar con cadenas de caracteres (s\u00f3lo algunos ejemplos)\n\u2022 CONCAT, INSTR (encontrar en una cadena), SUBSTRING, LCASE/RCASE, \nLENGTH, REPLACE, TRIM, entre otras,  son funciones similares a las que \npodemos encontrar en leng uajes de programaci\u00f3n para manipular cadenas \nde caracteres.\n\u2022 QUOTE: delimita una cadena de texto correctamente para evitar proble -\nmas al usarla en sentencias SQL. La cadena resultante estar\u00e1 delimitada por \ncomillas simples. Las comillas, el va lor ASCII NUL y otros potencialmente \nconflictivos ser\u00e1n devueltos pr ecedidos del car\u00e1cter '\\'.\n\u2022 ENCODE/DECODE, CRYPT, COMPRESS /UNCOMPRESS, MD5, etc. son \nfunciones que nos pueden ayudar mucho en el almacenamiento de datos sensibles como co ntrase\u00f1as, etc.\nFunciones num\u00e9ricas\n\u2022 Los operadores aritm\u00e9ticos cl\u00e1sicos para  realizar todo tipo de operaciones, \nsuma, resta, divisi\u00f3n, producto, divisi\u00f3n entera, etc.\n\u2022 Funciones matem\u00e1ticas de todo tipo, trigonom\u00e9tricas, logar\u00edtmicas, etc.\nFunciones para trabajar con fechas y horas\n\u2022 Obtenci\u00f3n de fechas en cualquie r formato: DATE_FORMAT, DATE, NOW, \nCURRDATE, etc.\n\u2022 Manipulaci\u00f3n y c\u00e1lculos con fechas : ADDDATE, ADDTIME, CONVERT_TZ, \nDATE_DIFF, etc.\n4.2.2. La sentencia EXPLAIN\nMySQL nos ofrece tambi\u00e9n facilidades a la  hora de evaluar la s sentencias SQL, \ngracias a la sentencia EXPLAIN.mysql> SELECT IF(STRCMP('test','test1'),'no','yes');\n+---------------------------------------+\n| IF(STRCMP('test','test1'),'no','yes') |\n+---------------------------------------+\n| no |\n+---------------------------------------+\n1 row in set (0.00 sec)\uf8e9 FUOC \u2022 71Z799014MO 32 Bases de datos en MySQL\nPresentamos primero la ej ecuci\u00f3n de una sentencia SQL m\u00e1s o menos compleja:\nAhora utilizamos la sentencia EXPLAIN para que MySQL nos explique c\u00f3mo \nha realizado esta consulta:\nmysql> explain select productos.clave, co ncat(parte,' ',tipo,' ', especificaci\u00f3n) \nas producto, provee dores.empresa , precio , pago  from productos natural join \nprecios natural jo in proveedores;\nEn cada fila del resultad o, nos explica c\u00f3mo ha ut ilizado los \u00edndices de cada \ntabla involucrada en la cons ulta. La columna 'type' nos indica el tipo de \u201cjoin\u201d \nque ha podido hacer. En nuestro caso, 'e q_ref', 'ref' o 'ref_or_null' indica que \nse ha consultado una fila de esta tabl a para cada combinac i\u00f3n de filas de las \notras. Es una buena se\u00f1al, se est\u00e1n utiliz ando los \u00edndices, tal como indican el \nresto de columnas (en concreto el atri buto 'clave' que es su clave primaria).\nVemos que en las otras dos ta blas, el tipo de 'join' es ALL, esto indica que el \ngestor ha tenido que leer toda la tabl a para comprobar las condiciones que le \nhemos exigido en la consulta. En el caso  de la tabla proveedores, habr\u00eda podi -\ndo utilizar la clave primaria ('poss ible_keys'), pero no lo ha hecho.mysql> select productos.clave, concat(parte,' ',tipo,' ', especificaci\u00f3n) as producto, proveedores.em -\npresa , precio , pago from productos natural join precios natural join proveedores;\n+-------+----------------------------+----------+--------+------------------+\n| clave | producto  | empresa | precio | pago |\n+-------+----------------------------+----------+--------+------------------+\n|  003 | Procesador 1.7 GHz 64 bits | Tecno-k | 198.34 | cr\u00e9dito |\n|  005 | RAM 128MB 333 MHz  | Tecno-k | 9.27 | cr\u00e9dito |\n|  006 | RAM 256MB 400 MHz  | Tecno-k | 34.85 | cr\u00e9dito |\n|  007 | Disco Duro 80 GB 7200 rpm  | Tecno-k | 59.95 | cr\u00e9dito |\n|  010 | Disco Duro 40 GB 4200 rpm  | Tecno-k | 61.22 | cr\u00e9dito |\n|  012 | Monitor 1024x876 60 Hz  | Tecno-k | 62.29 | cr\u00e9dito |\n|  001 | Procesador 2 GHz 32 bits  | Patito | 30.40 | efectivo |\n|  002 | Procesador 2.4 GHz 32 bits | Patito | 33.63 | efectivo |\n|  003 | Procesador 1.7 GHz 64 bits | Patito | 195.59 | efectivo |\n|  005 | RAM 128MB 333 MHz  | Patito | 9.78 | efectivo |\n|  006 | RAM 256MB 400 MHz  | Patito | 32.44 | efectivo |\n|  007 | Disco Duro 80 GB 7200 rpm  | Patito | 59.99 | efectivo |\n|  010 | Disco Duro 40 GB 4200 rpm  | Patito | 62.02 | efectivo |\n|  001 | Procesador 2 GHz 32 bits  | Nacional | 30.82 | cr\u00e9dito,efectivo |\n|  002 | Procesador 2.4 GHz 32 bits | Nacional | 32.73 | cr\u00e9dito,efectivo |\n|  003 | Procesador 1.7 GHz 64 bits | Nacional | 202.25 | cr\u00e9dito,efectivo |\n|  005 | RAM 128MB 333 MHz  | Nacional | 9.76 | cr\u00e9dito,efectivo |\n|  006 | RAM 256MB 400 MHz  | Nacional | 31.52 | cr\u00e9dito,efectivo |\n|  007 | Disco Duro 80 GB 7200 rpm  | Nacional | 58.41 | cr\u00e9dito,efectivo |\n|  010 | Disco Duro 40 GB 4200 rpm  | Nacional | 64.38 | cr\u00e9dito,efectivo |\n+-------+----------------------------+----------+--------+------------------+\n20 rows in set (0.00 sec)\n+-------------+--------+---------------+---------+---------+---------------+------+------------+\n| table  | type | possible_keys | key  | key_len | ref  | rows | Extra  |\n+-------------+--------+---------------+---------+---------+---------------+------+------------+\n| precios | ALL | NULL    | NULL |  NULL | NULL   | 20 |     |\n| productos | eq_ref | PRIMARY   | PRIMARY |    4 | precios.clave|  1 |     |\n| proveedores | ALL | PRIMARY   | NULL |  NULL | NULL   | 3 | where used |\n+-------------+--------+---------------+---------+---------+---------------+------+------------+\n3 rows in set (0.00 sec)\uf8e9 FUOC \u2022 71Z799014MO 33 Bases de datos en MySQL\nVamos a intentar mejorar esta consulta. Vemos que en la tabla precios no se \nha definido ning\u00fan \u00edndice, lo qu e facilitar\u00eda la labor al SGBD:\nLas cosas han cambiado sustancialmente. El gestor ha pasado de leer 24 filas \nde datos, a leer 11. Tambi\u00e9n ha cambiado  el orden de lectura de las tablas, ha -\nciendo primero una lectura total de la tabla proveedores (que es inevitable ya \nque no hemos puesto ning una condici\u00f3n en el SELECT) y, despu\u00e9s, ha apro -\nvechado los \u00edndices definidos en 'precios' y en 'productos'.\n4.3. Manipulaci\u00f3n de filas\nPara la manipulaci\u00f3n de filas dispon emos de las sentencias SQL INSERT, UP -\nDATE y DELETE, su uso y sintaxis ya se ha visto en el m\u00f3dulo 3 de este curso. \nEn algunos casos, MySQL nos proporci ona extensiones o modificadores que \nnos pueden ayudar mucho en determinadas situaciones.\n\u2022 INSERT [DELAYED]. Cuando la senten cia INSERT puede tardar mucho en \ndevolver el resultado (tablas muy grandes o con muchos \u00edndices que deben \nrecalcularse al insertar una nueva fila ) puede ser interesante a\u00f1adir la pala -\nbra clave DELAYED para que MySQL nos devuelva el control y realice la in -\nserci\u00f3n en segundo plano.\n\u2022 INSERT [[LOW_PRIORITY] | [HIGH_PRIO RITY]]. En tablas muy ocupadas, \ndonde muchos clientes realizan cons ultas constantemen te, una inserci\u00f3n \nlenta puede bloquear al resto de clie ntes durante un tiempo. Mediante es -\ntos modificadores podemos variar este comportamiento.\n\u2022 INSERT [IGNORE]. Este mo dificador convierte los e rrores de inserci\u00f3n en \navisos. Por ejemplo, si intentamos in sertar una fila que duplica una clave \nprimaria existente, el SG BD nos devolver\u00e1 un aviso (y no insertar\u00e1 la nueva \nfila), pero nuestro programa cliente po dr\u00e1 continuar con su cometido si el \nresultado de la inserci\u00f3n no era im portante para su correcta ejecuci\u00f3n.mysql> alter table precios add index empresa_idx (empresa);\nQuery OK, 20 rows affected (0.00 sec)\nRecords: 20 Duplicates: 0 Warnings: 0\nmysql> alter table precios add index clave_idx (clave);\nQuery OK, 20 rows affected (0.00 sec)\nRecords: 20 Duplicates: 0 Warnings: 0\nmysql> explain select productos.clave, concat(parte,' ',tipo,' ', especificaci\u00f3n) as producto, \nproveedores.empresa , precio , pago from productos natural join precios natural join proveedores;\n+-------------+--------+-----------------------+-------------+---------+--------------+-----+-----------+\n| table  | type | possible_keys | key | key_len | ref  |rows | Extra  |\n+-------------+--------+-----------------------+-------------+---------+--------------+-----+-----------+\n| proveedores | ALL | PRIMARY | NULL | NULL | NULL  | 3  | |\n| precios | ref | empresa_idx,clave_idex| empresa_idx | 20 | productos.emp| 7 | |\n| productos | eq_ref | PRIMARY   | PRIMARY | 4 | precios.clave| 1 | |\n+-------------+--------+-----------------------+-------------+---------+--------------+-----+-----------+\n3 rows in set (0.00 sec)\nVeremos m\u00e1s sobre los \u00edndices  \nen el subapartado 5.5 \u201cAn\u00e1lisis  \ny optimizaci\u00f3n\u201d de esta unidad did\u00e1ctica. \n\uf8e9 FUOC \u2022 71Z799014MO 34 Bases de datos en MySQL\n\u2022 UPDATE [LOW_PRIORITY] [IGNORE]. Se  comportan de igual modo que en \nla sentencia INSERT.\n\u2022 DELETE [QUICK]. Borra el/los registros sin actualizar los \u00edndices. \n\u2022 TRUNCATE. Es una forma muy r\u00e1pida de borrar todos los registros de una \ntabla, si no necesitamos saber el n\u00fa mero de registros que ha borrado. DE -\nLETE FROM <tabla> realiza el mismo cometido, pero devuelve el n\u00famero \nde registros borrados.\n\u2022 LAST_INSERT_ID(). Devuelve el \u00falti mo identificador asignado a una co -\nlumna de tipo AUTO_INCREMENT despu\u00e9s de una sentencia INSERT. \uf8e9 FUOC \u2022 71Z799014MO 35 Bases de datos en MySQL\n5. Administraci\u00f3n de MySQL\nLas tareas administrativas como la instal aci\u00f3n, gesti\u00f3n de usuarios, copias de \nseguridad, restauraciones, entre otras, son tareas ineludibles en cualquier or -\nganizaci\u00f3n. Las pol\u00edticas, los recursos y preferencias de los administradores ge -\nneran una gran variedad de  estilos y mecanismos para llevar a cabo estas \ntareas, por lo que no es posible habl ar de m\u00e9todos completamente estandari -\nzados en estas \u00e1reas.\nEn este apartado se contemplan las opciones de uso com\u00fan para la adminis -\ntraci\u00f3n de un servidor MySQL. Existen ta ntas alternativas que no es posible in -\ncluirlas todas en un curso. Por tal motivo, en este cap\u00edtulo se tratan algunos \ntemas de importancia para el administ rador, desde una pe rspectiva general, \nque permiten obtener una visi\u00f3n global de las posibilidades  pr\u00e1cticas de las \nherramientas administrativas.\nEn este sentido, el manual de MySQL es la referencia principal para encontrar posibilidades \ny resolver dudas. En especial se recomienda leer los siguientes cap\u00edtulos:\n\u2022 Cap\u00edtulo 2. Instalaci\u00f3n de MySQL.\n\u2022 Cap\u00edtulo 4. Administraci\u00f3n bases de datos.\n\u2022C a p \u00ed t u l o  5 .  O p t i m i z a c i \u00f3 n .\nLa informaci\u00f3n contenida en el los es muy amplia y clara, y representa una excelente gu\u00eda \npara resolver dudas. Asimismo, se deben tener en cuenta las listas de correo incluidas en el \nsitio oficial www.mysql.com.\nEste cap\u00edtulo se inicia con una breve rese \u00f1a del proceso de instalaci\u00f3n de MySQL. \nEn la actualidad es posible realizar la instalaci\u00f3n a partir de binarios empaqueta -\ndos que facilitan enormemente el proceso. La administraci\u00f3n de usuarios se \ntrata con algo m\u00e1s de detalle, incluyendo  una breve descripci\u00f3n de las tablas \ndel directorio de datos. Para los temas de copias de seguridad y restauraci\u00f3n se muestran los comand os y utilidades de mayor uso en la pr\u00e1ctica omitiendo al\n-\ngunos detalles t\u00e9cnicos poco  usuales. La optimizaci\u00f3n  se trata de manera muy \ngeneral, exponiendo los temas b\u00e1sicos que en la pr\u00e1ctica son pasados por alto.\nFinalmente, se describe brevemente c\u00f3mo  realizar la replicaci\u00f3n de datos en \nun servidor esclavo.\n5.1. Instalaci\u00f3n de MySQL\nLa instalaci\u00f3n de MySQL no representa  mayores problemas, ya que muchas \ndistribuciones incluyen paquetes con lo s que realizar la instalaci\u00f3n y configu -\nraci\u00f3n b\u00e1sica. Sin embargo, aqu\u00ed veremos la instalaci\u00f3 n de MySQL utilizando el \nc\u00f3digo fuente que se puede obtener en www.mysql.com. Cabe destacar que el uso de una versi\u00f3n de MySQL compilada ti ene la ventaja de que, probablemente, \uf8e9 FUOC \u2022 71Z799014MO 36 Bases de datos en MySQL\nse adaptar\u00e1 mucho mejor al entorno del servidor donde se ejecutar\u00e1, proporcio -\nnando as\u00ed un mejor rendimiento. Por contra, implicar\u00e1 m\u00e1s trabajo en caso de \nque surjan errores en la versi\u00f3n y teng amos que actualizarla. Las instrucciones \nque se describen en este apartado se ba san en la documentaci\u00f3n incluida en la \ndistribuci\u00f3n.\nEn primer lugar, debemos asegurarnos de que contamos con las librer\u00edas y uti -\nlidades necesarias para compilar los ficher os fuente. Principalmente la lista de \nverificaci\u00f3n debe incluir los ficheros siguientes:\n\u2022C o m p i l a d o r  g c c\n\u2022 Librer\u00edas libgc\nEl proceso de instalaci\u00f3n in cluye los siguientes pasos:\n\u2022 Descomprimir los archivos fuente\n\u2022 Configurar la versi\u00f3n de MySQL que va mos a obtener. El script 'configure' \nadmite muchos par\u00e1metros que debere mos examinar mediante la opci\u00f3n \n'--help'. Seg\u00fan los esquemas de tabl a que necesitemos o extensiones muy \nconcretas que debamos utilizar, debe remos examinar con cuidado sus op -\nciones. En su versi\u00f3n m\u00e1s simple lo ejecutar\u00edamos de la  siguiente manera:\n\u2022 Compilar. Procederemos a compilar si no ha habido problemas con la con -\nfiguraci\u00f3n. El par\u00e1metro -prefix especifi ca la ruta del sistema de ficheros \ndonde ser\u00e1 instalado.\n\u2022 Instalar el sistema el servidor ya compilado, mediante la siguiente ins -\ntrucci\u00f3n:cd /usr/local/src\ntar xzvf mysql-VERSION.tar.gz\ncd mysql-VERSION\n./configure \u2013prefix=/usr/local/mysql\nmake\nmake install\uf8e9 FUOC \u2022 71Z799014MO 37 Bases de datos en MySQL\n\u2022 Crear la base de datos in icial del servidor, la que almacenar\u00e1 los usuarios y \nprivilegios. Esta base de datos es impr escindible para qu e los usuarios se \npuedan conectar al servidor.\n\u2022 Crear un nuevo usuario y su grupo, para que el servicio se ejecute en un \nentorno de privilegios restringido en el  sistema operativo. En ning\u00fan caso \nse recomienda que el usuario que ejecute el servicio mysqld sea root.\n\u2022 Todos los archivos deben ser propiedad de root (mysql no debe poder modifi -\ncarse a s\u00ed mismo) y del grupo mysql. El  directorio de datos ser\u00e1 del usuario \nmysql para que pueda trabajar con las bases de datos, ficheros de registro, etc.\n\u2022 Crear el archivo de configuraci\u00f3n. La  distribuci\u00f3n incluye varios archivos \nde configuraci\u00f3n que sirven como plan tilla para adaptarl o a nuestras nece -\nsidades. En este caso, utilizamos la configur aci\u00f3n media como plantilla. \nOpcionalmente podemos editar el archivo /etc/my.cnf\n\u2022 Lanzar el servidor\n\u2022 En este estado, el servidor no puede servir a\u00fan de SGBD. Por defecto, ten -\ndremos creado un usuario ' root' sin contrase\u00f1a que po dr\u00e1 acceder tanto des -\nde el equipo local como remotamente.  El siguiente paso ser\u00e1 asignar una \ncontrase\u00f1a a este usuario y repasar los usuarios y privilegios definidos. Para \nasignar la contrase\u00f1a, debe remos hacer lo siguiente:scripts/mysql_istall_db\ngroupadd mysql\nuseradd -g mysql mysql\nchown -R root /usr/local/mysql\nchgrp -R mysql /usr/local/mysql\nchown -R mysql /usr/local/mysql/var\ncp support-files/my-medium.cnf /etc/my.cnf\n/usr/local/mysql/bin/mysql_safe &\nmysqladmin -u root password \u201cnuevapasswd\u201d\nmysqladmin -u root -h host_name password \u201cnuevapasswd\u201d\uf8e9 FUOC \u2022 71Z799014MO 38 Bases de datos en MySQL\nPodemos probar el funcionamiento del SGBD conectando con el cliente 'mysql':\nVeamos ahora algunas caracter\u00edsticas del servidor que acabamos de instalar:\n\u2022mysqld . El primer m\u00e9todo es lanzarlo di rectamente, se le pueden especifi -\ncar las opciones que el administrador desee.\n\u2022mysqld_safe . Es un script  que ejecuta mysqld  garantizando una configuraci\u00f3n \nsegura. Es mucho m\u00e1s reco mendable que ejecutar mysqld  directamente.\n\u2022mysql_server . Es un gui\u00f3n que realiza dos tare as: iniciar y detener el servidor \nmysqld  con los par\u00e1metros start y stop respectivamente. Utiliza mysqld_safe\npara lanzar el servidor mysqld . No es com\u00fan encontrarlo con ese nombre, ya \nque generalmente se copia como el archivo /etc/init.d/mysql\n\u2022mysql_multi . Permite la ejecuci\u00f3n de m\u00falt iples servidores de forma si -\nmultanea.\nPara detener el servidor b\u00e1 sicamente tenemos dos m\u00e9todos:\n\u2022/etc/init.d/mysql stop. Es el mecanismo est\u00e1ndar en los sistemas tipo \nUNIX. Aunque los direct orios pueden cambiar.\n\u2022$ mysqladmin -u root -p shutdown. Es la utilidad para realizar tareas ad -\nministrativas en un servidor MySQL, en este caso le pasamos el par\u00e1metro \n'shutdown' para de tener el servicio.\nPara que los mensajes del se rvidor aparezcan en espa\u00f1ol, se debe ejecutar con \nel par\u00e1metro -language:\nOtra opci\u00f3n es agregar en el archivo /e tc/my.cnf una l\u00ednea en la secci\u00f3n [mysqld]\n5.2. Usuarios y privilegios\nEl acceso al servidor MySQL est\u00e1 cont rolado por usuarios y privilegios. Los \nusuarios del servidor MySQL no tienen ninguna correspondencia con los mysql -u root -p\n$ mysqld --language=spanish\n[mysqld]\nlanguage = /usr/share/mysql/spanish\uf8e9 FUOC \u2022 71Z799014MO 39 Bases de datos en MySQL\nusuarios del sistema operativo. Aunque en la pr\u00e1ctica es com\u00fan que alg\u00fan ad -\nministrador de MySQL asigne los mismos  nombres que los usuarios tienen en \nel sistema, son mecanismos totalmente independientes y suele ser aconsejable \nen general.\nEl usuario administrador del sistema MySQL se llama root. Igual que el supe -\nrusuario de los sistemas tipo UNIX. \nAdem\u00e1s del usuario root, las instalaciones nuevas de MySQL incluyen el usua -\nrio an\u00f3nimo, que tiene permisos sobre la  base de datos test. Si queremos, tam -\nbi\u00e9n podemos restringirlo asign\u00e1ndole una contrase\u00f1a. El usuario an\u00f3nimo de \nMySQL se representa por una cadena va c\u00eda. Vemos otra fo rma de asignar con -\ntrase\u00f1as a un usuario, desde el cliente de mysql y como usuario root:\nLa administraci\u00f3n de privilegios y usuari os en MySQL se realiza a trav\u00e9s de las \nsentencias:\n\u2022GRANT . Otorga privilegios a un usuario, en caso de no existir, se crear\u00e1 el \nusuario.\n\u2022REVOKE . Elimina los privilegios de un usuario existente.\n\u2022SET PASSWORD . Asigna una contrase\u00f1a.\n\u2022DROP USER . Elimina un usuario.\n5.2.1. La sentencia GRANT\nLa sintaxis simplificada de grant consta de tres secciones. No puede omitirse \nninguna, y es importante el orden de las mismas:\n\u2022grant lista de privilegios\n\u2022on base de datos.tabla\n\u2022to usuario\nEjemplo\nCreaci\u00f3n de un nuevo usuario al que se otorga algunos privilegios\nEn la primera l\u00ednea se especifica n los privilegios que ser\u00e1n otorga dos, en este caso se permite \nactualizar ( update ), insertar (i nsert) y consultar ( select ). La segunda l\u00ednea especifica que los \nprivilegios se aplican a la tabla precios de la base de datos demo . En la \u00faltima l\u00ednea se encuen -\ntra el nombre del usuario y el equipo desd e el que se va a permitir la conexi\u00f3n.mysql> set password for ''@'localhost' = password(\u2019nuevapasswd\u2019);\nmysql> grant update, insert, select\n-> on demo.precios\n-> to visitante@localhost ;\uf8e9 FUOC \u2022 71Z799014MO 40 Bases de datos en MySQL\nEl comando grant crea la cuenta si no existe y, si existe, agrega los privilegios \nespecificados. Es posible asignar una co ntrase\u00f1a a la cuenta al mismo tiempo \nque se crea y se le otorgan privilegios:\nEn la misma sentencia es posible tamb i\u00e9n otorgar permisos a m\u00e1s de un usua -\nrio y asignarles, o no, contrase\u00f1a:\n5.2.2. Especificaci\u00f3n de luga res origen de la conexi\u00f3n\nMySQL proporciona mecanismos para permitir que el usuario realice su co -\nnexi\u00f3n desde diferentes equipos dentro de una red espec\u00edfica, s\u00f3lo desde un \nequipo, o \u00fanicamente desde el propio servidor. \nEl car\u00e1cter % se utiliza de la misma forma que en el comando like: sustituye a \ncualquier cadena de caracteres. En este ca so, se permitir\u00eda el  acceso del usuario \n'visitante' (con contrase\u00f1a, si la tuviese definida) desde cualquier equipo del \ndominio 'empresa.com'. Obs\u00e9rvese que es  necesario entrecomillar el nombre \ndel equipo origen con el fin de que sea aceptado por MySQL. Al igual que en \nlike, puede utilizarse el car\u00e1cter \u2019_\u2019.\nEntonces, para permitir la entrada desd e cualquier equipo en Internet, escribi -\nr\u00edamos:mysql> grant update, insert, select\n-> on demo.precios\n-> to visitante@localhost identified by \u2019nuevapasswd\u2019;\nmysql> grant update, insert, select\n-> on demo.precios\n-> to visitante@localhost,\n-> yo@localhost identified by  \u2019nuevapasswd\u2019,\n-> tu@equipo.remoto.com;\nmysql> grant update, insert, select\n-> on demo.precios\n-> to visitante@\u2019%.empresa.com\u2019;\n-> to visitante@\u2019%\u2019\uf8e9 FUOC \u2022 71Z799014MO 41 Bases de datos en MySQL\nObtendr\u00edamos el mismo resultado omitie ndo el nombre del equipo origen y \nescribiendo simplemente el nombre del usuario:\nLos anfitriones v\u00e1lidos tambi\u00e9n se pued en especificar con sus direcciones IP.\nLos caracteres \u2019 %\u2019 y \u2019_\u2019 no se permiten en los nombres de los usuarios. \n5.2.3. Especificaci\u00f3n de bases de datos y tablas\nDespu\u00e9s de analizar las opciones refere ntes a los lugares de conexi\u00f3n permiti -\ndos, veamos ahora c\u00f3mo podemos limitar  los privilegios a bases de datos, ta -\nblas y columnas.\nEn el siguiente ejemplo otorgamos privilegi os sobre todas las tablas de la base \nde datos demo .\nPodemos obtener el mismo resultado de esta forma:\nDe igual modo, al especifica r s\u00f3lo el nombre de una tabla se interpretar\u00e1 que \npertenece a la base de datos en uso:-> to visitante\nto visitante@192.168.128.10\nto visitante@\u2019192.168.128.%\u2019\nmysql> grant all\n-> on demo.*\n-> to \u2019visitante\u2019@\u2019localhost\u2019;\nmysql> use demo;\nmysql> grant all\n-> on *\n-> to \u2019visitante\u2019@\u2019localhost\u2019;\nmysql> use demo;\nmysql> grant all\n-> on precios\n-> to \u2019visitante\u2019@\u2019localhost\u2019;\n\uf8e9 FUOC \u2022 71Z799014MO 42 Bases de datos en MySQL\nOpciones para la clausula on del comando grant\n5.2.4. Especificaci\u00f3n de columnas\nA continuaci\u00f3n presentamos un ejempl o donde se especifican las columnas \nsobre las que se otorgan privilegios con el comando grant :\nPodemos especificar privilegios diferentes para cada columna o grupos de co -\nlumnas:\n5.2.5. Tipos de privilegios\nMySQL proporciona una gran variedad de tipos de privilegios.\n\u2022 Privilegios relaci onados con tablas: alter , create , delete , drop , index , in-\nsert, select , update\n\u2022 Algunos privilegios administrativos: f ile, proccess, super reload, replication \nclient, grant option, shutdown\n\u2022 Algunos privilegios para fines diversos: lock tables , show  databases , crea-\nte temporary  tables .\nEl privilegio all otorga todos los privilegios  exceptuando el privilegio grant \noption . Y el privilegio usage  no otorga ninguno, lo cual es \u00fatil cuando se desea, \npor ejemplo, simplemente cambiar la contrase\u00f1a:Opci\u00f3n Significado\n*.* Todas las bases de datos y todas las tablas\nbase.* Todas las tablas de la ba se de datos especificada\ntabla Tabla especificada de la base de datos en uso\n* Todas las tablas de la base de datos en uso\nmysql> grant update (precio,empresa)\n-> on demo.precios\n-> to visitante@localhost;\nmysql> grant update (precio), select (precio, empresa)\n-> on demo.precios\n-> to visitante@localhost;\ngrant usage\non *.*\nto visitante@localhost identified by \u2019secreto\u2019;\uf8e9 FUOC \u2022 71Z799014MO 43 Bases de datos en MySQL\nTipos de privilegios en MySQL\nEn entornos grandes, es frecuente enco ntrarse en la necesidad de delegar el \ntrabajo de administrar un servidor de bases de datos para que otros usuarios, adem\u00e1s del administrador, puedan resp onsabilizarse de otorgar privilegios so\n-\nbre una base de datos particular. Esto se puede hacer en MySQL con el privile -\ngio grant option :\nEl mismo resultado se puede obtener con la siguiente sintaxis alternativa:Tipo de privilegio Operaci\u00f3n que permite\nall [privileges] Otorga todos los privilegios excepto grant  option\nusage No otorga ning\u00fan privilegio\nalter Privilegio para alterar la estructura de una tabla\ncreate Permite el uso de create  table\ndelete Permite el uso de delete\ndrop Permite el uso de drop table\nindex Permite el uso de index  y drop  index\ninsert Permite el uso de insert\nselect Permite el uso de select\nupdate Permite el uso de update\nfile Permite le uso de select . . . into outfile  y load data infile\nprocess Permite el uso de show full procces list\nsuper Permite la ejecuci\u00f3n de comandos de supervisi\u00f3n\nreload Permite el uso de flush\nreplication client Permite preguntar la localizaci\u00f3n de maestro y esclavo\nreplication slave Permite leer los binlog  del maestro\ngrant option Permite el uso de grant  y revoke\nshutdown Permite dar de baja al servidor\nlock tables Permite el uso de lock tables\nshow tables Permite el uso de show  tables\ncreate temporary tables Permite el uso de create temporary table\nmysql> grant all, grant option\n-> on demo.*\n-> to operador@localhost;\nmysql> grant all\n-> on demo.*\n-> to operador@localhost\n-> with grant option ;\uf8e9 FUOC \u2022 71Z799014MO 44 Bases de datos en MySQL\nDe este modo el usuario operador  podr\u00e1 disponer de todos los privilegios sobre \nla base de datos demo , incluido el de controlar el acceso a otros usuarios.\n5.2.6. Opciones de encriptaci\u00f3n\nMySQL puede establecer conexiones seguras encript\u00e1ndolas mediante el pro -\ntocolo SSL*; de esta manera, los datos qu e se transmiten (tanto la consulta, en \nun sentido, como el resultado, en el ot ro) entre el cliente y el servidor estar\u00e1n \nprotegidos contra intrusos. Para especi ficar que un usuario debe conectarse \nobligatoriamente con este protoc olo, se utiliza la cl\u00e1usula require : \nLas conexiones encriptadas ofrecen protecci\u00f3n co ntra el robo de informaci\u00f3n, pero suponen \nuna carga adicional para el serv icio, que debe desencriptar la petici\u00f3n del cliente y encriptar \nla respuesta (adem\u00e1s de un proceso m\u00e1s largo de  negociaci\u00f3n al conectar), por ello, merman \nel rendimiento del SGBD.\n5.2.7. Limites de uso\nLos recursos f\u00edsicos del servidor siempr e son limitados: si se conectan muchos \nusuarios al mismo tiempo al servidor y realizan consultas o manipulaciones de datos complejas, es probable que pued a decaer el rendimiento notablemente. \nUna posible soluci\u00f3n a este problema es  limitar a los usuarios el trabajo que \npueden pedir al servidor  con tres par\u00e1metros:\n\u2022M \u00e1 x i m o  n \u00fa m e r o  d e  c o nexiones por hora.\n\u2022M \u00e1 x i m o  n \u00fa m e r o  d e  consultas por hora.\n\u2022 M\u00e1ximo n\u00famero de actualizaciones por hora.\nLa sintaxis de estas lim itaciones es como se muestra a continuaci\u00f3n:mysql> grant all\n-> on *.*\n-> to visitante@localhost\n-> require ssl;\nmysql> grant all\n-> on *.*\n-> to\n-> with MAX_CONECTIONS_PER_HOUR  3\n-> MAX_QUERIES_PER_HOUR  300\n-> MAX_UPDATES_PER_HOUR  30;* Secure Sockets Layer\uf8e9 FUOC \u2022 71Z799014MO 45 Bases de datos en MySQL\n5.2.8. Eliminar privilegios\nEl comando revoke  permite eliminar priv ilegios otorgados con grant  a los \nusuarios. Veamos un ejemplo representativo:\nAl ejecutar este comando se le retiran al usuario visitante  todos sus privilegios \nsobre todas las bases de datos, cuando se conecta desde localhost .\nEl comando anterior no retira todos los privilegios del usuario visitante , s\u00f3lo se \nlos retira cuando se conecta desde localhost . Si el usuario se conecta desde otra \nlocalidad (y ten\u00eda permiso para hacerlo) sus privilegi os permanecen intactos.\n5.2.9. Eliminar usuarios\nAntes de proceder a la elim inaci\u00f3n de un usuario, es  necesario asegurarse de \nque se le han quitado primero todos su s privilegios. Una vez asegurado este \ndetalle, se procede a elimin arlo mediante el comando drop user :\n5.2.10. La base de datos de privilegios: mysql\nMySQL almacena la informaci\u00f3n sobre lo s usuarios y sus privilegios en una \nbase de datos como cualqu ier otra, cuyo nombre es mysql . Si exploramos su \nestructura, entenderemos la manera como MySQL almacena la informaci\u00f3n de sus usuarios y privilegios:\n revoke all\non *.*\nfrom visitante@localhost;\nmysql> drop user  visitante;\nmysql -u root -p\nmysql> use mysql;\nmysql> show tables;\n+-----------------+\n| Tables_in_mysql |\n+-----------------+\n| columns_priv |\n| db  |\n| func |\n| host |\n| tables_priv |\n| user |\n+-----------------+\uf8e9 FUOC \u2022 71Z799014MO 46 Bases de datos en MySQL\nEs posible realizar modificaciones direct amente sobre estas tablas y obtener los \nmismos resultados que si utiliz\u00e1ramos los comandos grant , revoke , set pas-\nsword  o drop  user:mysql> show columns from user;\n+-----------------+------------------+------+-----+---------+-------+\n| Field | Type | Null | Key | Default | Extra |\n+-----------------+------------------+------+-----+---------+-------+\n| Host  | char(60) binary | PRI | | | |\n| User | char(16) binary | PRI | | | |\n| Password | char(16) binary | |  | | |\n| Select_priv | enum('N','Y') | N | | | |\n| Insert_priv | enum('N','Y') | | N | | |\n| Update_priv | enum('N','Y') | N | | | |\n| Delete_priv | enum('N','Y') | | N | | |\n| Create_priv | enum('N','Y') | N | | | |\n| Drop_priv  | enum('N','Y') | N | | | |\n| Reload_priv | enum('N','Y') | | N | | |\n| Shutdown_priv | enum('N','Y') | N | | | |\n| Process_priv | enum('N','Y') | N | | | |\n| File_priv  | enum('N','Y') | | N | | |\n| Grant_priv | enum('N','Y') | | N | | |\n| References_priv | enum('N','Y') | | N | | |\n| Index_priv | enum('N','Y') | | N | | |\n| Alter_priv | enum('N','Y') | |N | | |\n+-----------------+------------------+------+-----+---------+-------+\n17 rows in set (0.04 sec)\nmysql> show columns from db;\n+-----------------+------------------+------+-----+---------+-------+\n| Field | Type | Null | Key | Default | Extra |\n+-----------------+------------------+------+-----+---------+-------+\n| Host  | char(60) binary | PRI | | | |\n| Db | char(64) binary | PRI | | | |\n| User | char(16) binary | PRI | | | |\n| Select_priv | enum('N','Y') | | N | | |\n| Insert_priv | enum('N','Y') | | N | | |\n| Update_priv | enum('N','Y') | | N | | |\n| Delete_priv | enum('N','Y') | | N | | |\n| Create_priv | enum('N','Y') | | N | | |\n| Drop_priv  | enum('N','Y') | | N | | |\n| Grant_priv | enum('N','Y') | | N | | |\n| References_priv | enum('N','Y') | | N | N | |\n| Index_priv | enum('N','Y') | | N | | |\n| Alter_priv | enum('N','Y') | | N | | |\n+-----------------+------------------+------+-----+---------+-------+\n13 rows in set (0.00 sec)\nmysql> show columns from tables_priv;\n+--------------+----------------------------------------------------------------------------------------------+----+---+------- +-----+\n| Field | Type |Null|Key|Default|Extra|\n+--------------+----------------------------------------------------------------------------------------------+----+---+------- +-----+\n| Host  | char(60) binary |PRI | | | |\n| Db | char(64) binary |PRI | | | |\n| User | char(16) binary |PRI | | | |\n| Table_name | char(60) binary || N | | |\n| Grantor | char(77) || N | | |\n| Timestamp | timestamp(14) || N | | |\n| Table_priv | set('Select','Insert','Update','Delete','Create','Drop','Grant','References','Index','Alter')| | N | | |\n| Column_priv | set('Select','Insert','Update','References') |N | | | |\n+--------------+----------------------------------------------------------------------------------------------+----+---+------- +-----+\n8 rows in set (0.00 sec)\nmysql> update user\n-> set Password = password(\u2019nuevapasswd\u2019)\n-> where User =\u2019visitante\u2019 and Host = \u2019localhost\u2019;\nmysql> flush privileges ;\uf8e9 FUOC \u2022 71Z799014MO 47 Bases de datos en MySQL\nEl comando flush privileges  solicita a MySQL que vuelva  a leer las tablas de \nprivilegios. En el momento de ejecutarse , el servidor lee la informaci\u00f3n de es -\ntas tablas sobre privilegios. Pero si se han alterado las tablas manualmente, no \nse enterar\u00e1 de los cambios ha sta que utilicemos el comando flush privileges .\nTablas de la base de datos mysql\nEl acceso directo a las tablas de privilegios es \u00fatil en varios casos; por ejemplo, para \nborrar un usuario del sistema en las ve rsiones de MySQL anteriores a la 4.1.1:\nNo es posible eliminar me diante un solo comando revoke  todos los privilegios \nde un usuario. \nEjemplo\nSe otorgan derechos a un usuario con dos comandos grant .\nObservando el contenido de la base de datos de privilegios, podemos entender el comporta -\nmiento de los comandos grant  y revoke . Primero asignamos privilegios para usar el coman -\ndo select  al usuario visitante con dos comandos grant : el primero de ellos le permite el \ningreso desde el servidor nuestra-ong.org  y el segundo le otorga el  mismo tipo de privilegio, \npero desde cualquier equipo en Internet.\nConsultando la tabla user de la base de datos de privilegios , podemos observar los valores \u2019Y\u2019 \nen la columna del privilegio select . Tabla Contenido\nuser Cuentas de usuario y su s privilegios globales\ndb Privilegios sobres bases de datos\ntables_priv Privilegios sobre tablas\ncolumns_priv Privilegios sobre columnas\nhost Privilegios de otros equipos anfitriones sobre bases de datos\nmysql> delete from user\n-> where User = \u2019visitante\u2019 and Host = \u2019localhost\u2019;\nmysql> flush privileges ;\nmysql> grant select\n-> on *.*\n-> to visitante@nuestra-ong.org;\nQuery OK, 0 rows affected (0.01 sec)\nmysql> grant select\n-> on *.*\n-> to visitante@\u2019%\u2019;\nQuery OK, 0 rows affected (0.00 sec)\nmysql> select user,host,select_priv from  user\n-> where user = \u2019visitante\u2019;\n\uf8e9 FUOC \u2022 71Z799014MO 48 Bases de datos en MySQL\nAhora solicitamos eliminar el privilegio select de todas las bases de dato s y de todos los equipos \nen Internet.  \nEn la tabla user observamos que, efectivamente, se ha  eliminado el privilegio para visi -\ntante@\u2019%\u2019 pero no para 'visitante@nuestra -ong.org'. MySQL considera que son direccio -\nnes diferentes y respeta los privilegios otorgados a uno cuando se modifica otro.\n5.3. Copias de seguridad\nNing\u00fan sistema es perfecto ni est\u00e1 a salv o de errores humanos, cortes en el sumi -\nnistro de la corriente el\u00e9c trica, desperfectos en el hardware  o errores de software ; \nas\u00ed que una labor m\u00e1s que recomendable de l administrador del servidor de bases \nde datos es realizar copias de seguridad y dise\u00f1ar un plan de contingencia. Se de -\nben hacer ensayos del plan para asegurar su buen funcionamiento y, si se descu -\nbren anomal\u00edas, realizar  los ajustes necesarios.\nNo existe una receta universal que nos indique c\u00f3mo llevar nuestras copias de \nseguridad de datos. Cada administrador de be dise\u00f1ar el de su sistema de acuer -\ndo a sus necesidades, recursos, ries gos y el valor de la informaci\u00f3n.\nMySQL ofrece varias alternativas de copi a de seguridad de la informaci\u00f3n. La \nprimera que podemos mencio nar consiste simplemente en copiar los archivos \nde datos. Efectivamente, es una opci\u00f3n v\u00e1lida y sencilla.\nEn primera instancia son necesarios dos requisitos para  llevarla a cabo:\n\u2022 Conocer la ubicaci\u00f3n y estruc tura del directorio de datos.\n\u2022 Parar el servicio MySQL mi entras se realiza la copia.+-----------+-----------------+-------------+\n|   user |      host | select_priv |\n+-----------+-----------------+-------------+\n| visitante | nuestra-ong.org |      Y |\n| visitante |        % |      Y |\n+-----------+-----------------+-------------+\n2 rows in set (0.00 sec)\nmysql> revoke all\n-> on *.*\n-> from visitante@\u2019%\u2019;\nQuery OK, 0 rows affected (0.00 sec)\nmysql> select user,host,select_priv from user\n-> where user = \u2019visitante\u2019;\n+-----------+-----------------+-------------+\n|   user |      host | select_priv |\n+-----------+-----------------+-------------+\n| visitante | nuestra-ong.org |      Y |\n| visitante |        % |      N |\n+-----------+-----------------+-------------+\n2 rows in set (0.01 sec)\uf8e9 FUOC \u2022 71Z799014MO 49 Bases de datos en MySQL\nEn cuanto a la ubicaci\u00f3n y estructura del directorio, record emos que la distri -\nbuci\u00f3n de MySQL ubica el directorio de  datos en /usr/local/mysql/var, las dis -\ntribuciones GNU/Linux basa das en paquetes como DEB o RPM ubican, por lo \ngeneral, los datos en /var/lib/mysql.\nSi por alg\u00fan motivo no encontramos el direct orio de datos, podemos consultarlo a MySQL. \nEl comando show variables  nos muestra todas las variables di sponibles, basta realizar un fil -\ntro con la clausula like:\nUna vez ubicados los archivos, detenemo s la ejecuci\u00f3n del servidor: un modo \nsencillo de asegurarnos de que la base de datos no ser\u00e1 modificada mientras \nterminamos la copia:\nFinalmente, copiamos el directorio co mpleto con todas las bases de datos:\nPor supuesto podemos elegir  otras formas de copiarlo  o comprimirlo, de acuer -\ndo a nuestras preferencias y necesidades.\nSi queremos copiar s\u00f3lo una base de datos, copiamos el directorio con el mis -\nmo nombre de la base de datos:\nTambi\u00e9n es posible hacer copia de seguridad de una sola tabla.\nComo podemos observar, la organizaci\u00f3n de la base de datos en MySQL es \nmuy simple:\n\u2022 Todas las bases de datos se almacenan en un directorio, llamado el directo -\nrio de datos( datadir ).mysql> show variables  like \u2019datadir\u2019;\n+---------------+-----------------+\n| Variable_name |      Value |\n+---------------+-----------------+\n|    datadir | /var/lib/mysql/ |\n+---------------+-----------------+\n1 row in set (0.00 sec)\n$ mysqladmin  -u root -p shutdown\n$ cp -r /var/lib/mysql/ /algun_dir/\n$ tar czf mysql-backup.tar.gz /var/lib/mysql\n$ cp -r /var/lib/mysql/demo/ /algun_dir/respaldo_demo/\n$ cp -r /var/lib/mysql/demo/productos.* / algun_dir/backup_demo/\uf8e9 FUOC \u2022 71Z799014MO 50 Bases de datos en MySQL\n\u2022 Cada base de datos se almacena como un subdirectorio del directorio de \ndatos.\n\u2022 Cada tabla se almacena en un archivo, acompa\u00f1ada de otros archivos auxi -\nliares con el mismo nombre  y diferente extensi\u00f3n.\nEl problema de este mecanismo es que debemos detener el servicio de bases de \ndatos mientras realizamos el respaldo. \n5.3.1. mysqlhotcopy\nUn mecanismo que permite realizar la co pia de los archivos del servidor sin \nnecesidad de detener el servicio es el script  'mysqlhotcopy '. El script  est\u00e1 escrito \nen Perl y bloquea las tablas mientras re aliza el respaldo para evitar su modifi -\ncaci\u00f3n. Se usa de la siguiente manera:\nEn este caso, crear\u00e1 un directorio /algun_direc torio/demo con todos los archivos de la base \nde datos.\nEl comando mysqlhotcopy puede recibir s\u00f3lo el nombre de una base de datos \ncomo par\u00e1metro:\nEn este caso, crear\u00e1 un direct orio /var/lib/mysql/demo_copy.\nEste m\u00e9todo no funciona para tablas con el mecanismo de almacenamiento \ntipo InnoDB. \n5.3.2. mysqldump\nLas dos opciones anteriores representan copias binarias de la base de datos. El comando mysqldump , en cambio, realiza un volcad o de las bases de datos pero \ntraduci\u00e9ndolas a SQL; es decir, entrega un archivo de texto con todos los co\n-\nmandos necesarios para volver a reconstruir las bases de datos, sus tablas y sus datos. Es el m\u00e9todo m\u00e1s \u00fatil para copiar o distribuir una base de datos que de\n-\nber\u00e1 almacenarse en otros servidores. $ mysqlhotcopy  demo /algun_directorio\n$ mysqlhotcopy  demo\n$ mysqldump  demo > demo.sql\n\uf8e9 FUOC \u2022 71Z799014MO 51 Bases de datos en MySQL\nEl comando mysqldump  ofrece multitud de par\u00e1me tros para modificar su com -\nportamiento o el tipo de volcado gene rado: por defecto, genera sentencias \nSQL, pero puede generar ficheros de da tos tipo CSV u otros formatos. Tambi\u00e9n \npodemos especificarle que haga el volcado de todas las bases de datos o que \ns\u00f3lo vuelque los datos y no la  creaci\u00f3n de las tablas, etc.\nLas primeras l\u00edneas del archivo demo.sql  seg\u00fan el ejemplo anterior tendr\u00edan el \nsiguiente aspecto:\nLa ventaja de utilizar mysqldump  es que permite que los archivos puedan ser \nle\u00eddos (y modificados) en un simple ed itor de textos, y pu eden ser utilizados \npara migrar la informaci\u00f3n a otro SG BD que soporte SQL. Adem\u00e1s soporta to -\ndos los tipos de tablas. La desventaja es que su procesamiento es lento y los \narchivos que se obtienen son muy grandes. \n5.3.3. Restaurar a partir de respaldos\nEn alg\u00fan momento, sea por el motivo qu e sea, necesitaremo s realizar la res -\ntauraci\u00f3n de nuestras bases de datos. \nSi tenemos una copia binaria del directorio de datos, bastar\u00e1 con copiarla al \ndirectorio original y reiniciar el servidor:~$ mysqldump demo | head -25\n-- MySQL dump 8.21\n--\n-- Host: localhost Database: demo\n---------------------------------------------------------\n-- Server version 3.23.49-log\n--\n-- Table structure for table \u2019ganancia\u2019\n--\nDROP TABLE IF EXISTS ganancia;\nCREATE TABLE ganancia (\nventa enum(\u2019Por mayor\u2019,\u2019Por menor\u2019) default NULL,\nfactor decimal(4,2) default NULL\n) TYPE=MyISAM;\n--\nDumping data for table \u2019ganancia\u2019\n--\nINSERT INTO ganancia VALUES (\u2019Por mayor\u2019,1.05);\nINSERT INTO ganancia VALUES (\u2019Por menor\u2019,1.12);--\n# mysqladmin -u root -p shutdown\n# cp /algun_dir/respaldo-mysql/* /var/lib/mysql\n# chown -R mysql.mysql /var/lib/mysql\n# mysql_safe\n\uf8e9 FUOC \u2022 71Z799014MO 52 Bases de datos en MySQL\nEs importante restau rar tambi\u00e9n el due\u00f1o y el grup o de los archivos de datos, \npara tener los accesos corre ctamente establecidos. En este ejemplo se adopta \nel supuesto que el usuario mysql es el que ejecuta el servidor mysqld . \nLa restauraci\u00f3n de un archivo SQL obtenido con mysqldump , se realiza desde \nel cliente mysql , la base de datos debe existir, ya que el archivo demo.sql  no la \ncrea por defecto.\n5.4. Reparaci\u00f3n de tablas\nEn determinadas circunstancias de uso muy frecuente, como la inserci\u00f3n y bo -\nrrado masivos de datos, coincidiendo con bloqueos del sistema o llenado del \nespacio en disco u otras circunstancias, es posible que una tabla o algunos de \nsus \u00edndices se corrompan.\nPodemos consultar el estado de integridad de una tabla con el comando check \ntable , que realiza algunas verificaciones so bre la tabla en busca de errores y \nnos entrega un informe con las sigu ientes columnas de informaci\u00f3n:\nLa columna Op describe la operaci\u00f3n que se realiza sobre la tabla. Para el comando check \ntable  esta columna siempre tiene el valor check  porque \u00e9sa es la operaci\u00f3n que se realiza. \nLa columna Msg_type  pude contener uno de los valores status , error, info, o warning . Y la \ncolumna Msg_text  es el texto que reporta de alguna  situaci\u00f3n encontrada en la tabla.\nEs posible que la informaci\u00f3n entregada incluya varias filas con diversos men -\nsajes, pero el \u00faltimo mensaje siempre debe ser el mensaje OK de tipo status .\nEn otras ocasiones check table  no realizar\u00e1 la verificaci \u00f3n de tabla, en su lugar \nentregar\u00e1 como resultado el mensaje Table is already up to date , que significa \nque el gestor de la tabla indica que no hay necesidad de revisarla.\nMySQL no permite realizar consultas sobre una tabla da\u00f1ada y enviar\u00e1 un \nmensaje de error sin desple gar resultados parciales:$ mysql demo -u root -p < demo.sql\nmysql> check table precios ;\n+--------------+-------+----------+----------+\n|    Table |  Op | Msg_type | Msg_text |\n+--------------+-------+----------+----------+\n| demo.precios | check |  status |    OK |\n+--------------+-------+----------+----------+\n1 row in set (0.03 sec)\nmysql> select * from precios;\nERROR 1016: No puedo abrir archivo: \u2019precios.MYD\u2019. (Error: 145)\n\uf8e9 FUOC \u2022 71Z799014MO 53 Bases de datos en MySQL\nPara obtener informaci\u00f3n del significado del er ror 145, usaremos la utilidad en l\u00ednea de co -\nmandos perror :\nDespu\u00e9s de un mensaje como el anterior, es el momento de realizar una veri -\nficaci\u00f3n de la integridad de la  tabla para obtener el reporte. \nEn este caso localizam os dos errores en la tabla. La opci\u00f3n extended  es uno de los cinco ni -\nveles de comprobaci\u00f3n que se pueden  solicitar para verificar una tabla.\nTipos de verificaci\u00f3n\nLa sentencia repair table  realiza la reparaci\u00f3n de ta blas tipo MyISAM corruptas:\nEl segundo mensaje informa de la p\u00e9rdida de 13 filas durante el proceso de repa -\nraci\u00f3n. Esto significa, como es natural, que el comando repair table  es \u00fatil s\u00f3lo \nen casos de extrema necesidad, ya que no garantiza la recuperaci\u00f3n total de la in -\nformaci\u00f3n. En la pr\u00e1ctica, si empre es mejor realizar la restauraci\u00f3n de la informa -\nci\u00f3n utilizando las copias de seguridad. En caso de desastre, se debe conocer el \nmotivo que origina la corrupci\u00f3n de las ta blas y tomar las medidas adecuadas para \nevitarlo. En lo que respecta  a la estabilidad de MySQL,  se puede confiar en que \nmuy probablemente nunca ser\u00e1 necesario utilizar el comando repair table .$ perror 145\n145 = Table was marked as crashed and should be repaired\nmysql> check table precios extended;\n+-------------+------+----------+--------------------------------------+\n|    Table |  Op | Msg_type |              Msg_text |\n+-------------+------+----------+--------------------------------------+\n|demo.precios |check |  error |Size of datafile is:450 Should be:452 |\n|demo.precios |check |  error |               Corrupt |\n+-------------+------+----------+--------------------------------------+\n2 rows in set (0.00 sec)\nTipo Significado\nquick No revisa las filas en busc a de referencias incorrectas.\nfast Solamente verifica las tablas que no fueron cerradas adecuadamente.\nchangedVerifica s\u00f3lo las tablas mo dificadas desde la \u00faltima verificaci\u00f3n o que no se han \ncerrado apropiadamente.\nmediumRevisa las filas para verificar que los ligados borrados son correctos, verifica  \nlas sumas de comprobaci\u00f3n de las filas.\nextendedRealiza una b\u00fasqueda completa en todas las claves de cada columna. Garantiza el 100% de la integridad de la tabla.\nmysql> repair table  precios;\n+-------------+------+---------+--------------------------------------+\n|    Table |  Op | Msg_type|               Msg_text |\n+-------------+------+---------+--------------------------------------+\n|demo.precios |repair|   info | Wrong bytesec: 0-17-1 at 168;Skipped |\n|demo.precios |repair| warning | Number of rows changed from 20 to 7 |\n|demo.precios |repair|  status |                  OK |\n+-------------+-------+--------+--------------------------------------+\n3 rows in set (0.04 sec)\uf8e9 FUOC \u2022 71Z799014MO 54 Bases de datos en MySQL\nEl comando optimize table  puede tambi\u00e9n realizar  algunas correcciones so -\nbre una tabla.\n5.4.1. myisamchk\nEl programa myisamchk  es una utilidad en l\u00ednea de  comandos que se incluye \ncon la distribuci\u00f3n de MySQL y sirve pa ra reparar tablas tipo MyISAM. Para \nutilizarlo con seguridad el servidor no debe estar ejecut\u00e1n dose y se recomien -\nda realizar un respaldo del director io de datos antes de su utilizaci\u00f3n.\nRecibe como par\u00e1metro pr incipal los archivos .MYI correspondientes a las ta -\nblas que hay que revisar; es decir, myisamchk  no conoce la ubicaci\u00f3n del di -\nrectorio de datos. Por ejemplo, si el directorio de datos est\u00e1 ubicado en /val/\nlib/mysql, las siguientes se r\u00edan dos maneras de realizar una comprobaci\u00f3n de \nlos archivos de la  base de datos demo :\nSe pueden revisar todas las bases de da tos utilizando \u2019*\u2019 para denominar el di -\nrectorio de la base de datos:\nPara realizar una comproba ci\u00f3n r\u00e1pida, el manual su giere utilizar el siguiente \ncomando:\nY para realizar la correcci\u00f3n de las tabl as corruptas, el manual sugiere la sin -\ntaxis siguiente:\nLas opciones dadas por -O se refieren al uso de memoria, que permiten acelerar de forma no -\ntoria el proceso de reparaci\u00f3n.\n --force  reinicia myisamchk con el par\u00e1metro  --recover  cuando encuentra alg\u00fan error.\n--updatestate  almacena informaci\u00f3n sobre el resu ltado del an\u00e1lisis en la tabla MYI.# myisamchk /var/lib/mysql/demo/*.MYI\n# cd /var/lib/lib/mysql/demo\n# myisamchk *.MYI\n# myisamchk /var/lib/mysql/*/*.MYI\n# myisamchk --silent --fast *.MYI\n# myisamchk --silent --force --update-state -O key_buffer=64M \\\n-O sort_buffer=64M -O read_buffer=1M -O write_buffer=1M *.MYINota\nEn la pr\u00e1ctica con estas opcio-\nnes se logran corregir los  \nerrores m\u00e1s comunes. Para co-nocer otras opciones de recu-peraci\u00f3n con myisamchk , \npod\u00e9is consultar el manual  \nque acompa\u00f1a a la distribu-ci\u00f3n de MySQL.\uf8e9 FUOC \u2022 71Z799014MO 55 Bases de datos en MySQL\n5.5. An\u00e1lisis y optimizaci\u00f3n\nEl dise\u00f1o de MySQL le permite funcio nar con un rendimiento notable, sin em -\nbargo, se pueden cometer f\u00e1cilmente errores que disminuyan la capacidad de \nrespuesta del servidor. Tambi\u00e9n se pueden  realizar algunos ajustes a la confi -\nguraci\u00f3n de MySQL que incrementan su rendimiento.\n5.5.1. Indexaci\u00f3n\nLa indexaci\u00f3n es la principal herram ienta para optimizar el rendimiento ge -\nneral de cualquier base de datos. Es tambi\u00e9n la m\u00e1s conocida por los usuarios \nde servidores MySQL y, parad\u00f3jicamente,  su no utilizaci\u00f3n es una de las prin -\ncipales causas de bajo rendimiento en servidores de bases de datos.\nMuchos administradores y dise\u00f1adores simplemente parecen olvidar usar \u00edndices para opti -\nmizar los accesos a las bases de datos. Por otro lado, algunas personas tienden a indexar todo, \nesperando que de esta manera el servidor acelere cualquier tipo de consulta que se le solicite. \nEn realidad, esta pr\u00e1ctica pued e causar una disminuci\u00f3n en el rendimiento, sobre todo en lo \nque respecta a inserciones y modificaciones.\nPara ver las ventajas de utilizar \u00edndice s, analizaremos en primer t\u00e9rmino una \nsimple b\u00fasqueda en una tabla sin \u00edndice alguno:\n\u2022 El constante acceso de escritura de una tabla la mantiene desordenada.\n\u2022 La ordenaci\u00f3n de una tabla es una op eraci\u00f3n costosa: el servidor tendr\u00eda \nque detenerse un tiempo consider able para ordenar sus tablas.\n\u2022 Muchas tablas tienen m\u00e1s de un criterio de ordenaci\u00f3n: ordenar seg\u00fan una \ncolumna implica desordenar otra.\n\u2022 La inserci\u00f3n y eliminaci\u00f3n de datos sin alterar el orden en una tabla es cos -\ntosa: la inserci\u00f3n de un registro en una tabla grande implicar\u00eda una larga \nespera en la actualizaci\u00f3n de la misma.\n\u2022 Si se opta por mantener la tabla desord enada (que es la opci\u00f3n m\u00e1s viable), \nuna b\u00fasqueda implicar\u00eda forzosamente  un recorrido secuencial (tambi\u00e9n \ndenominado full scan ), registro por registro.\nEl uso de \u00edndices en la ordenaci\u00f3n de las bases de datos ofrece las ventajas si -\nguientes:\n\u2022 Permite ordenar las tablas por varios criterios simult\u00e1neamente.\n\u2022 Es menos costoso ordenar un archivo \u00edndice, porque incluye s\u00f3lo referen -\ncias a la informaci\u00f3n y no la informaci\u00f3n en s\u00ed.\n\u2022 El coste de inserci\u00f3n y eliminaci\u00f3n es menor.\n\u2022 Con los registros siempre ordenados se utilizaran algoritmos mucho m\u00e1s \neficientes que el simple recorr ido secuencial en las consultas.\uf8e9 FUOC \u2022 71Z799014MO 56 Bases de datos en MySQL\nEl uso de \u00edndices tambi\u00e9n co mporta alguna desventaja:\n\u2022 Los \u00edndices ocupan espacio en disco.\n\u2022 A\u00fan teniendo registros peque\u00f1os, el mantener en orden un \u00edndice dismi -\nnuye la velocidad de las operacio nes de escritura sobre la tabla.\nA pesar de estos inconvenientes, la ut ilizaci\u00f3n de \u00edndices ofrece mayores ven -\ntajas que desventajas, sobre todo en la consulta de m\u00faltiples tablas, y el au -\nmento de rendimiento es mayor cuanto mayor es la tabla. \nConsideremos por ejemplo un a consulta sobre las tablas A, B, y C, indepen -\ndientemente del conten ido de la cl\u00e1usula where,  las tres tablas se deben de \ncombinar para hacer posible posteriormen te el filtrado se g\u00fan las condiciones \ndadas:\nConsideremos que no son ta blas grandes, que no sobrepasan los 1.000 regis -\ntros. Si A tiene 500 registros, B tiene 600 y C 700, la tabla resultante de la con -\nsulta anterior tendr\u00e1 210 millones de registros. MySQL har\u00eda el producto \ncartesiano de las tres tabl as y, posteriormente, se re correr\u00eda la relaci\u00f3n resul -\ntante para buscar los registros que satisf acen las condiciones dadas, aunque al \nfinal el resultado incluya solamente 1.000 registros.\nSi utilizamos \u00edndices MySQL los utilizar\u00eda de una forma parecida a la siguiente:\n\u2022 Tomar\u00eda cada uno de los registros de A.\n\u2022 Por cada registro de A, buscar\u00eda los registros en B que cumpliesen con la con -\ndici\u00f3n A.a = B.b. Como B est\u00e1 indexado por el atributo 'b', no necesitar\u00eda ha -\ncer el recorrido de todos los registro s, simplemente acceder\u00eda directamente \nal registro que cumpliese la condici\u00f3n.\n\u2022 Por cada registro de A y B encontrado  en el paso anterior, buscar\u00eda los re -\ngistros de C que cumpliesen la condici\u00f3 n B.b = C.c. Es el mismo caso que \nen el paso anterior.\nComparando las dos alternativas de b\u00fasqueda, la segunda ocupar\u00eda cerca del 0,000005% del tiempo original. Por supu esto que s\u00f3lo se trata de una aproxi\n-\nmaci\u00f3n te\u00f3rica, pero adecuada para comp render el efecto de los \u00edndices en las \nconsultas sobre bases de datos. select *\nfrom A,B,C\nwhere A.a = B.b\nand B.b = C.c;\n\uf8e9 FUOC \u2022 71Z799014MO 57 Bases de datos en MySQL\n5.5.2. Equilibrio\nEl \u00edndice ideal deber\u00eda tener las siguientes caracter\u00edsticas:\n\u2022 Los registros deber\u00edan ser lo m\u00e1s peque\u00f1os posible.\n\u2022 S\u00f3lo se debe indexar valores \u00fanicos.\nAnalicemos cada recomendaci\u00f3n:\n\u2022 Cuanto m\u00e1s peque\u00f1os sean los registros, m\u00e1s r\u00e1pidamente se podr\u00e1n cam -\nbiar de lugar (al insertar, modificar o borrar filas), adem\u00e1s, en un momento \ndado, el \u00edndice puede permanecer en  memoria. Consideremos las dos defi -\nniciones posibles:\nEn esta tabla el \u00edndi ce se realiza sobre nombre , que es un campo de 30 caracteres, y se utiliza \ncomo clave para hacer los ' joins' con otras tablas.\nAhora consid\u00e9rese la siguiente alternativa:\nSe agrega una columna que servir\u00e1 como identifi cador de la empresa. Desde el punto de vista \nde rendimiento implica una mejora, ya que el \u00edn dice se realiza sobre n\u00fa meros enteros, por lo \ntanto, ocupar\u00e1 menos espacio y funcionar\u00e1 m\u00e1s r\u00e1pido.\n\u2022 Consideremos el \u00edndice siguiente, creado para disminuir la necesidad de \nefectuar accesos a la tabla: create table Empresa(\nnombre char(30),\ntel\u00e9fono char(20),\nindex (nombre)\n);\ncreate table Empresa(\nid int ,\nnombre char(30),\ntel\u00e9fono char(20),\nindex (id)\n);\nCuanto m\u00e1s peque\u00f1a sea la columna indexada mayor velocidad se ten -\ndr\u00e1 en el acceso a la tabla.\ncreate table Empresa(\nnombre char(30),\ncr\u00e9dito enum{\u2019SI\u2019,\u2019NO\u2019},\nindex(cr\u00e9dito)\n);\uf8e9 FUOC \u2022 71Z799014MO 58 Bases de datos en MySQL\nSi consideramos que un \u00edndice se crea  para evitar la necesidad de recorrer \nla tabla, veremos que el \u00edndice creado  es pr\u00e1cticamente in\u00fatil, ya que algu -\nno de los valores ocurre el 50% o m\u00e1s de las veces: para encontrar todos los \nresultados hay que recorre r gran parte de la tabla. MySQL no utiliza los \u00edn -\ndices que implican un 30% de  ocurrencias en una tabla.\nAun as\u00ed, y exceptuando casos ex agerados como este \u00faltimo, puede ser interesante indexar \nuna tabla por alg\u00fan atributo que no sea \u00fanico, si  ese atributo se utiliza para ordenar los resul -\ntados. Tambi\u00e9n puede ser conveniente crear un \u00edndice por varios atributos simult\u00e1neamente \nsi se usan todos en alguna consulta en la cl\u00e1usula ORDER BY.\n5.5.3. La cache  de consultas de MySQL\nEl servidor MySQL incluye la posibilidad de utilizar una cache * con los resul -\ntados de las \u00faltimas consultas para acelerar la velocidad de respuesta. Esta so -\nluci\u00f3n es \u00fatil cuando las tablas ti enen relativamente pocos cambios y se \nrealizan los mismos tipos de cons ultas. El funcio namiento de la cache  se basa \nen las premisas siguientes:\n\u2022 La primera vez que se recibe una consulta se almacena en la cache .\n\u2022 Las siguientes veces la consul ta se realiza primero en la cache ; si tiene \u00e9xito, \nel resultado se env\u00eda inmediatamente.\nLa cache  tiene las siguientes caracter\u00edsticas:\n\u2022 El servidor compara el texto de la co nsulta; aunque t\u00e9cn icamente sea igual \nsi difiere en uso de may\u00fa sculas-min\u00fasculas o cualqu ier otro cambio, no se \nconsidera la solicitud id\u00e9ntica  y no ser\u00e1 tratada por la cache .\n\u2022 Si alguna tabla incluida en alguna co nsulta cambia, el contenido de la con -\nsulta es elim inado de la cache .\nLa configuraci\u00f3n de la cache  se realiza a trav\u00e9s de variables globales:\n\u2022query_cache_limit . No almacena resultados que sobrepasen dicho tama\u00f1o. \nPor omisi\u00f3n es de 1M.\n\u2022query_cache_size . Tama\u00f1o de la memoria cache expresada en bytes. Por \nomisi\u00f3n es 0; es de cir, no hay cache.\n\u2022query_cache_type . Puede tener tres valores: ON , OFF o DEMAND.Cuanto menor sea la repetici\u00f3n de valores en una columna indexada, me -\nnor ser\u00e1 la necesidad de acceder a la tabla y m\u00e1s eficiente ser\u00e1 el \u00edndice.\n* Memoria intermedia \nde acceso r\u00e1pido.\uf8e9 FUOC \u2022 71Z799014MO 59 Bases de datos en MySQL\nTipos de cache\nCuando la cache  del servidor esta en modo DE MAND, se debe solicitar expl\u00edci -\ntamente que la consulta utilice o no la cache :\n5.6. Replicaci\u00f3n\nLa replicaci\u00f3n es la copia sincronizada entre dos servidores de bases de datos \nde forma que cualquiera de los dos pued e entregar los mismos resultados a sus \nclientes. \nMySQL incluye la posibilidad de replicac i\u00f3n con las siguient es caracter\u00edsticas:\n\u2022 Funciona con el esquema maestro-esclavo : existe un servidor maestro que \nlleva el control central y uno o varios servidores esclavos que se mantienen \nsincronizados con el  servidor maestro.\n\u2022 La r\u00e9plica se realiza mediante un regi stro de los cambios realizados en la \nbase de datos: no se realizan las copias de las bases de datos para mantener -\nlas sincronizadas, en su lugar se inform a de las operaciones realizadas en el \nservidor maestro (insert, delete , update  ...) para que las realicen a su vez los \nservidores esclavos.\n\u2022 No es posible realizar cambios en lo s servidores esclavos, son exclusiva -\nmente para consultas.\nEste sencillo esquema perm ite la creaci\u00f3n de rep licas sin mayores complica -\nciones obteniendo los siguientes beneficios:\n\u2022 Se distribuye la carga de trabajo.\n\u2022 El sistema es redundante, por lo que en caso de desastre hay menos proba -\nbilidades de perder los datos.\n\u2022 Es posible realizar los respaldos de un  esclavo sin interrumpir el trabajo del \nservidor maestro.Valor Tipo Significado\n0 OFF Cache  desactivado\n1 ON Cache  activado\n2 DEMAND S\u00f3lo bajo solicitud explicita\nselect sql_cache\nselect sql_no_cache\n\uf8e9 FUOC \u2022 71Z799014MO 60 Bases de datos en MySQL\n5.6.1. Preparaci\u00f3n previa\nEl equipo maestro debe tener acceso por red. Antes de realizar la configuraci\u00f3n \nde los servidores maestro y esclavo es ne cesario realizar las siguientes tareas:\n\u2022 Asegurarse de que en ambos est\u00e1 in stalada la misma versi\u00f3n de MySQL.\n\u2022 Asegurarse de que ninguno de los servid ores atender\u00e1 peticiones durante el \nproceso de configuraci\u00f3n.\n\u2022 Asegurarse de que las bases de datos del servidor maestro han sido copiadas \nmanualmente en el servidor esclavo, de manera que en ambos se encuentre exactamente la misma informaci\u00f3n.\n\u2022 Asegurarse de que ambos atienden co nexiones v\u00eda TCP/IP. Por seguridad, \nesta opci\u00f3n est\u00e1 desactivada por omisi\u00f3n. Para activarla se debe comentar \nla l\u00ednea skip_networking en el archivo de configuraci\u00f3n /etc/my.cnf\n5.6.2. Configuraci\u00f3n del servidor maestro\nEn el servidor maestro creamos una cuen ta de usuario con permisos de repli -\ncaci\u00f3n para autorizar, en el servidor ma estro, al nuevo usuario para realizar r\u00e9 -\nplicas:\nReplicador es el nombre del nuevo usuario.\nEsclavo.empresa.com es la di recci\u00f3n del servidor esclavo.\n\u2019Secreto\u2019 es la contrase\u00f1a. \nEl servidor maestro llevar\u00e1 un archivo de registro ' binlog ' donde se registrar\u00e1n \ntodas las solicitudes de actu alizaci\u00f3n que se realicen en  las bases de datos. Para \nactivar la creaci\u00f3n de este archivo debemos editar el archivo /etc/my.cnf y \nagregar las siguientes l\u00ednea s en la secci\u00f3n [mysqld]:mysql> grant replication slave\n-> on *.*\n-> to replicador@esclavo.empresa.com identified by  \u2019secreto\u2019;\n[mysqld]\nlog-bin\nserver-id = 1\uf8e9 FUOC \u2022 71Z799014MO 61 Bases de datos en MySQL\nEl servidor maestro debe identificarse co n un id, en este caso ser\u00e1 el n\u00famero \n1. a continuaci\u00f3n, reiniciamos el servidor:\nFinalmente, consultamos el  nombre del archivo ' binlog ' y la posici\u00f3n de com -\npensaci\u00f3n (estos datos son necesarios para co nfigurar el esclavo):\n5.6.3. Configuraci\u00f3n del servidor esclavo\nEn el servidor esclavo, editamos el ar chivo /etc/my.cnf y agregamos, al igual \nque en el maestro, la activaci\u00f3n del archivo ' binlog ' y un identificador del ser -\nvidor (que debe ser distinto del id entificador del se rvidor maestro):\nReiniciamos el servidor esclavo:\nConfiguramos los dato s del maestro en el servidor esclavo:.\nEl \u00faltimo paso es iniciar el servidor esclavo:\nY ya tendremos el servid or esclavo funcionando. /etc/init.d/mysql restart\nmysql> show master status;\n+-----------------+----------+--------------+------------------+\n|      File | Position | Binlog_do_db | Binlog_ignore_db |\n+-----------------+----------+--------------+------------------+\n| maestro-bin.001 |    76 |    | |\n+-----------------+----------+--------------+------------------+\n[mysqld]\nlog-bin\nserver-id = 2\n# /etc/init.d/mysql restart\nmysql> change master to\n-> master_host = \u2019maestro.empresa.com\u2019,\n-> master_user = \u2019replicador\u2019,\n-> master_password = \u2019secreto\u2019,\n-> master_log_file = \u2019maestro-log.001\u2019,\n-> master_log_pos = 76;\nmysql> start slave;\uf8e9 FUOC \u2022 71Z799014MO 62 Bases de datos en MySQL\n5.7. Importaci\u00f3n y exportaci\u00f3n de datos\nEn muchas ocasiones es necesario mover datos de una aplicaci\u00f3n a otra, para \nello son necesarios format os est\u00e1ndares que puedan ser escritos por la aplica -\nci\u00f3n origen y le\u00eddos por la aplicaci\u00f3n de stino. El m\u00e1s simple de esos formatos \nes el texto plano, donde cada archivo es un a tabla, cada fila es  un registro y los \nvalores de los campos se separan por tabuladores. \nMySQL puede leer este tipo de archiv os, incluyendo valo res nulos representa -\ndos por \u2019\\N\u2019(N may\u00fascula).s\nUtilizando el cliente mysql , podemos introducir los datos del archivo local \nproveedores.txt  en la tabla proveedores :\nSi se omite la palabra local , MySQL buscar\u00e1 el archivo en el servidor y no en \nel cliente. \nEn un archivo se pueden entrecomilla r los campos, utilizar comas para sepa -\nrarlos y terminar las l\u00edneas con los ca racteres \u2019\\r\\n\u2019 (como en los archivos \nWindows). El comando load data  tiene dos clausulas opcionales, fields,  en el \nque se especifican estos par\u00e1metros.\nLa opci\u00f3n enclosed by  puede tener la forma optionaly enclosed by , en caso \nde que los campos num\u00e9ri cos no sean delimitados.\nAdem\u00e1s pueden omitirse la s primeras lineas del arch ivo si contienen informa -\nci\u00f3n de encabezados:mysql> load data local infile \u2019proveedores.txt\u2019\n-> into table proveedores;\nmysql> load data local infile \u2019prooveedores.txt\u2019\n-> fields terminated by \u2019,\u2019\n-> enclosed by \u2019\u201d\u2019\n-> lines terminated by \u2019\\r\\n\u2019;\nmysql> load data local infile \u2019proveedores.txt\u2019\n-> ignore 1 lines;\n\uf8e9 FUOC \u2022 71Z799014MO 63 Bases de datos en MySQL\n5.7.1. mysqlimport\nLa utilidad mysqlimport  que se incluye en la distribuci\u00f3n puede realizar el \nmismo trabajo que load data . Estos son algunos de sus par\u00e1metros:\nEstos son algunos de  los argumentos de  mysqlimport  para realizar las tareas \nequivalentes a la sentencia load data :\nLa forma m\u00e1s simple para exportar datos es redireccionando la salida del cliente \nmysql . El par\u00e1metro -e permite ejecutar un  comando en modo de procesamiento \npor lotes. MySQL detecta si la salida es  en pantalla o est\u00e1 redireccionada a un \narchivo y elige la presentaci\u00f3n adecuada: con encabezados y l\u00edneas de separa -\nci\u00f3n para la salida en pantalla, y sin encabezados y con tabuladores para un \narchivo:\nLa sentencia select  tambi\u00e9n cuenta con una opci\u00f3n  para realizar la tarea in -\nversa de la sentencia load data :\n5.7.2. mysqldump\nLa utilidad mysqldump  realiza el volcado de base s de datos y puede utilizarse \npara transportar datos de una base a otra que tambi\u00e9n entienda SQL. Sin em -\nbargo, el archivo debe se r editado antes de utilizarse, ya que algunas opciones mysqlimport basededatos archivo.txt\n--fields-terminated-by=\n--fields-enclosed-by=\n--fields-optionally-enclosed-by=\n--fields-escaped-by=\n--lines-terminated-by=\n$ mysql demo -e \u201cselect * from proveedores\u201d > proveedores.txt\nmysql> select *\n-> into outfile \u201c/tmp/proveedores.txt\u201d\n-> fields termitated by \u2019,\u2019\n-> optionaly enclosed by \u2019\u201d\u2019\n-> lines termitates by \u2019\\n\u2019\n-> from proveedores;\uf8e9 FUOC \u2022 71Z799014MO 64 Bases de datos en MySQL\nson exclusivas de MySQL. Por lo general,  basta con eliminar el tipo de tabla \nque se especifica al final de un comando create table .\nEl siguiente comando realiza el vaci ado completo de la base de datos demo :\nEn algunos casos, los comandos insert  son suficientes y no necesitamos las de -\nfiniciones de las tablas.\nEl siguiente comando realiza un vaciado de la tabla proveedores  de la base de \ndatos demo  filtrando la salid a con el comando grep de UNIX que selecciona \ns\u00f3lo las l\u00edneas que contienen la palabr a INSERT. De este modo, el archivo pro-\nveedores-insert.txt  contiene exclusivamente comandos insert :$ mysqldump demo > demo.sql\n$ mysqldump demo proveedores | grep INSERT\uf8e9 FUOC \u2022 71Z799014MO 65 Bases de datos en MySQL\n6. Clientes gr\u00e1ficos\nExisten m\u00faltiples clientes de entorno gr\u00e1fico que perm iten la interacci\u00f3n con \nun servidor MySQL. Analizaremos brev emente los que distribuye la empresa \nMySQL AB ( mysqlcc, mysql-query-browser y mysql-administrator ) y que se pueden \ndescargar del sitio ofical www.mysql.com.\n6.1. mysqlcc\nAl ejecutarse por primera vez abrir\u00e1 el di\u00e1logo que permite realizar el registro \nde un nuevo servidor MySQL:\nEn la ventana principal se pueden apreci ar los servidores registrados, que en \neste caso es solamente uno.\nCon el bot\u00f3n derecho del rat\u00f3n sobre \u201cC onexi\u00f3n de Demostraci\u00f3n\u201d, se puede \nactivar la conexi\u00f3n. Despu\u00e9s de eso, mysqlcc  muestra las propiedades de los \nelementos de la base de datos.Nota\nActualmente, mysqlcc  se ha \ndado por obsoleto en favor  \nde los otros dos.\n\uf8e9 FUOC \u2022 71Z799014MO 66 Bases de datos en MySQL\nAhora ya estamos en disposici\u00f3n de realizar consultas SQL con Ctrl-Q (o haciendo \nclick sobre el icono 'SQL'). Se abrir\u00e1 un a nueva ventana en la que podremos escri -\nbir la consulta que, una vez escrita, se ej ecutar\u00e1 al teclear Ctrl-E. Los resultados se \nmostrar\u00e1n en forma de tabla como en  la captura de pantalla anterior.\nmysqlcc  ofrece m\u00faltiples opciones para re alizar inserciones,  eliminaciones, \nconfigurar teclas de acceso r\u00e1pido y una serie de caracter\u00edsticas de uso muy in -\ntuitivo. Tambi\u00e9n ofrece prestaciones pa ra exportar el resultado de una consul -\nta a un fichero de texto.\n6.2. mysql-query-browser\nTanto mysql-query-browser como mysql-administrator  comparten la informa -\nci\u00f3n relativa a las conexiones almacena das. La pantalla in icial nos permitir\u00e1 \nseleccionar una existente o configurar una nueva:\n\uf8e9 FUOC \u2022 71Z799014MO 67 Bases de datos en MySQL\nEl aspecto de este programa es mejor que el de mysqlcc y ofrece prestaciones de \nayuda en la generaci\u00f3n de consultas, favoritos, marcadores, accesos r\u00e1pidos a \nEXPLAIN , etc.\nAsimismo, ofrece varios fo rmatos de exportaci\u00f3n de los resultados de una con -\nsulta y m\u00e1s facilidades a la hora  de navegar por los resultados.\n6.3. mysql-administrator\nEsta novedosa herramienta es extremad amente potente y completa en cuanto \na tareas de administraci\u00f3n se refiere.\n\uf8e9 FUOC \u2022 71Z799014MO 68 Bases de datos en MySQL\nmysql-administrator  permite, entre otras cosas:\n\u2022 Encender y parar el SGBD.\n\u2022 Gestionar el fichero de configuraci\u00f3n /etc/my.cnf de forma gr\u00e1fica.\n\u2022 Gestionar usuarios y privilegios.\n\u2022 Monitorizar el uso del gestor que se es t\u00e1 haciendo del mismo, el n\u00famero de \nconexiones, consultas simult\u00e1neas y todo tipo de informaci\u00f3n estad\u00edstica.\n\u2022 Consultar los ficheros de registro ( log) del servidor.\n\u2022 Gestionar copias de seguridad.\n\u2022 Gestionar la replicaci\u00f3n de bases de datos.\n\u2022 Crear y borrar bases de datos (SCHEMA).\n\uf8e9 FUOC \u2022 71Z799014MO 69 Bases de datos en MySQL\n\uf8e9 FUOC \u2022 71Z799014MO 70 Bases de datos en MySQL\nResumen\nMySQL es un SGBD relacional de f\u00e1cil us o y alto rendimiento, dos caracter\u00edsticas \nmuy valiosas para un desarrollador de si stemas: su facilidad de uso permite la \ncreaci\u00f3n de bases de datos con rapidez y sin muchas complicaciones, y su alto \nrendimiento lo hace sumamente atractiv o para aplicaciones comerciales impor -\ntantes o portales web de mucho tr\u00e1fico. Si  a ello le a\u00f1adimos la disponibilidad \nde c\u00f3digo y su licencia dual, se comp rende que MySQL sea atractivo y accesible \npara todo el mundo.\nEstos atributos tienen sus costes: mant enerlo con un alto rendimiento hace \nalgo m\u00e1s lento su desarrollo, por lo que no es el m\u00e1s avanzado en cuanto a prestaciones y compatibilidad  con est\u00e1ndares. MySQL ca rece de caracter\u00edsticas \nque muchos otros SGBD poseen. Pero no se debe olvidar que est\u00e1 en continuo \ndesarrollo, por lo qu e futuras versiones incluir\u00e1n nuevas caracter\u00edsticas. Por \nsupuesto, para MySQL es m\u00e1 s importante la eficiencia  que incluir prestaciones \ns\u00f3lo por competir o satisfacer a algunos usuarios.\uf8e9 FUOC \u2022 71Z799014MO 71 Bases de datos en MySQL\nBibliograf\u00eda\nDuBois, P.  (2003). MySQL Second Edition: The definitive guide to using, programming, and \nadministering MySQL 4 databases Indianapolis: Developer\u2019s Library.\nManual de MySQL de la distribuci\u00f3n (accesible en: http://dev.mysql.com/doc/).\nSilberschatz, A.; Korth, H.; Sudarshan, S.  (2002) Fundamentos de Bases de Datos  (4.\u00aa ed.). \nMadrid: McGraw Hill. Bases de datos \nen PostgreSQL\nMarc Gibert Ginest\u00e0\nOscar P\u00e9rez Mora\uf8e9 FUOC \u2022 71Z799014MO Bases de datos en PostgreSQL\n\u00cdndice\nIntroducci\u00f3n .............................................................................................. 5\nObjetivos ..................................................................................................... 6\n1. Caracter\u00edsticas de PostgreSQL .......................................................... 7\n1.1. Breve historia .................................................................................... 7\n1.2. Prestaciones ......................................................................................  7\n1.3. Limitaciones ..................................................................................... 8\n2. Introducci\u00f3n a la orientaci\u00f3n a objetos ....................................... 9\n2.1. El modelo orientado a objetos .......................................................... 92.2. Objetos: clase frente a instancia ....................................................... 102.3. Propiedades: atributo frente a operaci\u00f3n ......................................... 11\n2.4. Encapsulamiento: implementaci\u00f3n frente a interfaz ....................... 11\n2.4.1. Atributo frente a variable de instancia ................................... 13\n2.5. Herencia: jerarqu\u00eda de clases ............................................................ 14\n2.5.1. Tipo y clase ............................................................................. 17\n2.6. Agregaci\u00f3n: jerarqu\u00eda de objetos ...................................................... 172.7. Persistencia ....................................................................................... 18\n2.8. PostgreSQL y la orientaci\u00f3n a objetos .............................................. 18\n3. Acceso a un servidor PostgreSQL .................................................... 20\n3.1. La conexi\u00f3n con el servidor ............................................................. 20\n3.2. El cliente psql .................................................................................... 203.3. Introducci\u00f3n de sentencias .............................................................. 21\n3.3.1. Expresiones y variables .......................................................... 22\n3.4. Proceso por lotes y formatos de salida ............................................. 233.5. Usar bases de datos ........................................................................... 27\n4. Creaci\u00f3n y manipulaci\u00f3n de tablas ................................................ 29\n4.1. Creaci\u00f3n de tablas ............................................................................ 294.2. Herencia ............................................................................................ 32\n4.3. Herencia y OID ................................................................................. 34\n4.4. Restricciones ..................................................................................... 37\n4.4.1. Restricciones de tabla ............................................................. 40\n4.5. Indexaci\u00f3n ........................................................................................ 424.6. Consulta de informaci\u00f3n de bases de datos y tablas ........................ 424.7. Tipos de datos ................................................................................... 44\n4.7.1. Tipos l\u00f3gicos ........................................................................... 44\n4.7.2. Tipos num\u00e9ricos ..................................................................... 444.7.3. Operadores num\u00e9ricos ........................................................... 45\uf8e9 FUOC \u2022 71Z799014MO Bases de datos en PostgreSQL\n4.7.4. Tipos de caracteres ................................................................. 46\n4.7.5. Operadores ............................................................................. 474.7.6. Fechas y horas ........................................................................ 484.7.7. Arrays ...................................................................................... 484.7.8. BLOB ....................................................................................... 50\n4.8. Modificaci\u00f3n de la estructura de una tabla ...................................... 53\n5. Manipulaci\u00f3n de datos ...................................................................... 54\n5.1. Consultas .......................................................................................... 545.2. Actualizaciones e inserciones ........................................................... 555.3. Transacciones .................................................................................... 56\n6. Funciones y disparadores .................................................................. 57\n6.1. Primer programa ............................................................................... 576.2. Variables ........................................................................................... 586.3. Sentencias ......................................................................................... 586.4. Disparadores ..................................................................................... 61\n7. Administraci\u00f3n de PostgreSQL ........................................................ 63\n7.1. Instalaci\u00f3n ........................................................................................ 63\n7.1.1. Internacionalizaci\u00f3n .............................................................. 64\n7.2. Arquitectura de PostgreSQL .............................................................. 657.3. El administrador de postgres ............................................................ 66\n7.3.1. Privilegios ............................................................................... 67\n7.4. Creaci\u00f3n de tipos de datos ............................................................... 68\n7.5. Plantilla de creaci\u00f3n de bases de da tos ......... .......... .......... .......... ...... 70\n7.6. Copias de seguridad .......................................................................... 717.7. Mantenimiento rutinario de la base de datos .................................. 72\n7.7.1. vacuum  .................................................................................... 72\n7.7.2. Reindexaci\u00f3n .......................................................................... 73\n7.7.3. Ficheros de registro ................................................................ 73\n8. Cliente gr\u00e1fico: pgAdmin3 ............................................................... 74\nResumen ...................................................................................................... 76\nBibliograf\u00eda ................................................................................................ 77\uf8e9 FUOC \u2022 71Z799014MO 5 Bases de datos en PostgreSQL\nIntroducci\u00f3n\nPostgreSQL es un gestor de bases de  datos orientadas a objetos (SGBDOO o\nORDBMS en sus siglas en ingl\u00e9s) muy co nocido y usado en entornos de software\nlibre porque cumple los est\u00e1ndares SQL92 y SQL99, y tambi\u00e9n por el conjuntode funcionalidades avanzadas que soporta, lo que lo sit\u00faa al mismo o a un mejor\nnivel que muchos SGBD comerciales.\nEl origen de PostgreSQL se sit\u00faa en el gestor de bases de datos POSTGRES desarro-\nllado en la Universidad de Berkeley y qu e se abandon\u00f3 en favor de PostgreSQL a\npartir de 1994. Ya entonces, contaba con prestaciones que lo hac\u00edan \u00fanico en el\nmercado y que otros gestores de bases de datos comerciales han ido a\u00f1adiendo\ndurante este tiempo. \nPostgreSQL se distribuye bajo  licencia BSD, lo que perm ite su uso, redistribuci\u00f3n,\nmodificaci\u00f3n con la \u00fanica restricci\u00f3n de mantener el copyright del software a sus\nautores, en concreto el PostgreSQL Gl obal Development Group y la Universidad\nde California.\nPostgreSQL puede funcionar en m\u00faltiples plataformas (en general, en todas las\nmodernas basadas en Unix) y, a partir de la pr\u00f3xima vers i\u00f3n 8.0 (actualmente\nen su segunda beta), tamb i\u00e9n en Windows de forma na tiva. Para las versiones\nanteriores existen versiones binarias para  este sistema operativo, pero no tie-\nnen respaldo oficial.\nPara el seguimiento de los ejemplos y la  realizaci\u00f3n de las actividades, es im-\nprescindible disponer de los datos de acceso del usuario administrador del ges-\ntor de bases de datos. Aunque en algu nos de ellos los privilegios necesarios\nser\u00e1n menores, para los cap\u00edtulos que tratan la administraci\u00f3n del SGBDOO\nser\u00e1 imprescindible disponer de las credenciales de administrador.\nLas sentencias o comandos escritos por el usuario estar\u00e1n en fuente monoes-\npaciada, y las palabras que tienen un si gnificado especial en PostgreSQL esta-\nr\u00e1n en negrita . Es importante hacer notar qu e estas \u00faltimas no siempre son\npalabras reservadas, sino comandos o sent encias de psql (el cliente interactivo\nde PostgreSQL).\nLa versi\u00f3n de PostgreSQL que se ha ut ilizado durante la reda cci\u00f3n de este ma-\nterial, y en los ejemplos, es la 7.4, la  \u00faltima versi\u00f3n estable en ese momento,\naunque no habr\u00e1 ning\u00fan problema en ejecutarlos en versiones anteriores,\nhasta la 7.0.\uf8e9 FUOC \u2022 71Z799014MO 6 Bases de datos en PostgreSQL\nObjetivos\nEl objetivo principal de esta unidad es conocer el gestor de bases de datos relacio-\nnales con soporte para objetos PostgreSQL , y comentar tanto sus caracter\u00edsticas\ncomunes a otros gestores de bases de dato s, como las que lo distinguen de sus\ncompetidores de c\u00f3digo abierto.\nAdem\u00e1s, se ofrece la oportunidad de aplicar los conocimi entos aprendidos en\nel m\u00f3dulo referido a SQL sobre un sistem a gestor de base de datos real y exa-\nminar las diferencias entre el est\u00e1ndar y la implementaci\u00f3n que hace de \u00e9l el\nSGBD.\nPor \u00faltimo, se presentan las tareas de administraci\u00f3n del SGBD m\u00e1s habituales\nque un usuario debe llevar a cabo como administrador de Post-greSQL.\uf8e9 FUOC \u2022 71Z799014MO 7 Bases de datos en PostgreSQL\n1. Caracter\u00edsticas de PostgreSQL\nEn este apartado comentaremos las caracter\u00edsticas m\u00e1s relevantes de este SGBD\ncon soporte para objetos, tanto sus pres taciones m\u00e1s interesantes o destacadas,\ncomo las limitaciones en su dise\u00f1o o en  implementaci\u00f3n de los est\u00e1ndares SQL.\nTambi\u00e9n es interesante conocer un poco su  historia, ya que tanto por las personas\nque han participado en su desarrollo como  por su relaci\u00f3n con otros gestores de\nbases de datos, nos ayudar\u00e1 a tener una mejor visi\u00f3n de la evoluci\u00f3n del mismo.\n1.1. Breve historia\nLa historia de PostgreSQL se inicia  en 1986 con un proyecto del profesor\nMichael Stonebraker y un equipo de de sarrolladores de la Universidad Berkeley\n(California), cuyo nombre original era PO STGRES. En su dise\u00f1o se incluyeron al-\ngunos conceptos avanzados en bases de da tos y soporte parcial a la orientaci\u00f3n\na objetos.\nPOSTGRES fue comercializ ado por Illustra, una empresa que posteriormente\nform\u00f3 parte de Informix (que comercializaba el co nocido SGBD del mismo\nnombre, recientemente absorbida por IB M y su DB/2). Lleg\u00f3 un momento en\nque mantener el proyecto absorb\u00eda de masiado tiempo a los investigadores y\nacad\u00e9micos, por lo que en 1993 se liber\u00f3 la versi\u00f3n 4.5 y oficialmente se dio\npor terminado el proyecto.\nEn 1994, Andrew Yu y Jolly Chen incluy eron SQL en Postgres para posterior-\nmente liberar su c\u00f3digo en la web con el nombre de Postgres95. El proyecto\ninclu\u00eda m\u00faltiples cambios al c\u00f3digo or iginal que mejoraban su rendimiento y\nlegibilidad.\nEn 1996 el nombre cambi\u00f3 a PostgreSQL  retomando la secuencia original de\nversiones, por lo que se liber\u00f3 la versi\u00f3 n 6.0. En el a\u00f1o 2004 la \u00faltima versi\u00f3n\nestable oficial es la 7.4.6, mientras que la versi\u00f3n 8.0 est\u00e1 ya en fase final de\nestabilizaci\u00f3n.\n1.2. Prestaciones\nPostgreSQL destaca por su ampl\u00edsima lista  de prestaciones que lo hacen capaz\nde competir con cualquier SGBD comercial:\n\u2022 Est\u00e1 desarrollado en C, con herramientas como Yacc y Lex.Los desarrolladores de proyectos \nbasados en software libre tienen \nmuy en cuenta PostgreSQL cuando \nlos requerimientos de un proyecto \nexigen prestaciones de alto nivel.\uf8e9 FUOC \u2022 71Z799014MO 8 Bases de datos en PostgreSQL\n\u2022 La API de acceso al SGBD se encuentra disponible en C, C++, Java, Perl,\nPHP, Python y TCL, entre otros.\n\u2022 Cuenta con un rico conjunto de tipos de datos, permitiendo adem\u00e1s su ex-\ntensi\u00f3n mediante tipos y operadores de finidos y programados por el usuario.\n\u2022 Su administraci\u00f3n se basa en usuarios y privilegios.\u2022 Sus opciones de conectividad abarcan TCP/IP, sockets  Unix y sockets  NT,\nadem\u00e1s de soportar completamente ODBC.\n\u2022 Los mensajes de error pueden estar en  espa\u00f1ol y hacer ordenaciones correc-\ntas con palabras acentuadas o con la letra \u2018\u00f1\u2019.\n\u2022 Es altamente confiable en cuan to a estabilidad se refiere.\n\u2022 Puede extenderse con librer\u00edas extern as para soportar encriptaci\u00f3n, b\u00fas-\nquedas por similitud fo n\u00e9tica (soundex), etc.\n\u2022 Control de concurrencia multi-versi\u00f3 n, lo que mejora sensiblemente las\noperaciones de bloqueo y transacci ones en sistemas multi-usuario.\n\u2022 Soporte para vistas, claves for\u00e1neas, integridad referencial, disparadores,\nprocedimientos almacenados, subconsu ltas y casi todos los tipos y opera-\ndores soportados en SQL92 y SQL99.\n\u2022 Implementaci\u00f3n de algunas extensiones de orientaci\u00f3n a objetos. En Post-\ngreSQL es posible definir un nuevo tipo de tabla a partir de otra previamen-\nte definida.\n1.3. Limitaciones\nLas limitaciones de este tipo de gestores de bases de datos suelen identificarse muy\nf\u00e1cilmente analizando las prestaciones qu e tienen previstas para las pr\u00f3ximas ver-\nsiones. Encontramo s lo siguiente:\n\u2022 Puntos de recuperaci\u00f3n dentro de transacciones. Actualmente, las transac-\nciones abortan completamente si se encuentra un fallo durante su ejecu-\nci\u00f3n. La definici\u00f3n de puntos de re cuperaci\u00f3n permitir \u00e1 recuperar mejor\ntransacciones complejas.\n\u2022N o  s o p o r t a  tablespaces  para definir d\u00f3nde almacenar la base de datos, el es-\nquema, los \u00edndices, etc.\n\u2022 El soporte a orientaci\u00f3n a objetos es una simple extensi\u00f3n que ofrece pres-\ntaciones como la herencia , no un soporte completo.\uf8e9 FUOC \u2022 71Z799014MO 9 Bases de datos en PostgreSQL\n2. Introducci\u00f3n a la orientaci\u00f3n a objetos\nDado que PostgreSQL incluye extensio nes de orientaci\u00f3n a objetos (aunque\nno es, como ya hemos comentado, un SGBDOO completo), es interesante re-\npasar algunos de los conceptos relacionados con este paradigma de programa-ci\u00f3n y estructuraci\u00f3n de datos.\n2.1. El modelo orientado a objetos\nEn 1967, el lenguaje de programaci\u00f3n Simula aplicaba algunas ideas para mo-\ndelar aspectos de la rea lidad de forma mucho m\u00e1s directa que los m\u00e9todos tra-\ndicionales. Desde entonces, la orientac i\u00f3n a objetos (OO) ha adquirido cada\nvez mayor popularidad al demostrar sus ventajas, entre las cuales:\n\u2022 Permite un modelado m\u00e1s \u201cnatural\u201d de la realidad.\n\u2022 Facilita la reutilizaci\u00f3n de  componentes de software.\n\u2022 Ofrece mecanismos de abstracci\u00f3n para  mantener controla ble la construc-\nci\u00f3n de sistemas complejos.\nEn el mercado aparecen constantemente  herramientas y lenguajes de progra-\nmaci\u00f3n autodenominados orientados a objetos y los ya existentes evolucio-nan r\u00e1pidamente incluyendo nuevas ca racter\u00edsticas de OO. De la misma\nmanera, se han desarrollado  m\u00faltiples m\u00e9todos y metodolog\u00edas bajo este en-\nfoque, cada una con aportaciones propia s que llegan, en ocasiones, a resultar\ncontradictorias entre s\u00ed. Se ha logrado la creaci\u00f3n de un lenguaje unificado\npara el modelado, llama do precisamente UML ( unified modeling language ). La\nintenci\u00f3n de UML es ser independiente de cualquie r metodolog\u00eda y es preci-\nsamente esta independencia la que lo hace importante pa ra la comunicaci\u00f3n\nentre desarrolladores, ya que las metodolog\u00edas son muchas y est\u00e1n en constan-te evoluci\u00f3n.\nLamentablemente, a pesar de los muchos  esfuerzos y de importantes avances,\nlas ciencias de la computaci\u00f3n no han creado a\u00fan una definici\u00f3n de modelo\nde objetos  como tal. En un panorama como \u00e9ste, es indispensable, al menos,\nla existencia de un modelo informal de objetos  que oriente la evoluci\u00f3n de la tec-\nnolog\u00eda y que tenga la aprobaci\u00f3n de lo s expertos en la materia. Un modelo\nas\u00ed permitir\u00eda su estudio consistente por parte de lo s profesionales de las tec-\nnolog\u00edas de la informaci\u00f3n,  facilitar\u00eda la creaci\u00f3n de mejores lenguajes y he-\nrramientas y, lo que es m\u00e1s importante, definir\u00eda los est\u00e1ndares para una\nmetodolog\u00eda de desarrollo consistente y aplicable.\uf8e9 FUOC \u2022 71Z799014MO 10 Bases de datos en PostgreSQL\nSin embargo, este modelo no existe, lo  que provoca inconsistencias incluso en\nel tratamiento de los principios y concep tos b\u00e1sicos de la OO. Por eso, es fre-\ncuente encontrar errores graves en el desarrollo de sistem as OO y, lo que es\na\u00fan peor, se implementan soluciones de dudosa validez en herramientas de\ndesarrollo que se dicen orientadas a objetos.\nAun sin haber alcanzado la madurez, la orientaci\u00f3n a objeto s es el paradigma\nque mejor permite solucion ar los muchos y variados  problemas que existen en\nel desarrollo de software. En los pr\u00f3x imos apartados analizaremos los concep-\ntos b\u00e1sicos de este modelo para identi ficar algunos de los problemas que a\u00fan\ndebe resolver, lo que fac ilitar\u00e1 la comprensi\u00f3n y eval uaci\u00f3n de m\u00e9todos y he-\nrramientas OO.\n2.2. Objetos: clase frente a instancia\nLos objetos  son abstracciones que realizamos del mundo que nos rodea y que\nidentificamos por sus pr opiedades. Para la OO todo es un objeto. \nCada objeto tiene una existencia un tanto independiente de los dem\u00e1s obje-\ntos; es decir, tiene identidad  propia. Aunque dos objetos tengan exactamente\nlos mismos valores, no por eso ser\u00e1n el mismo objeto, seguir\u00e1n siendo entida-des diferentes. En los modelos OO, la id entidad se representa con el identifi-\ncador de objeto, IDO (OID en ingl\u00e9s, de object identifier ). Te\u00f3ricamente, el IDO\nde un objeto es \u00fanico e irrepetible en el tiempo y el espacio.\nLos IDO son el mecanismo que permite hacer referencia a un objeto desde\notro. De esta manera la s referencias tejen las re laciones entre objetos.\nTodos los objetos que comparten las mismas propiedades se dice que pertene-\ncen a la misma clase . En los modelos OO, las clases  le roban el papel central a\nlos objetos, ya que es a tr av\u00e9s de ellas como se defi nen las propiedades de \u00e9stos\ny adem\u00e1s se utilizan como pl antillas para crear objetos.\nAl crear un objeto utilizando la definici \u00f3n dada por una clase, obtenemos un va-\nlor para \u00e9l, es lo que se llama una instancia  del objeto. Durante la ejecuci\u00f3n de\nlos programas se trabaja co n instancias. Como concepto, la instancia es equiva-\nlente a una tupla (fila) concreta en  una tabla de una base de datos. Elementos fundamentales en OOFunci\u00f3n del IDO\nEl IDO permite que dos objetos \nid\u00e9nticos puedan diferenciarse, no es importante que el usua-rio conozca los IDO, lo impor-tante es que los diferencie el sistema.\nobjeto clase\uf8e9 FUOC \u2022 71Z799014MO 11 Bases de datos en PostgreSQL\n2.3. Propiedades: atribu to frente a operaci\u00f3n\nLas propiedades de los objetos pueden ser de dos tipos, din\u00e1micas y est\u00e1ticas.\nUn atributo  representa una propiedad est\u00e1ti ca de un objeto (color, coste,\nedad, etc.). Una operaci\u00f3n  representa una propiedad din\u00e1mica; es decir, una\ntransformaci\u00f3n sobre un atributo o una acci\u00f3n que puede realizar.\nEl conjunto de valores de los atributos en un momento dado se conoce como\nestado  del objeto. Los operadores act\u00faan so bre el objeto camb iando su estado.\nLa secuencia de estados por la que pasa un objeto al ejecutar operaciones de-\nfinen su comportamiento .\nLa posibilidad de definir comportamiento s complejos es lo que hace diferente\nla OO.\n2.4. Encapsulamiento: implementaci\u00f3n frente a interfaz\nLa estructura interna de los objetos debe  estar oculta al usuario de un objeto,\nno necesita conocerla para interactua r con \u00e9l. Los objetos se conciben como\nuna c\u00e1psula cuyo interior est\u00e1 oculto  y no puede ser alterado directamente\ndesde el exterior.\nA la estructura interna de un objeto se la denomina implementaci\u00f3n  y a la\nparte visible, la que se presenta al exterior, interfaz . La interfaz se define por\nsus atributos y operaciones.\nLa implementaci\u00f3n de una operaci\u00f3n se conoce como m\u00e9todo . La implemen-\ntaci\u00f3n de un atributo se realiza generalmente con variables de instancia .Propiedades de los objetos\nEncapsulamientoobjeto (instancia) clase\natributos (estado) atributos\noperaciones (comportamiento) operaciones\nLos tipos de datos \nabstractos\nLos tipos de datos abstractos \n(TDA) obedecen al mismo principio de independencia de la implementaci\u00f3n. La dife-\nrencia respecto a los objetos es \nque \u00e9stos incluyen los datos y las operaciones en la misma c\u00e1psula.\nClase\nimplementaci\u00f3n interfaz\nvariables atributos\nm\u00e9todos operaciones\uf8e9 FUOC \u2022 71Z799014MO 12 Bases de datos en PostgreSQL\nEl encapsulamiento comporta las siguientes ventajas:\n\u2022 La modificaci\u00f3n interna (de la implem entaci\u00f3n) de un objeto para corre-\ngirlo o mejorarlo no afecta a sus usuarios.\n\u2022 La dificultad inherente a la modificaci \u00f3n de la implementaci\u00f3n de un ob-\njeto sea independiente del tama\u00f1o tota l del sistema. Esto  permite que los\nsistemas evolucionen con mayor facilidad.\n\u2022 La simplificaci\u00f3n en el uso del objeto al ocultar los detalle s de su funciona-\nmiento y presentarlo en t\u00e9rminos de sus propiedades. Al elevar el nivel de\nabstracci\u00f3n se disminuye el nivel de co mplejidad de un sistema. Es posible\nmodelar sistemas de mayor tama\u00f1o con menor esfuerzo.\n\u2022 Constituye un mecanismo de integridad. La dispersi\u00f3n de un fallo a trav\u00e9s\nde todo el sistema es menor, puesto que al presentar una divisi\u00f3n entre in-\nterfaz e implementaci\u00f3n, los fallos inte rnos de un objeto encuentran una\nbarrera en el encapsulamiento antes de propagarse al resto del sistema.\n\u2022 Permite la sustituci\u00f3n de objetos con la misma interfaz y diferente imple-\nmentaci\u00f3n. Esto permit e modelar sistemas de mayor tama\u00f1o con menor\nesfuerzo.\nParad\u00f3jicamente, el encapsulamiento, a pesar de ser uno de los conceptos b\u00e1-\nsicos en la OO, no siempre se interpre ta y se aplica correctamente. Especial-\nmente en lo referente a en capsulamiento de atributos.\nDiferenciemos operaci\u00f3n y m\u00e9to do a trav\u00e9s de un ejemplo.\nConsideremos tres objetos:  pol\u00edgono, c\u00edrculo y punto.\nA los tres se les solicita la operaci\u00f3n de  imprimir. En esta situaci\u00f3n, tenemos que:\n\u2022 La operaci\u00f3n solicitada es la misma, porqu e el significado del resultado es el mismo.\n\u2022 Cada objeto ejecuta la operaci\u00f3n de forma di ferente; es decir, con un m\u00e9todo diferente.\n\u2022 Cada objeto, internamente, puede tener m\u00e1s de un m\u00e9todo y selecciona el m\u00e1s apro-\npiado seg\u00fan las circunstancias.Estas caracter\u00edsticas de l encapsulamiento han contribuido en gran me-\ndida a la buena reputaci\u00f3n de la OO.\nLas operaciones no son exclusivas de  los tipos de objeto, los m\u00e9todos\ns\u00ed. Una operaci\u00f3n especifica \u201cqu\u00e9\u201d hacer y un m\u00e9todo \u201cc\u00f3mo\u201d hacer-lo. Esta diferencia permite tener m\u00faltiples m\u00e9todos para una misma\noperaci\u00f3n. \uf8e9 FUOC \u2022 71Z799014MO 13 Bases de datos en PostgreSQL\nVeamos ahora la diferencia entre atribu tos y variables de instancia, que puede\nparecer m\u00e1s sutil.\nUn atributo es la vista externa de una propiedad est\u00e1tica de un objeto. La re-\npresentaci\u00f3n interna puede variar, lo s atributos pueden implementarse tam-\nbi\u00e9n con m\u00e9todos. Tomemos como ejempl o el objeto punto con los atributos\nque se muestran a continuaci\u00f3n:\nLos atributos de un punto pueden defi nirse en coordenadas angulares o rec-\ntangulares; en este caso, es posible conocer ambas representaciones. En la\nimplementaci\u00f3n de estos atributos, do s pueden ser variables de instancia y\nlos otros dos se implementan como m\u00e9todos, que se calculan a trav\u00e9s de los\nprimeros. \nDesde el exterior no debe ser posible conocer la representaci\u00f3n elegida inter-\nnamente. Puede cambiarse la implementaci\u00f3n de los atributos sin alterar la in-terfaz. En algunos casos puede incluso pe rmitirse al sistema la elecci\u00f3n de la\nrepresentaci\u00f3n interna de un atributo del mismo modo que una operaci\u00f3n elige\nentre varios m\u00e9todos disponibles.\n2.4.1. Atributo frente a variable de instancia\nUn atributo especifica una cualidad de un objeto; una variable de instancia es-\npecifica c\u00f3mo se almacenan lo s valores para esa cualidad.\nConsideremos tres objetos, nombre, foto, v\u00edde o, de los que necesitamos conocer el tama-\n\u00f1o y prever, as\u00ed, el espacio nece sario para almacenarlos en disco.\nEn esta situaci\u00f3n tenemos que:\n\u2022 El atributo es el mism o, porque su lectura tien e el mismo significado.\n\u2022 Cada objeto implementa el atributo de ma nera diferente. Sin importar la implementa-\nci\u00f3n, externamente todos los atributos entr egan el mismo tipo de valor. Por ejemplo:\n\u2013 El nombre puede utilizar un byte como vari able de instancia, porque el tama\u00f1o de un\nnombre no puede ser mayor que 255 caract eres, o se puede implementar un m\u00e9todo\nque calcule el tama\u00f1o en  tiempo de ejecuci\u00f3n.\n\u2013 La foto utilizar\u00e1 dos o cuatro bytes.\n\u2013 El v\u00eddeo puede almacenar el valor de tama\u00f1o en m\u00faltiplos de K. \n\u2022 Cada objeto puede tener implementaciones alternativas que se adapten a las circuns-\ntancias.Punto\n+ x: float\n+ y: float\n+ radio: float\n+ \u00e1ngulo: float\nLos atributos\nUn atributo puede ser almace-\nnado en una variable o calcula-do por un m\u00e9todo.\uf8e9 FUOC \u2022 71Z799014MO 14 Bases de datos en PostgreSQL\nLamentablemente, los leng uajes de programaci\u00f3n co m\u00fanmente utilizados no\nimplementan mecanismos adecuados para  el encapsulamiento de los atribu-\ntos, llegando, incluso, a pe rmitir el acceso p\u00fablico a variables de instancia. A\ncontinuaci\u00f3n, analizaremos las grav es consecuencias de este hecho.\nAcceder a un atributo es, en realidad, una operaci\u00f3n que puede ser de lectura o de\nescritura. Por este motivo, frecuentemente se define el encapsulamiento como laocultaci\u00f3n de todas las variables permitiend o el acceso del exte rior s\u00f3lo para ope-\nraciones. Cuando el lenguaje de programa ci\u00f3n no ofrece independencia de la im-\nplementaci\u00f3n en los atributos, se deben definir una variable de instancia y dos\nm\u00e9todos por cada atributo: LeerAtributo  y EscribirAtributo .\nLas bases de datos relacionales tienen perfectamente diferenciada la interfaz\nde la implementaci\u00f3n en sus tipos de datos: la forma de almacenarlos es com-\npletamente independiente de la forma de consultarlos o guardarlos. No seconciben las operaciones co mo internas a los objetos.\nEl encapsulamiento ha sido consider ado como un principio central de la\norientaci\u00f3n a objetos y aten tar contra \u00e9l significa pa ra muchos romper con sus\nreglas fundamentales. Sin embargo, las bases de datos orientadas a objetos tie-nen entre sus funciones la realizaci\u00f3n de  consultas, que necesita acceder a los\natributos de los objetos. Dado que los objetos se implementan con variables,al accederlos se rompe el encapsulamiento.\nLa mayor\u00eda de los lenguaje s orientados a objetos permiten romper el encapsu-\nlamiento de forma pa rcial, declarando variables como p\u00fablicas. El encapsula-\nmiento, en estos casos, se proporciona como un mecanismo opcional, ya que\nel usuario puede declarar todas las variab les p\u00fablicas y, por lo tanto, accesibles\ndirectamente.\nOtros lenguajes implementan operacione s de lectura/escr itura que permiten\nacceder a las variables sin romper el encapsulamiento.\n2.5. Herencia: jerarqu\u00eda de clases\nLa herencia se define como  el mecanismo mediante el cual se utiliza la defini-\nci\u00f3n de una clase llamada \u201cpadre\u201d, para definir una nueva clase llamada \u201chija\u201dque puede heredar sus atributos y operaciones. Implementaci\u00f3n del encapsulamiento\nClase\nimplementaci\u00f3n interfaz\nvariables operaciones de lectura/escritura\nm\u00e9todos operaciones\uf8e9 FUOC \u2022 71Z799014MO 15 Bases de datos en PostgreSQL\nA las clases \u201chijo\u201d tamb i\u00e9n se les conoce como subclases , y a las clases \u201cpadre\u201d\ncomo superclases . La relaci\u00f3n de herencia entre clases genera lo que se llama\njerarqu\u00eda de clases .\nHablamos de herencia de tipo cuando la subclase hereda la interfaz de una su-\nperclase; es decir, los atributos y las operaciones. Hablamos de herencia estruc-tural cuando la subc lase hereda la implementaci\u00f3n  de la superclase; es decir,\nlas variables de instancia y los m\u00e9todos.\nLa herencia de tipo define relaciones es-un  entre clases, donde la clase \u201chijo\u201d\ntiene todas las propiedades del \u201cpadre\u201d, pero el \u201cpadre\u201d no tiene todas las pro-\npiedades del \u201chijo\u201d.\nConsideremos una referencia mascota que es de tipo animal, en alg\u00fan lengua-\nje de programaci\u00f3n.\nmimascota: Animal;\nPuede hacer referencia a objetos de ti po animal, o tipos derivados de \u00e9ste,\ncomo perro, gato o canario, por ejemplo.\nmimascota = new Canario;\nSe construye un nuevo canario y se hace referencia a \u00e9l como mascota.\nLa propiedad de sustituir objetos que descienden del mismo padre se conoce\ncomo polimorfismo, y es un mecanism o muy importante de reutilizaci\u00f3n en\nla OO.\nLa referencia al tipo animal es una re ferencia polimorfa, ya  que puede referirse\na tipos derivados de animal. A trav\u00e9s de una referencia polimorfa se pueden\nsolicitar operaciones sin conocer el tipo exacto.\nmimascota.comer();\nLa operaci\u00f3n comer tiene el mismo sign ificado para todos los animales. Como\nya hemos comentado, cada uno utilizar\u00e1 un m\u00e9todo distinto para ejecutar la\noperaci\u00f3n.\nPara conocer el tipo exacto  del objeto en cuesti\u00f3n, se utiliza el operador de in-\nformaci\u00f3n de tipo . De este modo puede acceders e a las propiedades espec\u00edfi-\ncas de un tipo de objeto qu e no est\u00e1n en los dem\u00e1s tipos.\nEn este ejemplo llamamos al operador informaci\u00f3n de tipo, instancia-de.\nif (mimascota instancia-de  Canario)\nmimascota.cantar();\nSi la mascota es una instancia del tipo Canario entonces se le solicitar\u00e1 cantar, que es una\npropiedad que no tienen todas las mascotas.La herencia de tipo\nEn la herencia de tipo lo que \nhereda la subclase son los atri-butos de la superclase, pero no necesariamente su implemen-taci\u00f3n, puesto que puede vol-ver a implementarlos.\nEjemplo\nUn gato es-un animal. Todas \nlas propiedades de la clase \u201canimal\u201d las tiene la clase \u201cga-to\u201d. Pero un animal no-es ne-cesariamente un  gato. Todas \nlas propiedades de gato no las tienen todos los animales.\uf8e9 FUOC \u2022 71Z799014MO 16 Bases de datos en PostgreSQL\nUna clase puede heredar las propiedades de dos superclases mediante lo que\nse conoce como herencia m\u00faltiple .\nEn una herencia m\u00faltiple, puede ocurrir que en amba s superclases existan pro-\npiedades con los mismos nombre s, situaci\u00f3n que se denomina colisi\u00f3n de\nnombres.  A continuaci\u00f3n, se relacionan los posibles casos de  colisi\u00f3n de nom-\nbres en la herencia de tipo:\n\u2022 Los nombres son iguales porque se re fieren a la misma propiedad (ya he-\nmos visto ejemplos de ello: la operaci\u00f3 n imprimir y el atributo tama\u00f1o). En\neste caso no hay conflicto porque el significado est\u00e1 claro: es la misma pro-\npiedad, s\u00f3lo hay que definir una implementaci\u00f3n adecuada.\n\u2022 Los nombres son iguales pero tienen significados diferentes. Esta situaci\u00f3n\nes posible porque el modelado es una tarea subjetiva y se soluciona cam-\nbiando los nombres de las propiedades heredadas que tengan conflicto.\nLa herencia m\u00faltiple no comporta prob lemas para la herenc ia de tipo, puesto\nque no pretende la reutiliz aci\u00f3n de c\u00f3digo, sino el control conceptual de la\ncomplejidad de los sistemas medi ante esquemas de clasificaci\u00f3n.\nPor lo que respecta a la he rencia estructural, que, re cordemos, consiste en que\nla subclase hereda las variables de inst ancia y los m\u00e9todos de la superclase \u2013es\ndecir, la implementaci \u00f3n\u2013, la cosa cambia.\nPara entender mejor la herencia estructura l, diremos informalmente que representa una\nrelaci\u00f3n funciona-como . Por ejemplo, se puede utilizar para definir un avi\u00f3n tomando\ncomo superclase ave, de esta manera la capacidad de volar del ave queda implementada\nen el avi\u00f3n. Un avi\u00f3n no es-un  ave, pero podemos decir que funciona-como  ave. \nAl aplicar la herencia de esta manera se dificulta la utilizaci\u00f3n del polimorfis-\nmo: aunque un objeto funcione internam ente como otro, no se garantiza que\nexternamente pueda tomar su lugar porque funciona-como .\nEl objetivo de la herencia estructural es la reutilizaci\u00f3n de c\u00f3digo, aunque en\nalgunos casos, como el ejemplo anterior, pueda ha cer conceptualmente m\u00e1s\ncomplejos los sistemas.\nSiempre que es posible aplicar la herenc ia de tipo, puede ap licarse la herencia\nestructural, por lo que la  mayor\u00eda de los lenguajes de programaci\u00f3n no hacen\ndistinci\u00f3n entre los dos tipos de herencia.\nLa herencia estructural m\u00faltiple  permite heredar variab les y m\u00e9todos de va-\nrias superclases, pero surgen problema s que no son f\u00e1ciles de resolver, espe-\ncialmente con las variables de instancia.Los lenguajes de programaci\u00f3n com\u00fa nmente no hacen distinci\u00f3n entre\nla herencia estructural y la herencia de tipo.Ejemplo\nSi un canario es-un  animal, \nentonces un canario funciona-\ncomo  animal, m\u00e1s otras propie-\ndades especificas de canario.\uf8e9 FUOC \u2022 71Z799014MO 17 Bases de datos en PostgreSQL\nPara resolver el conflicto de una variab le de instancia duplicada, se puede op-\ntar por las siguientes soluciones:\n\u2022 Cambiar los nombres, lo que puede pr ovocar conflictos en los m\u00e9todos que\nlas utilizan.\n\u2022 Eliminar una de las variables. Pero pu ede pasar que realicen alguna funci\u00f3n\nindependiente, en cuyo caso, ser\u00eda un error eliminar una.\n\u2022 No permitir herencia m\u00faltiple cuando hay variables duplicadas.\nComo se puede observar, no es f\u00e1cil solucionar conflictos entre variables de\ninstancia, por ello muchos lenguajes optan por diversos mecanismos inclu-\nyendo la prohibici\u00f3n de la herencia m\u00faltiple.\n2.5.1. Tipo y clase\nTenemos que advertir que la mayor\u00eda de  lenguajes de programaci\u00f3n no dife-\nrencian los conceptos de tipo y clase y que la diferencia que establecen algu-\nnos autores no es demasiado clara. De to das maneras, la tend encia ser\u00eda definir\ndichos conceptos como sigue:\n\u2022 Un tipo es un conjunto de objetos que comparten la misma interfaz.\u2022 Una clase es un conjunto de obje tos que comparten la misma implemen-\ntaci\u00f3n.\nUna soluci\u00f3n que se aplica es inclui r en el lenguaje el concepto de interfaz\nque define solamente las operaciones de una clase, pero no ofrece alternativas\npara los atributos. Sin embargo, con la diferenciaci\u00f3n entre clases e interfaces\nno se logra la diferenciaci\u00f3n entre los dos tipos de herencia, pues las clases se\nutilizan para representar relaciones es-un .\n2.6. Agregaci\u00f3n: jerarqu\u00eda de objetos\nLos objetos son, por naturaleza, complejos; es decir, est\u00e1n compuestos de ob-\njetos m\u00e1s peque\u00f1os. Un sistema de info rmaci\u00f3n debe reflejar esta propiedad\nde los objetos de forma natural. En una base de datos relacional, un objetocomplejo debe ser descompuesto en sus partes m\u00e1s simples para ser almacena-\ndo. Al extraerlo, es necesario ensamblar cada una de sus partes.\nPor este motivo el modelo relacional compor ta problemas cuando se utiliza en aplicacio-\nnes como el CAD, donde los objetos que se procesan son muy complejos.\nLas bases de datos de objetos deben pr oporcionar la facilidad de obtener un\nobjeto complejo en una sola consulta de forma transparente. En este caso, losEjemplo\nUn autom\u00f3vil est\u00e1 compuesto \nde carrocer\u00eda, motor, ruedas, etc.\uf8e9 FUOC \u2022 71Z799014MO 18 Bases de datos en PostgreSQL\napuntadores son un mecanismo excelent e para representar composici\u00f3n, ya\nque permiten acceder r\u00e1pidamente a las partes componentes de un objeto, sin\nimportar su lugar de almacenamiento.\nLas bases de datos requieren independencia de la aplicaci\u00f3n, lo que provoca\nun conflicto conceptual cuando se trabaja con objetos compuestos: las basesde datos deben almacenar informaci\u00f3n independient e de la aplicaci\u00f3n para\nque nuevas aplicaciones pued an hacer diferentes interp retaciones de la infor-\nmaci\u00f3n original; pero con los objetos co mpuestos esto no es  tan sencillo, pues-\nto que suelen tener una so la interpretaci\u00f3n, o mejor dicho, una sola manera\nde ser consultado en una base de datos.\n2.7. Persistencia\nLa persistencia se define como la capacidad de un objeto para sobrevivir al\ntiempo de ejecuci\u00f3n de un programa. Para implem entarla, se utiliza el alma-\ncenamiento secundario.\nSe han propuesto varios mecanismos para  implementar la persistencia en los\nlenguajes de programaci\u00f3n, entre los que podemos destacar los siguientes:\n\u2022 Archivos planos. Se crean archivos pa ra almacenar los objetos en el forma-\nto deseado por el programa dor. Los objetos se cargan al abrir el programa\ny se guardan al finalizar. \u00c9sta es la opci\u00f3n m\u00e1s accesible para todos los len-\nguajes de programaci\u00f3n.\n\u2022 Bases de datos relacionales. Los objetos son mapeados a tablas, un m\u00f3dulo\ndel programa se encarga de hacer las transformaciones objeto-relacionales.\nEste enfoque consume mucho tiempo al realizar el mapeo. Existen algunas\nherramientas que realizan mapeos semiautom\u00e1ticos.\n\u2022 Bases de objetos. Los objetos son almacenados de forma natural en una\nbase de objetos, y la consulta y recupe raci\u00f3n es administrada por el gestor,\nde esta forma las aplicac iones no necesitan saber nada sobre los detalles de\nimplementaci\u00f3n.\n\u2022 Persistencia transparente. Los objetos son almacenados y recuperados por\nel sistema cuando \u00e9ste lo cree conveniente, sin que el usuario  deba hacerninguna solicitud expl\u00edcita de consulta, actualizaci\u00f3 n o recuperaci\u00f3n de in-\nformaci\u00f3n a una base de objetos. No se  requiere, por lo tanto, otro lenguaje\npara interactuar con las bases de datos.\n2.8. PostgreSQL y la orientaci\u00f3n a objetos\nEl argumento a favor de las bases de datos objeto-relacionales sostiene que per-\nmite realizar una migraci\u00f3n gradual de sistemas relacionales a los orientados\uf8e9 FUOC \u2022 71Z799014MO 19 Bases de datos en PostgreSQL\na objetos y, en algunas circunstancias, coexistir ambos tipos de aplicaciones\ndurante alg\u00fan tiempo.\nEl problema de este enfoque es que no es  f\u00e1cil lograr la coex istencia de dos mo-\ndelos de datos diferentes como son la orientaci\u00f3n a objetos y el modelo rela-\ncional. Es necesario equilibrar de algu na manera los conceptos de uno y otro\nmodelo sin que entr en en conflicto.\nUno de los conceptos fundamentales en la  orientaci\u00f3n a objetos es el concepto\nde clase. Existen dos enfoques para asoc iar el concepto de clase con el modelo\nrelacional:\n1.er enfoque: las clases definen tipos de tablas\n2.o enfoque: las clases definen tipos de columnas\nDado que en el modelo relacional la s columnas est\u00e1n definidas por tipos de\ndatos, lo m\u00e1s natural es  hacer corresponder las co lumnas con las clases.\nPostgreSQL implementa los objetos como tuplas y las clases como tablas. Aun-\nque tambi\u00e9n es posible definir nuevos tipos de datos mediante los mecanis-\nmos de extensi\u00f3n.\nDado que las tablas son clases, pueden definirse como herencia de otras. Las\ntablas derivadas son polim orfas y heredan todos los atributos (columnas) de\nla tabla padre  (incluida su clave primaria). Si  no se manejan con precauci\u00f3n,\nlas tablas polimorfas pueden conducir a errores de inte gridad al duplicar claves\nprimarias. PostgreSQL soporta algunas ex tensiones del lengua je SQL para crear\ny gestionar este tipo de tablas.1.er enfoque 2.o enfoque\nLos objetos son valores tuplasLas clases son dominios tablas\nLos mecanismos \nde extensi\u00f3n\nNo es habitual que el usuario \nutilice los mecanismos de ex-tensi\u00f3n pues se consideran mecanismos avanzados.\nVeremos estos conceptos m\u00e1s\nen detalle en el subapartado 4.2 de esta unidad did\u00e1ctica.\n\uf8e9 FUOC \u2022 71Z799014MO 20 Bases de datos en PostgreSQL\n3. Acceso a un servidor PostgreSQL\n3.1. La conexi\u00f3n con el servidor\nAntes de intentar conectarse con el servidor, debemos asegurarnos de que est\u00e1\nfuncionando y que admite co nexiones, locales (el SGBD se est\u00e1 ejecutando en\nla misma m\u00e1quina que intent a la conexi\u00f3n) o remotas. \nUna vez comprobado el correcto funcio namiento del servidor, debemos dis-\nponer de las credenciales necesarias para la conexi \u00f3n. Para simplificar, supon-\ndremos que disponemos de las credenciales* del administrador de la base de\ndatos (normalmente, usuario PostgreSQL y su contrase\u00f1a).\n3.2. El cliente psql\nPara conectarse con un servidor, se requiere, obviamente, un programa clien-\nte. Con la distribuci\u00f3n de PostgreSQL se  incluye un cliente,  psql, f\u00e1cil de uti-\nlizar, que permite la introducci\u00f3n inte ractiva de comandos en modo texto.\nEl siguiente paso es conocer el nombre de una base de datos residente en el\nservidor. El siguiente comando permite conocer las bases de datos residentes\nen el servidor:\nPara realizar una conexi\u00f3n, se requieren los si guientes datos:\n\u2022 Servidor. Si no se especifica, se utiliza localhost .\n\u2022 Usuario. Si no se especifica, se utiliz a el nombre de usuario Unix que ejecu-\nta psql.\n\u2022 Base de datos.\nEjemplos del uso de psql para conectarse con un servidor de bases de datos~$ psql -l\nList of databasesName       | Owner    | Encoding-----------+----------+-----------demo       | postgres | SQL_ASCIItemplate0  | postgres | SQL_ASCIItemplate1  | postgres | SQL_ASCII(3 rows)~$\n~$ psql -d demo\n~$ psql demo* Distintos tipos de credenciales \npermiten distintos niveles \nde acceso.\nEn el apartado que concierne \na la administraci\u00f3n de PostgreSQL se comenta detalladamente los aspectos relacionados con el sistema de usuarios, contrase\u00f1as y privilegios del SGBD.\n\uf8e9 FUOC \u2022 71Z799014MO 21 Bases de datos en PostgreSQL\nLas dos formas anteriores ejecut an psql con la base de datos demo .\nA partir del fragmento anterior, el cliente psql mostrar\u00e1 algo similar a lo siguiente:\nEl s\u00edmbolo \u2018#\u2019, que signific a que psql est\u00e1 listo para leer la entrada del usuario.\nLas sentencias SQL se env\u00edan directamente  al servidor para su interpretaci\u00f3n,\nlos comandos internos tienen la forma \\comando  y ofrecen opciones que no\nest\u00e1n incluidas en SQL y son interpretadas internamente por psql.\nPara terminar la sesi\u00f3n co n psql, utilizamos el comando \\q o podemos presio-\nnar Ctrl-D.\n3.3. Introducci\u00f3n de sentencias\nLas sentencias SQL que escribamos en el cliente deber\u00e1n terminar con \u2018;\u2019 o\nbien con \u2018\\g\u2019:\nCuando un comando ocupa m\u00e1s de una l\u00ednea, el indicador cambia de forma y\nva se\u00f1alando el elemento qu e a\u00fan no se ha completado.  ~$ psql -d demo -U yo\n~$ psql demo yo\n~$ psql -h servidor.org -U usuario -d basedatos\nWelcome to psql, the PostgreSQL interactive terminal.Type: \\copyright for distribution terms\n\\h for help with SQL commands\n\\? for help on internal slash commands\\g or terminate with semicolon to execute query\n\\q to quit\ndemo=#\ndemo=# select user;\ncurrent_user\n--------------\npostgres\n(1 row)\ndemo=#\ndemo=# select\ndemo-# user\\g\ncurrent_user\n--------------\npostgres\n(1 row)\ndemo=#Notaci\u00f3n\nHemos utilizado los dos co-\nmandos de ayuda que ofrece el lenguaje:\n\u2022\\h Explica la sintaxis de\nsentencias SQL.\n\u2022\\? Muestra los comandos \ninternos disponibles.\nPara salir de ayuda, se presiona \nla tecla \u2018q\u2019.\uf8e9 FUOC \u2022 71Z799014MO 22 Bases de datos en PostgreSQL\nEl cliente psql almacena la sentencia hast a que se le da la orden de enviarla al\nSGBD. Para visualizar el contenido del buffer  donde ha almacenado la senten-\ncia, disponemos de la orden \u2018\\p\u2019:\nEl cliente tambi\u00e9n dispone de una or den que permite borrar completamente\nel buffer  para empezar de nu evo con la sentencia:\n3.3.1. Expresiones y variables\nEl cliente psql dispone de multitud de prestaciones avanzadas; entre ellas (co-\nmo ya hemos comentado), el soporte pa ra sustituci\u00f3n de variables similar al\nde los shells  de Unix:\nEsta sentencia crea la variable \u2018var1\u2019 y le  asigna el valor \u2018dem ostraci\u00f3n\u2019. Para recu-\nperar el valor de la variable, simplement e deberemos incluirla precedida de \u2018:\u2019 en\ncualquier sentencia o bien ver su valor mediante la orden \u2018echo\u2019:Indicadores de PostgreSQL\nIndicador Significado\n=# Espera una nueva sentencia\n-# La sentencia a\u00fan no se ha terminado con \u201c;\u201d o \\g\n\u201c# Una cadena en comillas dobles no se ha cerrado\n\u2018# Una cadena en comillas simples no se ha cerrado\n(# Un par\u00e9ntesis no se ha cerrado\ndemo=> SELECT \ndemo-> 2 * 10 + 1 \ndemo-> \\p \nSELECT \n2 * 10 + 1 \ndemo-> \\g \n?column? \n---------- \n21 \n(1 row) \ndemo=> \ndemo=# select \u2018Hola\u2019\\r\nQuery buffer reset (cleared).\ndemo=#\ndemo=>\\set var1 demostracion\uf8e9 FUOC \u2022 71Z799014MO 23 Bases de datos en PostgreSQL\nDe la misma forma, psql define algunas variables especiales que pueden ser\n\u00fatiles para conocer deta lles del servidor al qu e estamos conectados:\nEl uso de variables puede ayudar en  la ejecuci\u00f3n de sentencias SQL:  \n3.4. Proceso por lotes y formatos de salida\nAdem\u00e1s de ser interactivo,  psql puede procesar coma ndos por lotes almacena-\ndos en un archivo del sistema operat ivo mediante la si guiente sintaxis:\nAunque el siguiente comando tambi\u00e9n funciona en el mismo sentido, no es recomenda-\nble usarlo porque de este modo, psql no muestra informaci\u00f3n de depuraci\u00f3n importante,\ncomo los n\u00fameros de l\u00ednea donde se locali zan los errores, en caso de haberlos:\nEl propio int\u00e9rprete psql nos proporci ona mecanismos para almacenar en fi-\nchero el resultado de las sentencias:\n\u2022 Especificando el fichero destino* directamente al finalizar una sentencia:demo=# \\ echo :var1\ndemostracion\ndemo-# \ndemo=# \\ echo :DBNAME :ENCODING :HOST :PORT :USER;\ndemo LATIN9 localhost 5432 postgresdemo=#\ndemo=> \\set var2 \u2018mi_tabla\u2019 demo=> SELECT * FROM :var2; \nSe debe ser muy cuidadoso con el us o de las comillas y tambi\u00e9n es im-\nportante tener en cuenta que dentro de cadenas de caracteres no se sus-\ntituyen variables.\n$ psql demo -f demo.psql\n$ psql demo < demo.psql\ndemo=# select user \\g /tmp/a.txt* Hemos almacenado el resultado \nen el fichero \u2018 /tmp/a.txt \u2019.\uf8e9 FUOC \u2022 71Z799014MO 24 Bases de datos en PostgreSQL\n\u2022 Mediante una pipe enviamos la salida a un comando Unix:\n\u2022 Mediante la orden \u2018\\o\u2019 se puede indica r d\u00f3nde debe ir la salida de las sen-\ntencias SQL que se ejecuten en adelante:  \n\u2022 Se puede solicitar la ej ecuci\u00f3n de un solo comando y terminar inmediata-\nmente mediante la siguiente forma:\n\u2022 Se puede especificar el formato de salida de los resultados de una sentencia.\nPor defecto, psql los muestra en forma tabular mediante texto. Para cambiarlo,\nse debe modificar el valor de la variab le interna \u2018format\u2019 mediante la orden\n\u2018\\pset\u2019. Veamos, en  primer lugar, la especifi caci\u00f3n del formato de salida:demo=# select user \\g | cat > /tmp/b.txt\ndemo=# \\o /tmp/sentencias.txt\ndemo=# select user ;\ndemo=# select 1+1+4;\ndemo=# \\o\ndemo=# select 1+1+4;\n?column?\n----------\n6\n(1 row)\ndemo=# \n$ psql -d demo -c \u201ccomando sql\u201d\ndemo=# \\pset format html\nOutput format is html.\ndemo=# select user;\n<table border=\u201c1\u201d>\n<tr>\n<th align=\u201ccenter\u201d>current_user</th>\n</tr><tr valign=\u201ctop\u201d>\n<td align=\u201cleft\u201d>postgres</td>\n</tr>\n</table>\n<p>(1 row)<br />\n</p>demo=#Notaci\u00f3n\nA la orden \u2018\\o\u2019 se le debe espe-\ncificar un ficher o o bien un co-\nmando que ir\u00e1 recibiendo los resultados mediante una pipe.\nCuando se desee volver a la sa-\nlida est\u00e1ndar STDOUT, simple-mente se dar\u00e1 la orden \u2018\\o\u2019 sin ning\u00fan par\u00e1metro.\nLa salida del fichero\nAl haber especificado que se \nquiere la salida en html, la po-dr\u00edamos redirigir a un fichero (ya hemos visto c\u00f3mo hacerlo) y generar un archivo html que permitiese ver el resultado de la consulta mediante un na-vegador web convencional.\uf8e9 FUOC \u2022 71Z799014MO 25 Bases de datos en PostgreSQL\nHay otros formatos de salid a, como \u2018aligned\u2019, \u2018unaligne d\u2019, \u2018html\u2019 y \u2018latex\u2019. Por\ndefecto, psql muestra el resultado en formato \u2018aligned\u2019.\nTenemos tambi\u00e9n multitud de variables para ajustar los se paradores entre co-\nlumnas, el n\u00famero de regi stros por p\u00e1gina, el separa dor entre registros, t\u00edtulo\nde la p\u00e1gina html, etc. Veamos un ejemplo:  \nPara poder realizar los ejem plos del resto del presente  apartado, se debe proce-\nsar el contenido del fichero demo.sql  tal como se transcribe a continuaci\u00f3n.\nContenido del fichero demo.psql   demo=# \\pset format unaligned\nOutput format is unaligned.\ndemo=# \\pset fieldsep  \u2018,\u2019\nField separator is \u201c,\u201d.\ndemo=# select user, 1+2+3 as resultado;\ncurrent_user,resultadopostgres,6\n(1 row)\ndemo=#La salida de este fichero\nCon esta configuraci\u00f3n, y diri-\ngiendo la salida a un fichero, generar\u00edamos un fichero CSV \nlisto para ser le\u00eddo en una hoja de c\u00e1lculo u otro programa de importaci\u00f3n de datos.\n--drop table productos;\n--drop table proveedores;--drop table precios;--drop table ganancia;\ncreate table productos (\nparte varchar(20),tipo varchar(20),especificaci\u00f3n varchar(20),psugerido float(6),clave serial,\nprimary key(clave)\n);\ninsert into productos (parte,tipo,especificaci\u00f3n,psugerido) values\n(\u2018Procesador\u2019,\u20192 GHz\u2019,\u201932 bits\u2019,null);\ninsert into productos (parte,tipo,especificaci\u00f3n,psugerido) values\n(\u2018Procesador\u2019,\u20192.4 GHz\u2019,\u201932 bits\u2019,35);\ninsert into productos (parte,tipo,especificaci\u00f3n,psugerido) values\n(\u2018Procesador\u2019,\u20191.7 GHz\u2019,\u201964 bits\u2019,205);\ninsert into productos (parte,tipo,especificaci\u00f3n,psugerido) values\n(\u2018Procesador\u2019,\u20193 GHz\u2019,\u201964 bits\u2019,560);\ninsert into productos (parte,tipo,especificaci\u00f3n,psugerido) values\n(\u2018RAM\u2019,\u2019128MB\u2019,\u2019333 MHz\u2019,10);\ninsert into productos (parte,tipo,especificaci\u00f3n,psugerido) values\n(\u2018RAM\u2019,\u2019256MB\u2019,\u2019400 MHz\u2019,35);\uf8e9 FUOC \u2022 71Z799014MO 26 Bases de datos en PostgreSQL\ninsert into productos (parte,tipo,especificaci\u00f3n,psugerido) values\n(\u2018Disco Duro\u2019,\u201980 GB\u2019,\u20197200 rpm\u2019,60);\ninsert into productos (parte,tipo,especificaci\u00f3n,psugerido) values\n(\u2018Disco Duro\u2019,\u2019120 GB\u2019,\u20197200 rpm\u2019,78);\ninsert into productos (parte,tipo,especificaci\u00f3n,psugerido) values\n(\u2018Disco Duro\u2019,\u2019200 GB\u2019,\u20197200 rpm\u2019,110);\ninsert into productos (parte,tipo,especificaci\u00f3n,psugerido) values\n(\u2018Disco Duro\u2019,\u201940 GB\u2019,\u20194200 rpm\u2019,null);\ninsert into productos (parte,tipo,especificaci\u00f3n,psugerido) values\n(\u2018Monitor\u2019,\u20191024x876\u2019,\u201975 Hz\u2019,80);\ninsert into productos (parte,tipo,especificaci\u00f3n,psugerido) values\n(\u2018Monitor\u2019,\u20191024x876\u2019,\u201960 Hz\u2019,67);\ncreate table proveedores (\nempresa varchar(20) not null,credito bool,efectivo bool,primary key empresa)\n);\ninsert  into  proveedores  (empresa,efectivo)  values  (\u2018Tecno-k\u2019,  true );\ninsert into proveedores (empresa,credito) values (\u2018Patito\u2019, true );\ninsert into proveedores (empresa,credito,efectivo) values\n(\u2018Nacio-nal\u2019, true, true );\ncreate table ganancia(\nventa varchar(16),factor decimal (4,2)\n);\ninsert into ganancia values(\u2018Al por mayor\u2019,1.05);\ninsert into ganancia values(\u2018Al por menor\u2019,1.12);\ncreate table precios (\nempresa varchar(20) not null,clave int not null,precio float(6), \nforeign key (empresa) references proveedores,\nforeign key (clave) references productos\n);\ninsert into precios values (\u2018Nacional\u2019,001,30.82);\ninsert into precios values (\u2018Nacional\u2019,002,32.73);insert into precios values (\u2018Nacional\u2019,003,202.25);insert into precios values (\u2018Nacional\u2019,005,9.76);insert into precios values (\u2018Nacional\u2019,006,31.52);insert into precios values (\u2018Nacional\u2019,007,58.41);insert into precios values (\u2018Nacional\u2019,010,64.38);insert into precios values (\u2018Patito\u2019,001,30.40);insert into precios values (\u2018Patito\u2019,002,33.63);insert into precios values (\u2018Patito\u2019,003,195.59);insert into precios values (\u2018Patito\u2019,005,9.78);\uf8e9 FUOC \u2022 71Z799014MO 27 Bases de datos en PostgreSQL\n3.5. Usar bases de datos\nLa siguiente orden informa sobre las bases de datos actualmente en el SGBD.\nLa orden \u2018\\c\u2019 permite conectarse a una base de datos:\nLa consulta de la tabla que contiene la base de datos demo  se realiza mediante\nla orden \u2018\\d\u2019:  insert into precios values (\u2018Patito\u2019,006,32.44);\ninsert into precios values (\u2018Patito\u2019,007,59.99);insert into precios values (\u2018Patito\u2019,010,62.02);insert into precios values (\u2018Tecno-k\u2019,003,198.34);insert into precios values (\u2018Tecno-k\u2019,005,9.27);insert into precios values (\u2018Tecno-k\u2019,006,34.85);insert into precios values (\u2018Tecno-k\u2019,007,59.95);insert into precios values (\u2018Tecno-k\u2019,010,61.22);insert into precios values (\u2018Tecno-k\u2019,012,62.29);\ndemo=# \\l\n        List of databasesName       |Owner     | Encoding\n-----------+----------+----------\n demo      | postgres | LATIN9 template0 | postgres | LATIN9 template1 | postgres | LATIN9(3 rows)\ndemo=#\ndemo=# \\c demo\nYou are now connected to database \u201cdemo\u201d.\ndemo=# \ndemo=# \\d\n                 List of relations\n Schema |        Name         |   Type   |  Owner--------+---------------------+----------+----------\n public | ganancia            | table    | postgres\n public | precios             | table    | postgres public | productos           | table    | postgres\n public | productos_clave_seq | sequence | postgres\n public | proveedores         | table    | postgres(5 rows)\uf8e9 FUOC \u2022 71Z799014MO 28 Bases de datos en PostgreSQL\nConsulta de las columnas de cada una de las tablas:\nPara crear una nueva base de datos, usaremos la sentencia create database :\nPara eliminar una base de da tos, usaremos la sentencia drop database :La orden \\d es \u00fatil para mostrar informac i\u00f3n sobre el SGBD: tablas, \u00edn-\ndices, objetos, variables, permisos, etc. Pod\u00e9is obtener todas las varian-\ntes de esta sentencia introduciendo \\? en el int\u00e9rprete de comandos.\ndemo-# \\d proveedores\n          Table \u201cpublic.proveedores\u201dColumn    |Type                   | Modifiers\n----------+-----------------------+-----------\n empresa  | character varying(20) | not null credito  | boolean               |\n efectivo | boolean               |\nIndexes:    \u201cproveedores_pkey\u201d primary key, btree (empresa)\nmysql> create database  prueba;\nmysql> drop database  prueba;\uf8e9 FUOC \u2022 71Z799014MO 29 Bases de datos en PostgreSQL\n4. Creaci\u00f3n y manipulaci\u00f3n de tablas\n4.1. Creaci\u00f3n de tablas\nUna vez conectados a una base de datos, la sentencia SQL create table  per-\nmite crear las tablas que necesitemos:\nEl comando drop table  permite eliminar tablas:\nLa tabla reci\u00e9n creada aparece ahora en la lista de tablas de la base de datos en uso:\nPodemos consultar su descripci\u00f3n mediante el comando \\d tabla :\nLa tabla est\u00e1 lista para insert ar en ella algunos registros.demo=# create table  persona (\ndemo(# nombre varchar(30),\ndemo(# direccion varchar(30)\ndemo(# );CREATE\ndemo=# drop table  persona;\ndemo=# \\dt\nList of relations\nName     |Type   |Owner\n---------+-------+-------- persona | table | quiron\n(1 row)\ndemo=# \\d persona\nTable \u201cpersona\u201d\nColumn     |Type                   | Modifiers\n-----------+-----------------------+-----------    nombre | character varying(30) |\n direccion | character varying(30) |\ndemo=# insert into  persona values ( \u2018Alejandro Magno\u2019 , \u2018Babilonia\u2019 );\nINSERT 24756 1\ndemo=#  insert  into  persona  values  ( \u2018Federico Garc\u00eda Lorca  \u2018 , \u2018Granada 65\u2019  );\nINSERT 24757 1\uf8e9 FUOC \u2022 71Z799014MO 30 Bases de datos en PostgreSQL\nEl n\u00famero con el que responde el comando insert  se refiere al OID del registro\ninsertado.\nLas consultas se realizan con la sentencia SQL select. En este caso solicita-\nmos que nos muestre toda s las columnas de los registros en la tabla persona :\nLas tablas creadas en PostgreSQL incluy en, por defecto, varias columnas ocul-\ntas que almacenan informaci\u00f3n acerca del identificador de transacci\u00f3n en quepueden estar implicad as, la localizaci\u00f3n f\u00edsica del registro dentro de la tabla\n(para localizarla muy r\u00e1pida mente) y, los m\u00e1s importantes, el OID y el TABLE-\nOID. Estas \u00faltimas columnas est\u00e1n defini das con un tipo de datos especial lla-\nmado identificador de objeto (OID) que se implementa como un enteropositivo de 32 bits. Cuando se inserta un nuevo registro en una tabla se le asig-na un n\u00famero consecutivo como OID, y el TABLEOID de la tabla que le co-rresponde.\nPara observar las columnas  ocultas, debemos hacer re ferencia a ellas espec\u00edfi-\ncamente en el comando select :\n demo=# select * from persona;\nnombre                 |direccion-----------------------+------------\n Alejandro Magno       | Babilonia\n Federico Garc\u00eda Lorca | Granada 65(2 rows)\ndemo=# \nEn la programaci\u00f3n orientada a objetos, el concepto de OID es de vital\nimportancia, ya que se re fiere a la identidad propia del objeto, lo que lo\ndiferencia de los dem\u00e1s objetos.\ndemo=# select oid, tableoid, * from persona;\noid    |tableoid  |nombre                 |direccion\n-------+----------+-----------------------+------------\n 17242 |    17240 | Alejandro Magno       | Babilonia 17243 |    17240 | Federico Garc\u00eda Lorca | Granada 65\n(2 rows)\ndemo=# \nEstas columnas se implementan para se rvir de identificadores en la rea-\nlizaci\u00f3n de enlaces desde otras tablas.Este aspecto se explicar\u00e1 en detalle \nm\u00e1s adelante.\n\uf8e9 FUOC \u2022 71Z799014MO 31 Bases de datos en PostgreSQL\nEjemplo de la utilizaci\u00f3n de OID para enlazar dos tablas\nRetomamos la tabla persona  y construimos una nueva tabla para almacenar los tel\u00e9fonos.\nLa tabla tel\u00e9fono  incluye la columna propietario  de tipo OID, que almacenar\u00e1 la referencia\na los registros de la tabla persona . Agreguemos dos tel\u00e9fonos a \u2018Alejandro Magno\u2019, para\nello utilizamos su OID que es 17242:\nLas dos tablas est\u00e1n vinculadas por el OID de persona.\nLa operaci\u00f3n que nos permite unir las dos tablas es join, que en este caso une tel\u00e9fono  y\npersona , utilizando para ello la igualdad de las columnas telefono.propietario  y persona.oid :\nLos OID de PostgreSQL pres entan algunas deficiencias:\n\u2022 Todos los OID de una base de datos se generan a partir de una \u00fanica se-\ncuencia centralizada, lo que provoca que en bases de datos con mucha ac-\ntividad de inserci\u00f3n y elim inaci\u00f3n de registros, el contador de 4 bytes se\ndesborde y pueda entregar OID ya entregados. Esto sucede, por supuesto,\ncon bases de datos muy grandes.\n\u2022 Las tablas enlazadas mediante OID no tienen ninguna ventaja al utilizar\noperadores de composici\u00f3n en t\u00e9rminos  de eficiencia respecto a una clave\nprimaria convencional.\n\u2022 Los OID no mejoran el rendimiento.  Son, en realidad, una columna con\nun n\u00famero entero como valor.demo=# create table  telefono (\ndemo(# tipo char(10),\ndemo(# numero varchar(16),\ndemo(# propietario oid\ndemo(# );CREATE\ndemo=# insert into  telefono values( \u2018m\u00f3vil\u2019 , \u201812345678\u2019, 17242 );\ndemo=# insert into telefono values( \u2018casa\u2019 , \u2018987654\u2019, 17242 );\ndemo=# select * from  telefono;\ntipo        |numero       | propietario------------+-------------+-------------\n      m\u00f3vil |    12345678 |   17242\n       casa |      987654 |   17242(2 rows)\ndemo=# select * from  telefono join persona on (telefono.propietario = perso-na.oid);\ntipo        |numero       | propietario |nombre           | direccion------------+-------------+-------------+-----------------+-----------\n      m\u00f3vil |    12345678 |       17242 | Alejandro Magno | Babilonia\n       casa |      987654 |       17242 | Alejandro Magno | Babilonia(2rows)\uf8e9 FUOC \u2022 71Z799014MO 32 Bases de datos en PostgreSQL\nLos desarrolladores de PostgreSQL propon en la siguiente alternativa para usar\nOID de forma absolutamente segura:\n\u2022 Crear una restricci\u00f3n de tabla para qu e el OID sea \u00fanico, al menos en cada\ntabla. El SGBD ir\u00e1 incrementando se cuencialmente el OID hasta encontrar\nuno sin usar.\n\u2022 Usar la combinaci\u00f3n OID - TABLEOID si  se necesita un identificador \u00fanico\npara un registro v\u00e1lido en toda la base de datos.\nPor los motivos anteriores, no es reco mendable el uso de OID hasta que nue-\nvas versiones de PostgreSQL los corrijan.  En caso de usarlos, conviene seguir\nlas recomendacio nes anteriores.\nEs posible crear tablas que no incluyan  la columna OID medi ante la siguiente\nnotaci\u00f3n:\n4.2. Herencia\nPostgreSQL ofrece como caracter\u00edstica pa rticular la herencia entre tablas, que\npermite definir una tabla que herede de  otra previamente definida, seg\u00fan la\ndefinici\u00f3n de herencia que hemo s visto en cap\u00edtulos anteriores.\nRetomemos la tabla persona  definida como sigue:\nA partir de esta definici\u00f3n, creamos la tabla estudiante  como derivada de\npersona :create table  persona (\nnombre varchar(30),\ndireccion varchar(30)\n)without oids ;\ncreate table  persona (\nnombre varchar (30),\ndireccion varchar (30)\n);\ncreate table estudiante (\ndemo(# carrera varchar(50),\ndemo(# grupo char,\ndemo(# grado int\ndemo(# ) inherits  ( persona );\nCREATE\uf8e9 FUOC \u2022 71Z799014MO 33 Bases de datos en PostgreSQL\nEn la tabla estudiante  se definen las columnas carrera , grupo  y grado , pero al so-\nlicitar informaci\u00f3n de la estructura de  la tabla observamos que tambi\u00e9n inclu-\nye las columnas definidas en persona :\nEn este caso, a la tabla persona  la llamamos padre  y a la tabla estudiante , hija.\nCada registro de la tabla estudiante  contiene 5 valores porque tiene 5 columnas:  \nLa consulta del cont enido de la tabla estudiante  mostrar\u00e1, por supuesto, un\nsolo registro. Es decir, no  se heredan los datos, \u00fanicamente los campos (atri-\nbutos) del objeto:demo=# \\d estudiante\nTable \u201cestudiante\u201d\nColumn     |Type                   | Modifiers-----------+-----------------------+-----------\n    nombre | character varying(30) |\n direccion | character varying(30) |   carrera | character varying(50) |\n     grupo |          character(1) |\n     grado |               integer |\ndemo=# insert into estudiante values (\ndemo(# \u2018Juan\u2019 ,\ndemo(# \u2018Treboles 21\u2019,demo(# \u2018Ingenieria en Computacion\u2019,\ndemo(# \u2018A\u2019,\ndemo(# 3demo(# );\nINSERT 24781 1\nLa herencia no s\u00f3lo permite que la tabla hija contenga las columnas de\nla tabla padre , sino que establece una relaci\u00f3n conceptual es-un . \ndemo=# select * from  estudiante;\nnombre  |direccion    |carrera                    |grupo  | grado--------+-------------+---------------------------+-------+-------   Juan | Treboles 21 | Ingenieria en Computacion |     A | 3\n(1 row)\uf8e9 FUOC \u2022 71Z799014MO 34 Bases de datos en PostgreSQL\nAdem\u00e1s, la consul ta de la tabla persona  mostrar\u00e1 un nuevo registro:\nEl \u00faltimo registro mostrado es el que fue insertado en tabla estudiante , sin em-\nbargo la herencia define una rela ci\u00f3n conceptual en la que un estudiante  es-una\npersona . Por lo tanto, al consultar cu\u00e1ntas personas est\u00e1n registradas en la base\nde datos, se incluye en el resultado a todos los estudiantes. Para consultar s\u00f3lo\na las personas que no son estudiantes,  podemos utilizar el modificador ONLY:   \nComo es l\u00f3gico, al borrar la fila del nuevo estudiante que hemos insertado, se\nborra de las dos tablas. Tanto si lo borramos desde la tabla persona , como si lo\nborramos desde la tabla estudiante.  \n4.3. Herencia y OID\nLos OID permiten que se diferencien lo s registros de todas las tablas, aunque\nsean heredadas: nuestro estudiante tendr\u00e1 el mismo OID en las dos tablas, yaque se trata de \u00fanica instancia de la clase estudiante:demo=# select * from  persona;\nnombre                 | direccion-----------------------+-------------\n  Federico Garca Lorca | Granada 65\n       Alejandro Magno | Babilonia                  Juan | Treboles 21\n(3 rows)\ndemo=# select * from only  persona;\nnombre                 | direccion\n-----------------------+------------ Alejandro Magno       | Babilonia\n Federico Garc\u00eda Lorca | Granada 65\n(2 rows)demo=#\nNo es posible borrar una tabla padre  si no se borran primero las tablas\nhijo.\ndemo=# drop table  persona;\nNOTICE: table estudiante depende de table persona\nERROR: no se puede eliminar table persona porque otros objetos dependen de \u00e9lHINT: Use DROP ... CASCADE para eliminar adem\u00e1s los objetos dependientes.\uf8e9 FUOC \u2022 71Z799014MO 35 Bases de datos en PostgreSQL\nDado que no se recomienda el uso de OID en bases muy grandes, y debe in-\ncluirse expl\u00edcitamente en las consultas pa ra examinar su valor, es conveniente\nutilizar una secuencia compartida para padres y todos sus descendientes si se\nrequiere un identificador.\nEn PostgreSQL, una alternativa para no  utilizar los OID es  crear una columna\nde tipo serial  en la tabla padre , as\u00ed ser\u00e1 heredada en la hija. El tipo serial  define\nuna secuencia de valores que se ir\u00e1 incrementando de forma autom\u00e1tica, y porlo tanto constituye una buena forma de crear claves primarias, al igual que eltipo AUTO_INCREMENT en MySQL.\nLa columna id se define como un entero y se  incrementar\u00e1  utilizando la fun-\nci\u00f3n nextval()  tal como nos indica la informaci\u00f3n de la columna:demo=# select oid,* from persona ;\noid    |nombre                 | direccion\n-------+-----------------------+-------------\n 17242 | Alejandro Magno       | Babilonia 17243 | Federico Garc\u00eda Lorca | Granada 65\n 17247 | Juan                  | Treboles 21\n(3 rows)demo=# select oid,* from estudiante ;\noid    |nombre  |direccion    |carrera                    |grupo  | grado\n-------+--------+-------------+---------------------------+-------+------- 17247 | Juan   | Treboles 21 | Ingenieria en Computaci\u00f3n | A     |     3\n(1 row)\ndemo=# create table persona (\ndemo(# id serial,\ndemo(# nombre varchar (30),\ndemo(# direccion varchar(30)\ndemo(# ) without oids;\nNOTICE: CREATE TABLE will create implicit sequence \u2018persona_id_seq\u2019 for SERIAL column \u2018persona.\nNOTICE: CREATE TABLE / UNIQUE will create implicit index \u2018persona_id_key\u2019 for table \u2018persona\u2019\nCREATE\ndemo=# \\d persona\nTable \u201cpersona\u201dColumn   |Type                |Modifiers\n---------+---------------------+---------------------------------------------\nid|            integer |not null default nextval(\u2018\u201dpersona_id_seq\u201d\u2018::text)\nnombre|character varying(30)|\ndireccion|character varying(30)|\nUnique keys: persona_id_key\uf8e9 FUOC \u2022 71Z799014MO 36 Bases de datos en PostgreSQL\nAl definir un tipo serial , hemos creado im pl\u00edcitamente una secuencia indepen-\ndiente de la tabla. Podemos consultar las secuencias de nuestra base de datosmediante el comando \u2018\\ds\u2019:\nCreamos nuevamente la tabla estudiante  heredando de persona :\nEl estudiante heredar\u00e1 la columna id y se incrementar\u00e1 utilizando la misma se-\ncuencia:\nInsertaremos en la tabla algunos regist ros de ejemplo, omit iendo el valor para\nla columna id:demo=# \\ ds\n                 List of relations Schema |Name                 |Type      |Owner\n--------+---------------------+----------+----------\n public | productos_clave_seq | sequence | postgres(1 row)\ncreate table estudiante (\ndemo(# carrera varchar(50),\ndemo(# grupo char,\ndemo(# grado int\ndemo(# ) inherits  ( persona );\nCREATE\ndemo=# \\d persona\nTable \u201cpersona\u201dColumn   |Type                 |Modifiers\n---------+---------------------+---------------------------------------------\n       id|             integer |not null default next-val(\u2018\u201dpersona_id_seq\u201d\u2018::text)   nombre|character varying(30)|\ndireccion|character varying(30)|\n carrera |character varying(50)|   grupo |         character(1)|\n   grado |              integer| \ndemo=# insert into  persona(nombre,direccion)\nvalues ( \u2018Federico Garca Lorca\u2019 , \u2018Granada 65\u2019 );\ndemo=# insert into  persona(nombre,direccion)\nvalues ( \u2018Alejandro Magno\u2019 , \u2018Babilonia\u2019 );\ndemo=# insert into  estudiante(nombre,direccion,carrera,grupo,grado)\nvalues ( \u2018Elizabeth\u2019 , \u2018Pino 35\u2019, \u2018Psicologia\u2019 , \u2018B\u2019 , 5 );\uf8e9 FUOC \u2022 71Z799014MO 37 Bases de datos en PostgreSQL\nLa tabla estudiante  contendr\u00e1 un solo registro, pero su identificador es el\nn\u00famero 3.\nTodos los registros de persona  siguen una misma secuencia sin importar si son\npadres o hijos:\nLa herencia es \u00fatil para definir tabl as que conceptualmente mantienen ele-\nmentos en com\u00fan, pero tambi\u00e9n requ ieren datos que los hacen diferentes.\nUno de los elementos que conviene defi nir como comunes son los identifica-\ndores de registro.\n4.4. Restricciones\nComo ya sabemos, las restricciones pe rmiten especificar condiciones que de-\nber\u00e1n cumplir tablas o columnas para mant ener la integridad de sus datos. Al-\ngunas de las restricciones  vendr\u00e1n impuestas por el modelo concreto que se\nest\u00e9 implementando, mientras  que otras tendr\u00e1n su orig en en las reglas de ne-\ngocio del cliente, los valores que pueden tomar algunos campos, etc.\nLos valores que puede contener una co lumna est\u00e1n restringidos en primer\nlugar por el tipo de datos. \u00c9sta no es la \u00fanica restricci\u00f3n que se puede defi-nir para los valores en una columna, Po stgreSQL ofrece las restricciones si-\nguientes:\n\u2022null y not null . En m\u00faltiples ocasiones el va lor de una columna es desco-\nnocido, no es aplicable o no existe. En  estos casos, los valores cero, cadena\nvac\u00eda o falso son inadecuado s, por lo que utilizamos null para especificardemo=# select * from  estudiante;\nid |nombre     |direccion  |carrera     |grupo  |grado\n---+-----------+-----------+------------+-------+-------\n3  | Elizabeth | Pino 35   | Psicologia |     B |     5(1 row)\ndemo=# select * from  persona;\n id |nombre                |direccion\n----+----------------------+------------  1 | Federico Garca Lorca | Granada 65\n  2 |      Alejandro Magno | Babilonia\n  3 |            Elizabeth | Pino 35(3 rows)\nEjemplo\nUna columna definida como \ninteger  no puede contener ca-\ndenas de caracteres.\uf8e9 FUOC \u2022 71Z799014MO 38 Bases de datos en PostgreSQL\nla ausencia de valor. Al definir una tabla podemos indicar qu\u00e9 columnas\npodr\u00e1n contener valore s nulos y cu\u00e1les no.\nEl nombre  de una persona no puede ser nulo, y es posible que la persona no tenga trabajo .\nTambi\u00e9n es posible que no tenga correo , al no especificar una restricci\u00f3n not null, se asu-\nme que la columna puede contener valores nulos.\n\u2022unique . Esta restricci\u00f3n se utiliza cuando  no queremos que los valores con-\ntenidos en una columna puedan duplicarse.\nc\u00f3nyuge  no puede contener valores duplicados, no permitiremos que dos personas tengan\nsimult\u00e1neamente el mismo c\u00f3nyuge.\n\u2022primary key . Esta restricci\u00f3n especifica la  columna o columnas que elegi-\nmos como clave primaria. Pued e haber m\u00faltiples columnas unique , pero\ns\u00f3lo debe haber una clave primaria. Lo s valores que son \u00fanicos pueden ser-\nvir para identificar una fila de la tabl a de forma un\u00edvoca, por lo que se les\ndenomina claves candidatas .\nAl definir una columna como primary key , se define impl\u00edcitamente con unique . El nss\n(n\u00famero de la seguridad social) no s\u00f3lo es \u00fan ico, sino que lo utilizamos para identificar\na las personas.\n\u2022references y foreign key . En el modelo relacional , establecemos las rela-\nciones entre entidades mediante la inclusi\u00f3n de claves for\u00e1neas en otras re-laciones. PostgreSQL y SQL ofrecen me canismos para expresar y mantener\nesta integridad refe rencial. En el siguiente ejemplo, las Mascotas  tienen\ncomo due\u00f1o a una Persona :create table  Persona (\nnombre varchar(40) not null,\ntrabajo varchar(40) null,\ncorreo varchar(20),\n);\ncreate table  Persona (\nnombre varchar(40) not null,\nconyuge varchar(40) unique,\n);\ncreate table Persona (\nnss varchar(10) primary key,\nconyuge varchar(40) unique,\n);\ncreate table Mascota(\nnombre varchar(20),\ndue\u00f1o varchar(10) references  Persona,\n);\uf8e9 FUOC \u2022 71Z799014MO 39 Bases de datos en PostgreSQL\nUna referencia por defecto es a una clave primaria, por lo que due\u00f1o  se refiere\nimpl\u00edcitamente al nss de Persona . Cuando se capturen los datos de una nueva\nmascota , PostgreSQL verificar\u00e1 que el valor de due\u00f1o  haga referencia a un nss\nque exista en Persona , en caso contrario emitir\u00e1 un  mensaje de error. En otras\npalabras, no se permite asignar a una mascota un due\u00f1o que no exista.\nTambi\u00e9n es posible especificar a qu\u00e9 co lumna de la tabla hace referencia:\no su equivalente:\nPodr\u00eda darse el caso de que la clave pr imaria de la tabla referenciada tuviera\nm\u00e1s de una columna, en ese caso, la clave for\u00e1nea tambi\u00e9n tendr\u00eda que estar\nformada por el mismo n\u00famero de columnas:\nSi no se especifica otra acci\u00f3n, por omisi\u00f3n la persona que tenga una mascota\nno puede ser eliminad a, porque la mascota se quedar\u00eda sin due\u00f1o. Para poder\neliminar una persona, antes se deben eliminar las mascot as que tenga. Este\ncomportamiento no parece ser el m\u00e1s adecuado para el caso.\nPara modificar este comportamiento di sponemos de las re glas de integridad\nreferencial del lenguaje SQ L, que PostgreSQL tambi\u00e9n soporta. En el siguiente\nejemplo se permite que al eliminar un a persona, las mascotas simplemente se\nqueden sin due\u00f1o.create table Mascota(\nnombre varchar(20),\ndue\u00f1o varchar(10) references  Persona(nss),\n);\ncreate table Mascota(\nnombre varchar(20),\ndue\u00f1o varchar(10),\nFOREIGN KEY due\u00f1o references  Persona(nss),\n);\ncreate table t1 (\n  a integer PRIMARY KEY,\n  b integer,  c integer,\n  FOREIGN KEY  (b, c) REFERENCES  other_table (c1, c2)\n);\ncreate table Mascota (\ndue\u00f1o varchar(10) references  Persona on delete set null ,\n);\uf8e9 FUOC \u2022 71Z799014MO 40 Bases de datos en PostgreSQL\nEn cl\u00e1usula on delete  se pueden especificar las siguientes acciones:\n\u2013set null . La referencia toma el valor NULL: si se elimina Persona  su Mascota\nse quedar\u00e1 sin due\u00f1o.\n\u2013set default . La referencia toma el valor por omisi\u00f3n. \n\u2013cascade . La acci\u00f3n se efect\u00faa en cascada: si se elimina Persona  autom\u00e1tica-\nmente se elimina su Mascota .\n\u2013restrict . No permite el borrado del regi stro: no se puede eliminar una Per-\nsona que tenga Mascota . \u00c9sta es la acci\u00f3n que se toma por omisi\u00f3n.\nSi se modifica la clave primaria de la tabla referenciada, se dispone de las mis-\nmas acciones que en el caso anterior, que especificaremos con la cl\u00e1usula ON\nUPDATE.\n\u2022check . Esta restricci\u00f3n realiza la evalua ci\u00f3n previa de una expresi\u00f3n l\u00f3gica\ncuando se intenta realizar una asignaci\u00f3n. Si el resultado es verdadero,acepta el valor para la columna, en caso contrari o, emitir\u00e1 un mensaje de\nerror y rechazar\u00e1 el valor.\nSe han restringido los valores que se acepta r\u00e1n en la columna de la manera siguiente.\n\u2022 Edad debe estar entre 11 y 79 a\u00f1os.\n\u2022 Ciudad no debe una cadena vac\u00eda.\n\u2022 Correo debe tener una arroba.\nCualquiera de esas restricciones puede tener nombre , de manera que se facilita\nla referencia a las restricciones espec\u00ed ficas para borrarlas , modificarlas, etc.\npues puede hacerse por nombres. Para  dar nombre a una restricci\u00f3n, utiliza-\nmos la sintaxis siguiente:\n4.4.1. Restricciones de tabla\nCuando las restricciones se indican desp u\u00e9s de las definiciones de las colum-\nnas, y pueden afectar a varias de ella s simult\u00e1neamente, se dice que son res-\ntricciones de tabla:create table  Persona (\nedad int check ( edad > 10 and edad < 80 ),\ncorreo varchar(20) check( correo ~ \u2018.+@.+\\..+\u2019 ),\nciudad varchar(30) check( ciudad <> \u201c )\n);\nconstraint  nombre_de_restricci\u00f0n  <restricci\u00f3n>Comparaci\u00f3n \nde expresiones regulares\nEl operador ~ realiza compara-\nciones de cadenas con expre-siones regulares. Las expresiones regulares son patrones de b\u00fasqueda muy flexibles desarrollados en el mundo Unix.\uf8e9 FUOC \u2022 71Z799014MO 41 Bases de datos en PostgreSQL\nEsta notaci\u00f3n permite que la restri cci\u00f3n pueda abarcar varias columnas.\nUn curso se identifica por el grupo y la  materia, y dos cursos no pueden estar\nen la misma aula el mismo d\u00eda y a la misma hora.\nAl igual que la restricci\u00f3n de columna, a las restricciones de tabla puede asig-\nn\u00e1rseles un nombre:\nLa sentencia alter table permite a\u00f1adir ( add) o quitar ( drop ) restricciones\nya definidas:create table  Persona (\nnss int,\nnombre varchar(30),\npareja varchar(30),\njefe int,\ncorreo varchar(20),\nprimary key (nss),\nunique (pareja),\nforeign key (jefe) references Persona,\ncheck (correo ~ \u2018@\u2019 )\n);\ncreate table  Curso (\nmateria varchar(30),\ngrupo char(4),\ndia int,\nhora time,\naula int,\nprimary key (materia, grupo),\nunique (dia, hora, aula)\n);\ncreate table  Persona (\nnss int,\nnombre varchar(30),\npareja varchar(30),\njefe int,\ncorreo varchar(20),\nconstraint  identificador primary key (nss),\nconstraint  monogamia unique (pareja),\nconstraint  un_jefe foreign key (jefe) references  Persona,\ncheck (correo ~ \u2018@\u2019 )\n);\nalter table Persona drop constraint  monogamia\nalter table add constraint  monogamia unique (pareja);\uf8e9 FUOC \u2022 71Z799014MO 42 Bases de datos en PostgreSQL\n4.5. Indexaci\u00f3n\nPostgreSQL crea \u00edndices para las llaves primarias de todas las tablas. Cuando se ne-\ncesite crear \u00edndices adiciona les, utilizaremos la expr esi\u00f3n del ejemplo siguiente:\n4.6. Consulta de informaci\u00f3n de bases de datos y tablas\nComo ya sabemos, el cliente psql ofrece varias alternat ivas para obtener infor-\nmaci\u00f3n sobre la estructura de nuestra base de datos. En la siguiente tabla semuestran algunos comand os de mucha utilidad.\nPara obtener la lista de tablas de la base de datos demo  hacemos lo siguiente:\nLa estructura de la tabla productos  se solicita de la siguiente manera.create index persona_nombre_indice on Persona ( nombre );\nComando Descripci\u00f3n\n\\l Lista las bases de datos\n\\d Describe las tablas de la  base de datos en uso\n\\ds Lista las secuencias\n\\di Lista los \u00edndices\n\\dv Lista las vistas\n\\dp \\z Lista los privilegios sobre las tablas\n\\da Lista las funciones de agregados\n\\df Lista las funciones\n\\g archivo Ejecuta los comandos de archivo\n\\H Cambia el modo de salida HTML\n\\! comando Ejecuta un comando del sistema operativo\ndemo=# \\d\nList of relationsName                 |Type      | Owner---------------------+----------+--------            ganancia |    table | postgres             precios |    table | postgres           productos |    table | postgres productos_clave_seq | sequence | postgres         proveedores |    table | postgres(5 rows)\ndemo=# \\d productos\nTable \u201cproductos\u201dColumn        |Type                 | Modifiers--------------+---------------------+-------------------------------------------        parte |character varying(20)|         tipo |character varying(20)|especificaci\u00f3n|character varying(20)|    psugerido |                real |        clave |integer              |not null default nextval(\u2018\u201dproductos_clave_seq\u201d\u2018::text)Primary key: productos_pkeyTriggers: RI_ConstraintTrigger_17342,RI_ConstraintTrigger_17344 \uf8e9 FUOC \u2022 71Z799014MO 43 Bases de datos en PostgreSQL\nEn el ejemplo anterior podemos observar que la columna clave  contiene dos\nmodificadores:\n\u2022 El primero especifica que no pueden asignarse valores nulos.\n\u2022 El segundo especifica el valor por om isi\u00f3n que deber\u00e1 as ignarse a la co-\nlumna.\nEn este caso, el valor ser\u00e1 autom\u00e1ticamente calculado por la funci\u00f3n nextval() ,\nque toma como argumento la secuencia*  productos_clave_seq .\nEl siguiente comando muestra las secuencias creadas en una base de datos:\nLas secuencias se crean autom\u00e1ticame nte cuando se declaran columnas de\ntipo serial.\nEn la estructura de la tabla productos encontramos tambi\u00e9n una clave pri-\nmaria. PostgreSQL generar\u00e1 siempre un \u00edndice para cada tabla utilizando la\nclave primaria. La lista de los \u00edndices de la base de datos se obtiene de la si-\nguiente forma:\nEl conjunto de comandos proporcionados por psql que hemos presentado\npermite obtener informaci\u00f3n sobre la es tructura de nuestra base de datos de\nuna manera directa y sencilla  y, tambi\u00e9n, es \u00fatil para  explorar bases de datos\nque no conozcamos.demo=# \\ds\nList of relations\nName                 |Type      | Owner---------------------+----------+--------productos_clave_seq | sequence | quiron(1 row)\ndemo=# \\di\nList of relations\nName              | Type  | Owner------------------+-------+--------productos_pkey    | index | quironproveedores_pkey  | index | quiron(2 rows)* Una secuencia es un nombre \nespecial que permite la producci\u00f3n \nde series num\u00e9ricas.\uf8e9 FUOC \u2022 71Z799014MO 44 Bases de datos en PostgreSQL\n4.7. Tipos de datos\n4.7.1. Tipos l\u00f3gicos\nPostgreSQL incorpora el tipo l\u00f3gico boolean , tambi\u00e9n llamado bool . Ocupa\nun byte de espacio de almacenamiento  y puede almacenar los valores falso y\nverdadero.\nPostgreSQL soporta los oper adores l\u00f3gicos siguientes: and, or y not.\nAunque los operadores de comparaci\u00f3n se aplican sobre pr\u00e1cticamente todos\nlos tipos de datos proporcionados por PostgreSQL, dado que su resultado es unvalor l\u00f3gico, describire mos su comportamiento en la siguiente tabla:\n4.7.2. Tipos num\u00e9ricos\nPostgreSQL dispone de los tipos enteros smallint , int y bigint  que se compor-\ntan como lo hacen los enteros en muchos lenguajes de programaci\u00f3n.\nLos n\u00fameros con punto flotante real y double  precisi\u00f3n  almacenan cantida-\ndes con decimales. Una caracter\u00edstica de los n\u00fameros de punto flotante es quepierden exactitud conforme crecen o decrecen los valores.\nAunque esta p\u00e9rdida de exactitud no su ele tener importancia en la mayor\u00eda de\nlas ocasiones, PostgreSQL incluye el tipo numeric , que permite almacenar\ncantidades muy grandes o muy peque\u00f1as sin p\u00e9rdida de informaci\u00f3n. Por su-\npuesto, esta ventaja tiene un coste, los valores de tipo numeric  ocupan un es-\npacio de almacenamiento considerab lemente grande y las operaciones se\nejecutan sobre ellos muy lentamente. Po r lo tanto, no es  aconsejable utilizar\nel tipo numeric  si no se necesita una alta pr ecisi\u00f3n o se prima la velocidad de\nprocesamiento.Valor Nombre\nFalso false, \u2018f\u2019, \u2018n\u2019, \u2018no\u2019, 0\nVerdadero true, \u2018t\u2019, \u2018y\u2019, \u2018yes\u2019, 1\nOperador Descripci\u00f3n\n>M a y o r  q u e\n<M e n o r  q u e\n<= Menor o igual que>= Mayor o igual que\n<>\n!=Distinto de\nNombre Tama\u00f1o Otros nombres Comentario\nsmallint 2 bytes int2\nint 4 bytes int4, integer\uf8e9 FUOC \u2022 71Z799014MO 45 Bases de datos en PostgreSQL\nSerial \nLa declaraci\u00f3n serial  es un caso especial, ya que no se trata de un nuevo tipo. Cuando se\nutiliza como nombre de tipo de una columna, \u00e9sta tomar\u00e1 autom\u00e1ticamente valores con-\nsecutivos en cada nuevo registro.\nEjemplo de una tabla que define la columna folio como tipo serial .\nPostgreSQL responder\u00eda esta instrucci\u00f3n con dos mensajes:\n\u2022 En el primero avisa que se ha creado una secuencia de nombre factura_folio_seq :\n\u2022 En el segundo avisa de la creaci\u00f3n de un \u00edndice \u00fanico en la tabla utilizando la columna\nfolio:\nSi se declaran varias columnas con serial  en una tabla, se crear\u00e1  una secuencia y un \u00edndice\npara cada una de ellas.\n4.7.3. Operadores num\u00e9ricos\nPostgreSQL ofrece un conjunto predefin ido de operadores num\u00e9ricos, que pre-\nsentamos en la siguiente tabla:Nombre Tama\u00f1o Otros nombres Comentario\nbigint 8 bytes int8numeric(p,e) 11 + (p/2) \u2018p\u2019 es la precisi\u00f3n, \u2018e\u2019 es la escala\nreal 4 bytes float, float4\ndouble precision 8 bytes float8\nserialNo es un tipo, es un entero\nauto-incrementable\ncreate table Factura(\nfolio serial,\ncliente varchar(30),\nmonto real\n);\nNOTICE: CREATE TABLE will create implicit sequence \u2018factura_folio_seq\u2019 for SERIAL column \u2018\nNOTICE: CREATE TABLE / UNIQUE will create implicit index \u2018factura_folio_key\u2019 for table \u2018factura\u2019\nCREATE\nS\u00edmbolo Operador\n+A d i c i \u00f3 n\n- Substracci\u00f3n\n* Multiplicaci\u00f3n\n/ Divisi\u00f3n\n%M \u00f3 d u l o\n^E x p o n e n c i a c i \u00f3 n\n|/ Ra\u00edz cuadradaEjemplo\nselect |/ 9;\nselect 43 % 5;select !! 7;select 7!;\uf8e9 FUOC \u2022 71Z799014MO 46 Bases de datos en PostgreSQL\n4.7.4. Tipos de caracteres\nLos valores de cadena en PostgreSQL  se delimitan por comillas simples.\nSe puede incluir una comilla simple dentro de una cadena con \\\u2019 o \u2018 \u2018:\nLas cadenas pueden contener caracteres  especiales utilizan do las llamadas se-\ncuencias de escape que in ician con el caracter \u2018\\\u2019:S\u00edmbolo Operador\n||/ Ra\u00edz c\u00fabica\n! Factorial\n!! Factorial como operador fijo\n@V a l o r  a b s o l u t o\n&A N D  b i n a r i o\n|O R  b i n a r i o\n#X O R  b i n a r i o~ Negaci\u00f3n binaria\n<< Corrimiento binario a la izquierda\n>> Corrimiento binario a la derecha\ndemo=# select \u2018Hola mundo\u2019;\n?column?\n------------\nHola mundo(1 row)\ndemo=# select \u2018\u00c9l dijo: \u2018\u2018Hola\u2019\u2019 \u2018;\n?column?------------------\n\u00c9l dijo: \u2018Hola\u2019\n(1 row)\n\\n nueva l\u00ednea\n\\r retorno de carro\n\\t tabulador\n\\b retroceso\n\\f cambio de p\u00e1gina\n\\r retorno de carro\n\\\\ el caracter \\Recordad\nLas comillas dobles delimitan \nidentificadores que contienen caracteres especiales.\uf8e9 FUOC \u2022 71Z799014MO 47 Bases de datos en PostgreSQL\nLas secuencias de escape se sustituy en por el car\u00e1cter correspondiente:\nPostgreSQL ofrece los tipos siguientes para cadenas de caracteres:\n4.7.5. Operadores\nEn la siguiente tabla se describen los operadores para cadenas de caracteres:\nEn la siguiente tabla se muestran algu nas funciones de uso com\u00fan sobre cade-\nnas de caracteres:\nSobre las cadenas tambi\u00e9n podemos utilizar los oper adores de comparaci\u00f3n\nque ya conocemos.\nEjemplo\nEn este caso, el resultado de la comparaci\u00f3n menor que  es VERDADERO:demo=# select \u2018Esto est\u00e1 en \\n dos renglones\u2019;\n?column?\n------------------------------Esto est\u00e1 en\ndos renglones\n(1 row)\nTipo Otros nombres Descripci\u00f3n\nchar(n) character(n) Reserva n espacios para al macenar la cadena \nvarchar(n) character var-ying(n)Utiliza los espacios nece sarios para almacenar \nuna cadena menor o igual que n\ntext Almacena cadenas de cualquier magnitud\nOperador Descripci\u00f3n\u00bfDistingue may\u00fasculas \ny min\u00fasculas?\n|| Concatenaci\u00f3n -\n~ Correspondencia a expresi\u00f3n regular S\u00ed\n~* Correspondencia a expresi\u00f3n regular No\n!~ No correspondencia a expresi\u00f3n regular S\u00ed\n!~* No correspondencia a expresi\u00f3n regular -\nFunci\u00f3n Descripci\u00f3n\nLength(cadena) Devuelve la  longitud de la cadena\nlower(cadena) Convierte la cadena a min\u00fasculas\nltrim(cadena,caracteres) Elimina de la izquierda los caracteres especificados\nsubstring(cadena from patr\u00f3n) Extrae la subcadena que cumple el patr\u00f3n especificado\ndemo=# select \u2018HOLA\u2019 < \u2018hola\u2019;\n?column?----------\nt\n(1 row)Bibliograf\u00eda\nEs recomendable consultar \nel manual para obtener la referencia completade funciones.\uf8e9 FUOC \u2022 71Z799014MO 48 Bases de datos en PostgreSQL\n4.7.6. Fechas y horas\nEn la siguiente tabla se muestran los tipos de datos referentes al tiempo que\nofrece PostgreSQL:\nExiste un tipo de dato timez  que incluye los datos del tipo time  y, adem\u00e1s, la zona ho-\nraria. Su sintaxis es la siguiente:\nhh:mm[:ss[.mmm]][am|pm][zzz]\nEl tipo de datos date almacena el d\u00eda, mes y a\u00f1o de una fecha dada y se mues-\ntra por omisi\u00f3n con el form ato siguiente: YYYY-MM-DD:\nPara cambiar el formato de presentaci\u00f3n , debemos modificar la variable de en-\ntorno datestyle : \n4.7.7. Arrays  \nEl tipo de datos array  es una de las caracter\u00edstica s especiales de PostgreSQL,\npermite el almacenamiento de m\u00e1s de un valor del mismo tipo en la misma\ncolumna.Tipo de dato Unidades Tama\u00f1o Descripci\u00f3n Precisi\u00f3n\ndate d\u00eda-mes-a\u00f1o 4 bytes Fecha D\u00eda\ntime hrs:min:seg:micro 4 bytes Hora Microsegundo\ntimestampd\u00eda-mes-a\u00f1o \nhrs:min:seg:micro8 bytes Fecha m\u00e1s hora Microsegundo\nintervalsecond, minute, hour, day, \nweek, month, year, decade, century, millennium*12 bytesIntervalo \nde tiempoMicrosegundo\ndemo=# create table  Persona ( nacimiento date );\nCREATEdemo=# insert into persona values ( \u20182004-05-22\u2019 );\nINSERT 17397 1\ndemo=# select * from persona;\nnacimiento\n------------\n2004-05-22(1 row)\ndemo=# set datestyle = \u2018german\u2019;\nSET VARIABLE\ndemo=# select * from persona;\nnacimiento------------\n22.05.2004\n(1 row)* Tambi\u00e9n admite abreviaturas.\nNombre \ndel \nformatoFormato Ejemplo\nISO A\u00f1o-mes-d\u00eda 2004-05-22\nGERMAN D\u00eda.mes.a\u00f1o 22.05.2004\nPOSTGRES d\u00eda-mes-a\u00f1o 22-05-2004SQL mes/d\u00eda/a\u00f1o 05/22/2004\nDefinici\u00f3n\nLos arrays  no cumplen la pri-\nmera forma normal de Cood, por lo que muchos los conside-ran inaceptables en el modelo relacional.\uf8e9 FUOC \u2022 71Z799014MO 49 Bases de datos en PostgreSQL\nLa columna parciales  acepta tres calificaci ones de los estudiantes.\nTambi\u00e9n es posible asig nar un solo valor del array :\nLos arrays , al igual que cualquier columna cuan do no se especifica lo contra-\nrio, aceptan valores nulos:\nLos valores del array se escriben siempre entre llaves.\nPara seleccionar un valor de un array  en una consulta se especifica entre cor-\nchetes la celda que se va a desplegar: demo=# create table Estudiante (\ndemo(# nombre varchar(30),\ndemo(# parciales int [3]\ndemo(# );\nCREATE\ndemo=# insert into Estudiante( nombre, parciales[2]) values ( \u2018Pedro\u2019 , \u2018{90}\u2019);\nINSERT 17418 1\ndemo=# select * from Estudiante ;\nnombre      | parciales\n------------+------------\nJohn Lennon |Juan        | {90,95,97}\nPedro       | {90}\n(3 rows)\ndemo=# insert into  Estudiante values ( \u2018John Lennon \u2018 );\nINSERT 17416 1\ndemo=# insert into Estudiante values ( \u2018Juan\u2019 , \u2018{90,95,97}\u2019 );\nINSERT 17417 1\ndemo=# select * from Estudiante;\nnombre        | parciales--------------+------------\nJohn Lennon   |\nJuan          | {90,95,97}(2 rows)\ndemo=# select nombre, parciales[3] from Estudiante;\nnombre        | parciales--------------+-----------\nJohn Lennon   |\nJuan          | 97\nPedro         |\n(3 rows)S\u00f3lo Juan tiene calificaci\u00f3n\nen el tercer parcial.\uf8e9 FUOC \u2022 71Z799014MO 50 Bases de datos en PostgreSQL\nEn muchos lenguajes de programaci\u00f3n, los array  se implementan con longitud\nfija, PostgreSQL permite aument ar su tama\u00f1o din\u00e1micamente: \nMediante la funci\u00f3n array_dims() po demos conocer las dimensiones de un array :\n4.7.8. BLOB\nEl tipo de datos BLOB (Binary Large OBject) permite almacenar en una colum-\nna un objeto de gran tama\u00f1o. PostgreSQL  no conoce nada sobre el tipo de in-\nformaci\u00f3n que se almacena en una co lumna BLOB, simpleme nte lo considera\ncomo una secuencia de bytes. Por este motivo, no se tienen operaciones sobre\nlos tipos BLOB, con la excepci\u00f3n del op erador de concatenaci\u00f3n, que simple-\nmente une el contenido de dos BLOB en uno.\nVeamos c\u00f3mo almacenar una fotograf\u00eda en  una tabla de personas mediante ti-\npos BLOB.\nUna primera manera de ha cerlo es importando el contenido del archivo que\ncontiene la imagen mediante la funci\u00f3n lo_import() :La columna parciales  del registro \nPablo incluye cuatro celdas y s\u00f3lo\nla \u00faltima tiene valor.\ndemo=# insert into Estudiante( nombre, parciales[4]) values ( \u2018Pablo\u2019 , \u2018{70}\u2019);\nINSERT 17419 1\ndemo=# select * from Estudiante;\nnombre        | parciales--------------+------------\nJohn Lennon   |\nJuan          | {90,95,97}\nPedro         | {90}\nPablo         | {70}(4 rows)\ndemo=# select nombre, array_dims(parciales) from Estudiante;\nnombre        | array_dims--------------+------------\nJohn Lennon   |\nJuan          | [1:3]Pedro         | [1:1]\nPablo         | [1:1]\n(4 rows)\ndemo=# select lo_import(\u2018/home/quiron/mi-foto.jpg\u2019);\nlo_import\n-----------17425\n(1 row)\uf8e9 FUOC \u2022 71Z799014MO 51 Bases de datos en PostgreSQL\nEsta funci\u00f3n devuelve como  resultado el OID del ob jeto insertado.\u00bfD\u00f3nde se\nha almacenado la fotograf\u00eda si no hemos utilizado el comando insert ? Post-\ngreSQL mantiene una tabla de nombre pg_largeobject  con el objetivo de al-\nmacenar BLOB. Podemos utilizar el OID para hacer referenciar al objeto en\nuna tabla:\nLos registros insertados en esta tabla llevan un n\u00famero entero como OID que,\nen el siguiente caso, se ha obte nido solicit\u00e1ndolo a la funci\u00f3n lo_import()  an-\nterior.\nLa inserci\u00f3n anterior pudo habe rse realizado en un solo paso:\nPara extraer el contenido de la  columna, se utiliza la funci\u00f3n lo_export()\nLa funci\u00f3n lo_unlink()  permite borrar un BLOB almacenado en pg_largeobject:demo=# create table persona (\ndemo(# nombre varchar(30),\ndemo(# direccion varchar(30),\ndemo(# fotografia oid\ndemo(# );CREATE\ndemo=# insert into  persona values ( \u2018Julio\u2019 , \u2018Cedro 54\u2019, 17425);\ndemo=# insert into persona\nvalues ( \u2018Julio\u2019 , \u2018Cedro 54\u2019, lo_import(\u2018/home/quiron/mi-foto.jpg\u2019));\ndemo=# select lo_export(17425,\u2019/tmp/mi-foto.jpg\u2019);\nlo_export-----------1(1 row)\nselect lo_unlink(17425);\uf8e9 FUOC \u2022 71Z799014MO 52 Bases de datos en PostgreSQL\nVeamos el formato qu e utiliza PostgreSQL pa ra visualizar BLOB.  \nLa fotograf\u00eda se ha dividido en tres registros, que son las p\u00e1ginas 0, 1 y 2 del\nBLOB. Los tres registros tienen el mismo loid, lo que significa que son el mismo\nobjeto. Obs\u00e9rvese tambi\u00e9n, que los byte s son desplegados como caracteres de\nla forma \u2018 \\ddd \u2019, donde ddd son tres d\u00edgitos octales.\nPara almacenar un BLOB en una tabla de forma directa; es decir, sin utilizar la\ntabla del sistema pg_largeobject  utilizamos el tipo de dato bytea : \nLa columna fotograf\u00eda es de tipo bytea , lo que permite almacenar objetos de\ngran tama\u00f1o, cerca de 1GB. Para insertar valores en estas columnas, hacemos\nlo siguiente:\nLa consulta se visualiza como sigue:Se ha recortado la salida para hacer \nm\u00e1s comprensible la tabla.\nloid  | pageno | data\n------+--------+------------------------------------------------------------------\n17425 | 0      | \\377\\330\\377\\340\\000\\020JFIF\\000\\001\\001\\001\\000H\\000H\\000\\000\\37\n17425 | 1      | \\256-}\\306\\267\\032s[\\336)\\245\\231\\370|L\\206\\275\\364\\224\\321\\237\\217425 | 2      | \\341\\226;\\015l\\232\\033f\\\\\\371\\251\\0323\\003t\\307\\207~\\035GB\\271\\17\n(3 rows) \ndemo=# create table persona (\ndemo(# nombre varchar(30),\ndemo(# direccion varchar(30),\ndemo(# fotografia bytea\ndemo(# );CREATEEn el primer caso se est\u00e1 insertando \nun BLOB de un solo byte, el car\u00e1cter \nASCII cero.\nEn el segundo caso se est\u00e1n \ninsertando 4 bytes, los tres \nprimeros est\u00e1n representados \ndirectamente por los caracteres \nimprimibles ASCII y el tercero,\nel caracter ASCII 30 octal, como \nno es imprimible, se escribe\nen notaci\u00f3n \u2018 \\\\ddd \u2019.\ndemo=# insert into persona values ( \u2018Jorge\u2019 , \u2018Cerezo 55\u2019, \u2018\\\\000\u2019);\nINSERT 17436 1demo=# insert into persona values ( \u2018Luis\u2019 , \u2018Encino 67\u2019, \u2018abc\\\\030\u2019);\nINSERT 17437 1\ndemo=# select * from persona;\nnombre  | direccion | fotografia--------+-----------+------------\nJorge   | Cerezo 55 | \\000\nLuis    | Encino 67 | abc\\030(2 rows)\uf8e9 FUOC \u2022 71Z799014MO 53 Bases de datos en PostgreSQL\nLos caracteres en notaci\u00f3n  octal se muestran con un a barra invertida y con dos\ntal como se escribieron. Es to es debido a que, en re alidad, s\u00f3lo llevan una barra\ninvertida, pero por cuestiones de dise \u00f1o PostgreSQL, las literales BLOB deben\nescribirse con doble barra invertida.\n4.8. Modificaci\u00f3n de la estructura de una tabla\nPara modificar la estructura de una tabla una vez construida, disponemos de\nla sentencia SQL alter table .\nMediante esta sentencia, podemos lleva r a cabo las operaciones siguientes:\n\u2022 Agregar una columna.\n\u2022 Eliminar una columna.\n\u2022 Fijar el valor por omisi\u00f3n de una columna.\n\u2022 Eliminar el valor por omisi\u00f3n de una columna.\n\u2022 Renombrar una columna.\n\u2022 Renombrar una tabla.demo=# alter table persona add edad int ;\nALTER\ndemo=# ALTER TABLE products DROP COLUMN description;\ndemo=# alter table persona alter edad set default 15;\nALTER\ndemo=# alter table persona alter edad drop default;\nALTER\ndemo=# alter table persona rename direccion to dir;\nALTER\ndemo=# alter table persona rename to personal;\nALTER\uf8e9 FUOC \u2022 71Z799014MO 54 Bases de datos en PostgreSQL\n5. Manipulaci\u00f3n de datos\n5.1. Consultas\nLas consultas a la base de datos se realizan con el comando select , que se im-\nplementa en PostgreSQL cumpliendo en  gran parte con el est\u00e1ndar SQL:\nAl igual que MySQL, Postgr eSQL admite la sentencia explain delante de select\npara examinar qu\u00e9 est\u00e1 ocu rriendo durante una consulta:  demo=# select parte, tipo\ndemo-# from productos\ndemo-# where psugerido > 30\ndemo-# order by parte\ndemo-# limit 5\ndemo-# offset 3;\nparte       | tipo\n------------+----------Monitor     | 1024x876\nMonitor     | 1024x876\nProcesador  | 2.4 GHzProcesador  | 1.7 GHz\nProcesador  | 3 GHz\n(5 rows)Notaci\u00f3n\nOmitiremos las referencias \ncomunes a SQL y s\u00f3lo se mostrar\u00e1n algunas de las po-sibilidades de consulta con PostgreSQL. Por lo que res-pecta a las funciones auxilia-res, se han visto algunas en el apartado de tipos dedatos y, en todo caso, se recomienda la consulta de la documentaci\u00f3n del pro-ducto para las operaciones m\u00e1s avanzadas.\nAl igual que en el m\u00f3dulo de \nMySQL, vemos que no aprovecha \nlos \u00edndices (b\u00e1sicamente porque no \ntenemos ningun o definido).\ndemo=# explain select  productos.clave, parte||\u2019 \u2018||tipo||\u2019 \u2018||especificaci\u00f3n as producto,\nproveedores.empresa , precio  from productos natural join  precios natural join proveedores;\nQUERY PLAN\n--------------------------------------------------------------------------------Hash Join  (cost=45.00..120.11 rows=1000 width=104)\nHash Cond: ((\u201couter\u201d.empresa)::text = (\u201cinner\u201d.empresa)::text)\n-> Hash Join  (cost=22.50..72.61 rows=1000 width=104)\nHash Cond: (\u201couter\u201d.clave = \u201cinner\u201d.clave)\n-> Seq Scan on precios  (cost=0.00..20.00 rows=1000 width=32)\n-> Hash (cost=20.00..20.00 rows=1000 width=76)\n-> Seq Scan on productos  (cost=0.00..20.00 rows=1000 width=76)\n-> Hash (cost=20.00..20.00 rows=1000 width=24)\n-> Seq Scan on proveedores  (cost=0.00..20.00 rows=1000 width=24)\n(9 rows)\ndemo=# \uf8e9 FUOC \u2022 71Z799014MO 55 Bases de datos en PostgreSQL\nVeamos como mejorar el rendimiento de este select :\n5.2. Actualizaciones e inserciones\nPostgreSQL cumple con el est\u00e1ndar SQL en todos los sentidos  para las senten-\ncias de actualizaci\u00f3n, in serci\u00f3n y borrado. No define  modificadores ni otros\nmecanismos para estas sentencias. \nEn determinadas cl\u00e1usulas, y para tablas heredadas, es posible limitar el borra-\ndo o la actualizaci\u00f3n a la tabla padre  (sin que se propague a los registros de las\ntablas hijas) con la cl\u00e1usula only :demo=# create index  empresa_idx on precios (empresa);\nCREATE INDEX\ndemo=# create index  clave_idx on precios (clave);\nCREATE INDEX\ndemo=# explain select  productos.clave, parte||\u2019 \u2018||tipo||\u2019 \u2018||especificaci\u00f3n as producto, \nproveedores.empresa , precio  from productos natural join  precios natural join  proveedores;\nQUERY PLAN\n-------------------------------------------------------------------------------- Hash Join  (cost=29.00..56.90 rows=20 width=104)\nHash Cond: (\u201couter\u201d.clave = \u201cinner\u201d.clave)->  Seq Scan on productos  (cost=0.00..20.00 rows=1000 width=76)->  Hash  (cost=28.95..28.95 rows=20 width=32)\n->  Hash Join  (cost=1.25..28.95 rows=20 width=32)\nHash Cond: ((\u201couter\u201d.empresa)::text = (\u201cinner\u201d.empresa)::text)->  Seq Scan on proveedores  (cost=0.00..20.00 rows=1000 width=24)->  Hash  (cost=1.20..1.20 rows=20 width=32)\n->  Seq Scan on precios  (cost=0.00..1.20 rows=20 width=32)\n(9 rows)demo=# \ndemo=# update only  persona set nombre=\u2018Sr. \u2018||nombre;\nUPDATE 2\ndemo=# select * from persona;\nnombre                     | direccion---------------------------+-------------\n Sr. Alejandro Magno       | Babilonia\n Sr. Federico Garc\u00eda Lorca | Granada 65 Juan                      | Treboles 21\n(3 rows)\ndemo=# \uf8e9 FUOC \u2022 71Z799014MO 56 Bases de datos en PostgreSQL\n5.3. Transacciones\nDefinimos transacci\u00f3n  como un conjunto de operaciones que tienen significa-\ndo solamente al actuar juntas.\nPostgreSQL ofrece soporte a transaccio nes, garantizando que ambas operacio-\nnes se realicen o que no se realice ningun a. Para iniciar una transacci\u00f3n, se uti-\nliza el comando begin  y para finalizarla, commit .\nInsertamos un registro con el precio de l proveedor Patito pa ra el producto con\nclave 13.\nAl cerrar la transacci\u00f3n, los registros inse rtados ya son visibles para todos los\nusuarios. Si por alguna raz\u00f3n, por ejemplo una ca\u00edda del sistema, no se ejecuta\nel commit , la transacci\u00f3n se cancela. La forma expl\u00edcita de cancelar una tran-\nsacci\u00f3n es con el comando rollback .demo=# begin;\nBEGIN\ndemo=# insert into productos values (\u2018RAM\u2019,\u2019512MB\u2019,\u2019333 MHz\u2019,60);\nINSERT 17459 1\ndemo=# select * from productos;\nparte      | tipo     | especificaci\u00f3n | psugerido | clave\n-----------+----------+----------------+-----------+-------\nProcesador | 2 Ghz    | 32 bits        |           | 1\nProcesador | 2.4 GHz  | 32 bits        | 35        | 2\nProcesador | 1.7 GHz  | 64 bits        | 205       | 3Procesador | 3 GHz    | 64 bits        | 560       | 4\nRAM        | 128MB    | 333 MHz        | 10        | 5\nRAM        | 256MB    | 400 Mhz        | 35        | 6Disco Duro | 80 GB    | 7200 rpm       | 60        | 7\nDisco Duro | 120 GB   | 7200 rpm       | 78        | 8\nDisco Duro | 200 GB   | 7200 rpm       | 110       | 9Disco Duro | 40 GB    | 4200 rpm       |           | 10\nMonitor    | 1024x876 | 75 Hz          | 80        | 11\nMonitor    | 1024x876 | 60 Hz          | 67        | 12RAM        | 512MB    | 333 MHz        | 60        | 13\n(13 rows)\ndemo=# insert into precios values (\u2018Patito\u2019,13,67);INSERT 17460 1\ndemo=# commit;Ejemplo\nUna compra puede ser una \ntransacci\u00f3n que conste dedos operaciones:\n\u2022 Insertar un registro del pago \ndel producto\n\u2022 Insertar el producto en \nel inventario.\nNo se debe insertar un produc-\nto que no se haya pagado, ni pagar un producto que no est\u00e9 en el inventario, por lo tanto, las dos operaciones forman una transacci\u00f3n.\nEl nuevo registro tiene como clave \nel 13 y, de momento, hasta que \nfinalice la transacci\u00f3n, s\u00f3lo puede \nverlo el usuario que lo ha insertado.\nLas transacciones \nde PostgreSQL\nNo hay ninguna caracter\u00edstica \nen las transacciones de Post-greSQL que lo diferencien de lo que especifica el est\u00e1n-dar. Ya hemos visto en aparta-dos anteriores que las filas implicadas en una transacci\u00f3n mantienen unas columnas ocultas con informaci\u00f3n acerca de la propia transacci\u00f3n.\uf8e9 FUOC \u2022 71Z799014MO 57 Bases de datos en PostgreSQL\n6. Funciones y disparadores\nComo algunos de los gestores de bases de datos relacional es, comerciales l\u00edde-\nres en el mercado, Postgr eSQL puede incorporar m\u00faltiples lenguajes de progra-\nmaci\u00f3n a una base de datos en partic ular. Este hecho permite, por ejemplo:\n\u2022 Almacenar procedimientos en la base de datos ( stored procedure ), que po-\ndr\u00e1n lanzarse cuando convenga.\n\u2022 Definir operadores propios.\nPostgreSQL ofrece por defe cto soporte para su propio lenguaje procedural,\nel PL/pgSQL. Para instalarlo, basta con invocar el comando createlang  des-\nde el sistema operativo, no  desde la l\u00ednea de psql.\nPostgreSQL tambi\u00e9n soporta otros lenguajes directamente, como PL/Tcl, PL/\nPerl y PL/Python.\n6.1. Primer programa\nVeamos el programa HolaMundo  en PL/pgSQL:\nLa funci\u00f3n tiene tres partes:\n\u2022 El encabezado que define el nombre de la funci\u00f3n y el tipo de retorno.\n\u2022 El cuerpo de la funci\u00f3n, que es una cadena de texto (por lo tanto, siempre\nva entre comillas dobles).\n\u2022 La especificaci\u00f3n del lenguaje utilizado.\nLa funci\u00f3n recien creada tiene las mism as caracter\u00edsticas que las integradas.$ createlang  plpgsql demo  \ndemo=# create function  HolaMundo() ret urns char\ndemo-# as \u2018 begin return \u201cHola Mundo PostgreSQL\u201d ; end; \u2018\ndemo-# language  \u2018plpgsql\u2019;\nCREATEPL/pgSQL\nPL/pgSQL ( procedual langua-\nge/postgreSQL ) es una exten-\nsi\u00f3n del SQL que permite la creaci\u00f3n de procedimientos y funciones al estilo de los len-guajes tradicionales de progra-maci\u00f3n.\nMediante este comando, se ha \ninstalado el lenguaje PL/pgSQL\nen la base de datos demo .\uf8e9 FUOC \u2022 71Z799014MO 58 Bases de datos en PostgreSQL\nPuede solicitarse mediante el comando select :\nPuede eliminarse mediante el comando drop function .\n6.2. Variables\nLas funciones pueden recibir par\u00e1metros, s\u00f3lo es necesario especificar los tipos\nde datos. PostgreSQL asig na los nombres a los par\u00e1 metros utilizando la se-\ncuencia $1, $2, $3...\nEn este ejemplo veremos todas las posibles ma neras de declarar variables en una funci\u00f3n.  \n6.3. Sentencias\nLa estructura b\u00e1sica de una funci\u00f3n es el bloque , que incluye dos partes, la de-\nclaraci\u00f3n de variables y la  secci\u00f3n de sentencias:\ndeclare\nsecci\u00f0n de variables\nbegin\nsecci\u00f0n de sentencias\nend;demo=# select HolaMundo();\nholamundo\n-----------------------Hola Mundo PostgreSQL\n(1 row)\ndemo=# drop function  HolaMundo();\nDROP\ncreate function  mi_funcion( int,char) returns int\nas \u2018\ndeclare -- declaraci\u00f3n de variables locales\nx int; -- x es de tipo entero\ny int := 10; -- y tiene valor inicial de 10\nz int not null; -- z no puede tomar valores nulos\na constant  int := 20; -- a es constante\nb alias for $1; -- El primer par\u00e1metro tiene dos nombres.\nrename $1 to c; -- Cambia de nombre el segundo par\u00e1metro\nbeginx := y + 30;\nend;\n\u2018 language  \u2018plpgsql\u2019;\nSentencia Descripci\u00f3n\ndeclare begin end Bloque\n:= Asignaci\u00f3nselect into Asignaci\u00f3n desde un select\nSentencias sql Cualquier sentencia sqlLa sentencia alias crea un nuevo \nnombre para una variable. \nLa sentencia rena me cambia el \nnombre de una variable.\uf8e9 FUOC \u2022 71Z799014MO 59 Bases de datos en PostgreSQL\nLa sentencia de asignaci\u00f3n  utiliza el operador \u2018 :=\u2018 para almacenar los resulta-\ndos de expresiones en variables. Post greSQL proporciona otra sentencia para\nhacer asignaciones, select. Esta sentenci a debe obtener como resultado un solo\nvalor para que pueda ser al macenado en la variable: \nLa ejecuci\u00f3n de comandos sql como create , drop , insert  o update  pueden ha-\ncerse sin ninguna sintaxis especi al. La excepci\u00f3n es el comando select , que re-\nquiere ejecutarse con el comando perform  a fin de que el resultado de la\nconsulta sea descartado.\nLa sentencia execute  tambi\u00e9n ejecuta un comando sql pero a partir de una ca-\ndena de texto. Esta sentencia comporta el problema de que su sintaxis no se\nverifica hasta la ejecuci\u00f3n. Se puede ut ilizar, por ejemplo, para procesar par\u00e1-\nmetros como comandos sql:\nEl comando exit termina la ejecuci\u00f3n de un bloque. Se utiliza principalmente\npara romper ciclos.\nLa bifurcaci\u00f3n, o ejecuci\u00f3 n condicional, se realiz a mediante la sentencia if:Sentencia Descripci\u00f3n\nperform Realiza una llamada a comando sqlexecute Interpreta una cadena como comando sql\nexit Termina la ejecuci\u00f3n de un bloque\nreturn Termina la ejecuci\u00f3n de una funci\u00f3nif Ejecuta sentencias condicionalmente\nloop Repite la ejecuci\u00f3n de un conjunto de sentencias\nwhile Repite un conjunto de sentencias mientrasfor Repite un conjunto de sentencias  utilizando una variable de control\nraise Despliega un mensaje de error a advertencia\nselect into x psugerido from productos where clave = 3;\nperform select  psugerido from productos;\nexecute $1\nif ( $1 > 0 ) then\nresultado := \u2018Positivo\u2019;\nelse\nresultado := \u2018Negativo\u2019;end if;\uf8e9 FUOC \u2022 71Z799014MO 60 Bases de datos en PostgreSQL\nTambi\u00e9n puede utilizarse if con m\u00e1s de dos ramas:\nCon referencia a los bucles, PL /pgSQL ofrece tres opciones:\n\u2022E l  b u c l e  loop  es infinito, por lo que tiene una estructura muy simple. Por\nlo general se utiliza con alguna sentencia if para terminarlo:\ncont := 0;\nloopif ( cont = 10 ) then\nexit;\nend if;\n-- alguna acci\u00f3n\ncont := cont + 1;\nend loop;\n\u2022E l  b u c l e  while  incluye la condici\u00f3n al inicio del mismo, por lo que el con-\ntrol de su terminaci\u00f3n es m\u00e1s claro:\ncont := 0;\nwhile cont != 10 loop\n-- alguna acci\u00f3n\ncont := cont + 1;\nend loop;\n\u2022E l  b u c l e  for permite realizar un n\u00famero de  iteraciones controladas por la\nvariable del ciclo:\nfor cont in 1 .. 10 loop\n-- alguna acci\u00f3n\nend loop;\nLa sentencia raise  permite enviar mensajes de  tres niveles de severidad:\n\u2022debug . El mensaje se escribe en la bit\u00e1cora del sistema (logs).\n\u2022notice . El mensaje se escribe en la bit\u00e1cora y en el cliente psql.\n\u2022exception  . El mensaje se escribe en la bit\u00e1cora y aborta la transacci\u00f3n.if ( $1 > 0 ) then\nresultado := \u2018Positivo\u2019;\nelsif ( $1 < 0 ) then\nresultado := \u2018Negativo\u2019;else\nresultado := \u2018Cero\u2019;\nend if;\uf8e9 FUOC \u2022 71Z799014MO 61 Bases de datos en PostgreSQL\nEl mensaje puede incluir valores de va riables mediante el car\u00e1cter \u2018 %\u2019:\n\u2022raise debug  \u2018funcion(): ejecutada con \u00e9xito;\n\u2022raise notice  \u2018El valor % se tomo por omisi\u00f3n\u2019, variable;\n\u2022raise excepci\u00f3n  \u2018El valor % est\u00e1 fuera del rango permitido\u2019, variable;\n6.4. Disparadores\nLas funciones deben llamarse expl\u00edcitamente para su ejecuci\u00f3n o para incluir-\nlas en consultas. Sin embargo, se pued e definir que algunas funciones se eje-\ncuten autom\u00e1ticamente cuando cierto even to tenga lugar en cierta tabla. Estas\nfunciones se conocen como disparadores o triggers  y se ejecutan mediante los\ncomandos insert , delete  y uptade .\nAgregamos la tabla historial  que almacena los productos de scontinuados cuando se eli-\nminan de la tabla productos .\nPara poder utilizar una funci\u00f3n como di sparador, no debe recibir argumentos\ny debe retornar el tipo especial trigger : \nLa funci\u00f3n est\u00e1 lista para  ser utilizada como disparad or, s\u00f3lo es necesario de-\nfinirlo y asociarlo a la tabla y al evento deseado:create table historial(\nfecha date,\nparte varchar(20),\ntipo varchar(20),\nespecificacion varchar(20),\nprecio float(6)\n);\ncreate function  respaldar_borrados() returns trigger as \u2018\nbegin\ninsert into historial values (\nnow(),\nold.parte,\nold.tipo,\nold.especificacion,\nold.psugerido\n);return null;\nend;\ncreate trigger  archivar\nbeofre delete\non productosfor each row execute procedure  respaldar_borrados();La variable old est\u00e1 predefinida por \nPostgreSQL y se refiere al registro \ncon sus antiguos valores. Para \nreferirse a los nuevos valores, \nse dispone de la variable new.\uf8e9 FUOC \u2022 71Z799014MO 62 Bases de datos en PostgreSQL\nAcabamos de crear un disparador de nombre archivar  que se activar\u00e1 cuando\nse ejecute el comando delete  en la tabla productos . El usuario no necesita saber\nque se debe hacer una copia de seguridad de los registros borrados, se hace au-\ntom\u00e1ticamente.\nAl crear el disparador, hemos especifica do \u201cbefore delete\u201d al indicar la opera-\nci\u00f3n. PostgreSQL nos permite lanzar  el disparador antes o despu\u00e9s ( before, after )\nque se efect\u00faen las operaciones. Este mati z es importante, ya que, si este mismo\ndisparador lo ejecutamos despu\u00e9s de la  operaci\u00f3n, no veremos ninguna fila en\nla tabla. Es posible defi nir el mismo disparador para varias operaciones:\ncreate trigger  archivar\nbeofre delete or updateon productos\nfor each row execute procedure  respaldar_borrados();\uf8e9 FUOC \u2022 71Z799014MO 63 Bases de datos en PostgreSQL\n7. Administraci\u00f3n de PostgreSQL\nEn las tareas administrativas como la inst alaci\u00f3n, la gesti\u00f3n de usuarios, las co-\npias de seguridad, restauraciones y el uso de prestaciones internas avanzadas,\nes donde realmente se aprecian las diferencias entre gestores de bases de datos.PostgreSQL tiene fama de ser m\u00e1s comp lejo de administrar que sus competi-\ndores de c\u00f3digo abierto, lo que se debe, sobre todo, a que ofrece m\u00e1s prestacio-\nnes (o m\u00e1s complejas).\nEl contenido de los siguientes aparta dos contempla las opciones de uso co-\nm\u00fan para la administraci\u00f3n de un serv idor PostgreSQL. Existen tantas al-\nternativas que no es posible incluirlas  todas en este m\u00f3dulo, por lo que s\u00f3lo\nse presentar\u00e1n algunos temas de import ancia para el administrador, desde\nuna perspectiva general, que permita obtener una visi\u00f3n global de las po-sibilidades pr\u00e1cticas de las herramientas administrativas.\n7.1. Instalaci\u00f3n\nPostgreSQL est\u00e1 disponible para la mayor\u00eda de distribuciones de GNU/Linux.\nSu instalaci\u00f3n es tan sencilla como ejec utar el instalador de paquetes corres-\npondiente.\nEn Debian, el siguiente proc edimiento instala el servid or y el cliente respecti-\nvamente:\nEn distribuciones basadas en RPM, los nombres de los paquetes son un poco\ndiferentes:\nUna vez instalado, se escribir\u00e1 un script  de inicio que permite lanzar y apagar\nel servicio PostgreSQL; de este modo, para iniciar el  servicio, deberemos ejecu-\ntar el siguiente comando:\n # apt-get install postgresql\n# apt-get install postgresql-client\n# rpm -Uvh postgresql-server# rpm -Uvh postgresql\n# /etc/init.d/postgresql startBibliograf\u00eda\nEl manual de PostgreSQL es \nla referencia principal que se debe tener siempre a mano para encontrar posibilidades y resolver dudas. En especial se recomienda leer los siguientes cap\u00edtulos:\nCap\u00edtulo III. Server \nAdministration.\nCap\u00edtulo V. Server \nProgramming.\nCap\u00edtulo VII. Internals.\nDe la misma manera, \ntambi\u00e9n son muy \u00fatiles las listas de correo que se describen en el sitio oficial www.postgresql.org.\nNotaci\u00f3n\nAdem\u00e1s del start tambi\u00e9n po-\ndremos utilizar los par\u00e1metros restart, stop, reload que per-\nmiten reiniciar, detener y re-cargar el servidor (releyendo su configuraci\u00f3n), respectiva-mente.\uf8e9 FUOC \u2022 71Z799014MO 64 Bases de datos en PostgreSQL\nSi se desea realizar una instalaci\u00f3n a partir del c\u00f3digo fuente, puede obtenerse del\nsitio oficial www.postgresql.o rg. A continuaci\u00f3n, se describe el proceso de insta-\nlaci\u00f3n de forma muy simplificada. En la pr\u00e1ctica podr\u00e1n encontrarse algunas di-ferencias; lo m\u00e1s recomendable es l eer cuidadosamente la documentaci\u00f3n\nincluida en los archivos INSTALL y READ ME. Cualquier duda no resuelta por la\ndocumentaci\u00f3n, puede consultarse en la lista de distribuci\u00f3n.\nCon este proceso se instala la versi\u00f3n 7.4. 6. El archivo se descomprime utilizando tar.\nDentro del directorio reci\u00e9n creado se ejecuta configure , que realiza una comprobaci\u00f3n de\nlas dependencias de la aplicaci\u00f3n. Antes de ejecutar configure, debemos instalar todos los\npaquetes que vamos a necesitar.\nLa compilaci\u00f3n se realiza con make y, finalmente, los binarios producidos se copian en\nel sistema en los lugares convenientes con make install.\nDespu\u00e9s de instalados los binari os, se debe cr ear el usuario postgres  (responsa-\nble de ejecutar el proceso postmaster ) y el directorio donde se almacenar\u00e1n los\narchivos de las bases de datos.\nUna vez creado el usuario postgres , \u00e9ste debe inicializar  la base de datos:\nEl postmaster ya est\u00e1 listo para ejecutarse manualmente:  \n7.1.1. Internacionalizaci\u00f3n\nPor omisi\u00f3n, PostgreSQL no est\u00e1 compila do para soportar mensajes en espa-\n\u00f1ol, por lo que es necesario compilarlo a partir de las fuentes incluyendo las# tar xzvf postgresql-7.4.6.tar.gz\n# cd postgresql-7.4.6\n# ./configure# make\n# make install\n# adduser postgres\n# cd /usr/local/pgsql# mkdir data\n# chown postgres data\n# su - postgres\n# /usr/local/pgsql/initbd -D /usr/local/pgsql/data\n# /usr/local/pgsql/postmaster -D /usr/local/pgsql/datainitdb\nEl ejecutable initdb realiza \nel procedimiento necesario para inicializar la base de datos de postgres, en este caso, en el directorio /usr/local/pgsql/data.\nBibliograf\u00eda\nEl proceso de compilaci\u00f3n tiene m\u00faltiples opcionesque se explican en la documentaci\u00f3n incluida con las fuentes.\uf8e9 FUOC \u2022 71Z799014MO 65 Bases de datos en PostgreSQL\nsiguientes opciones de configuraci\u00f3n, pa ra que tanto el servidor como el clien-\nte psql adopten la configuraci\u00f3n es tablecida por el programa setlocales y las\nvariables de entorno respectivas:\n7.2. Arquitectura de PostgreSQL\nEl siguiente gr\u00e1fico muestra de forma esquem\u00e1tica las entidades involucradas\nen el funcionamiento normal del gestor de bases de datos:\nPostgreSQL est\u00e1 basado en una arquitec tura cliente-servidor . El programa ser-\nvidor se llama postgres  y entre los muchos programas cliente tenemos, por\nejemplo, pgaccess  (un cliente gr\u00e1fico) y psql (un cliente en modo texto).\nUn proceso servidor postgres puede atender exclusivamente a un solo cliente;\nes decir, hacen falta tantos procesos servidor postgres como clientes haya. El\nproceso postmaster es el encargado de ejecutar un nuevo servidor para cada\ncliente que solicite una conexi\u00f3n.\nSe llama sitio al equipo anfitri\u00f3n ( host) que almacena un conjunto de bases de\ndatos PostgreSQL. En un sitio se ejecuta solamente un proceso postmaster y\nm\u00faltiples procesos postgres . Los clientes pueden ejecut arse en el mismo sitio o\nen equipos remotos conectados por TCP/IP.\nEs posible restringir el acceso a usuarios  o a direcciones IP modificando las opcio-\nnes del archivo pg_hba.conf, que se en cuentra en /etc/postgresql/pg_hba.conf.\nEste archivo, junto con /etc/postgresq l/postgresql.conf son particularmente\nimportantes, porque algunos de sus pa r\u00e1metros de configuraci\u00f3n por defecto# configure --enable-nls \u2013enable-locale\n\uf8e9 FUOC \u2022 71Z799014MO 66 Bases de datos en PostgreSQL\nprovocan multitud de problemas al cone ctar inicialmente y porque en ellos se\nespecifican los mecanismos de autenticaci\u00f3n que usar\u00e1 PostgreSQL para veri-\nficar las credenciales de los usuarios.\nPara habilitar la conexi\u00f3n a PostgreSQL desde clientes remotos, debemos verificar\nel par\u00e1metro tcpip_socket = true en el fichero /etc/postgresql/postgresql.conf .\nA continuaci\u00f3n, para examinar los m\u00e9to dos de autenticaci\u00f3n y las posibilida-\ndes de conexi\u00f3n de clientes ex ternos, debemos mirar el fichero /etc/postgresql/\npg_hba.conf , donde se explicita la acci\u00f3n qu e hay que emprender para cada co-\nnexi\u00f3n proveniente de cada host externo, o grupo de hosts .\n7.3. El administrador de postgres\nAl terminar la instalaci\u00f3n, en el sist ema operativo se habr\u00e1 creado el usuario\npostgres , y en PostgreSQL se habr\u00e1 creado un usuario con el mismo nombre.\n\u00c9l es el \u00fanico usuario existente en la base de datos y ser\u00e1 el \u00fanico que podr\u00e1\ncrear nuevas bases de datos y nuevos usuarios.\nNormalmente, al usuario postgres del sistema operativo no se le permitir\u00e1 el ac-\nceso desde un shell ni tendr\u00e1 contrase\u00f1a asigna da, por lo que deberemos con-\nvertirnos en el usuario root, para despu\u00e9s convertirnos en el usuario postgres  y\nrealizar tareas en su nombre:\nEl usuario postgres puede crear nuevas bases de datos utilizando  el comando\ncreatedb . En este caso, le indicamos que el  usuario propietario de la misma\nser\u00e1 el usuario postgres:  \nEl usuario postgres puede crear nuevos usuarios utilizando el comando\ncreateuser : yo@localhost:~$ su\nPassword:\n# su - postgrespostgres@localhost:~$\npostgres@localhost:~$ createdb  demo \u2013-owner=postgres\ncreate database\nSe ha creado el usuario yo con \npermisos para crear bases de datos \ny sin permisos para crear usuarios.\npostgres@localhost:~$ createuser  yo\nShall the new user be allowed to create databases? (y/n) y\nShall the new user be allowed to create more new users? (y/n) nCREATE USER\uf8e9 FUOC \u2022 71Z799014MO 67 Bases de datos en PostgreSQL\nLos siguientes comandos eliminan bases de datos y usuarios, respectivamente:\nEs recomendable que se agreguen los usua rios necesarios para  operar la insta-\nlaci\u00f3n de PostgreSQL, y recurrir, as \u00ed, lo menos posible al ingreso con postgres.\nTambi\u00e9n disponemos de sentencias SQL para la creaci\u00f3n de usuarios, grupos\ny privilegios:\nLos grupos permiten asignar privilegios a varios usuarios y su  gesti\u00f3n es sencilla:\nPara a\u00f1adir o quitar usuarios de un grupo, debemos usar:\n7.3.1. Privilegios\nCuando se crea un objeto en PostgreSQL, se le asigna un due\u00f1o. Por defecto,\nser\u00e1 el mismo usuario que lo ha creado . Para cambiar el due\u00f1o de una tabla,\n\u00edndice, secuencia, etc., debemos usar el comando alter table . El due\u00f1o del ob-\njeto es el \u00fanico que puede hacer camb ios sobre \u00e9l, si queremos cambiar este\ncomportamiento, deberemos asignar privilegios a otros usuarios.\nLos privilegios se asignan y eliminan mediante las sentencias grant  y revoke .\nPostgreSQL define los siguientes tipos de operaciones sobre las que podemos dar\nprivilegios:\nselect, insert, update, delete , rule, references, trigger,  create, temporary, execu-\nte, usage, y all privileges.postgres@localhost:~$ dropdb demo\npostgres@localhost:~$ dropuser  yo\ndemo=# create user  marc password  \u2018marc21\u2019;\nCREATE USER\ndemo=# alter user  marc password  \u2018marc22\u2019;\nALTER USERdemo=# drop user marc;\nDROP USER\ncreate group  migrupo;\nalter group  migrupo add user  marc, ... ;\nalter group  migrupo drop user  marc, ... ;\uf8e9 FUOC \u2022 71Z799014MO 68 Bases de datos en PostgreSQL\nPresentamos algunas sentencias de trabajo con pr ivilegios, que siguen al pie de la letra el\nest\u00e1ndar SQL:\n7.4. Creaci\u00f3n de tipos de datos\nEntre las m\u00faltiples opciones para exte nder PostgreSQL, no s queda a\u00fan por ver\nla creaci\u00f3n de tipos o dominios (seg\u00fan la nomenclatura del est\u00e1ndar SQL).PostgreSQL prev\u00e9 dos tipos de datos definidos por el administrador:\n\u2022 Un tipo de datos compuesto, para utilizar como tipo de retorno en las fun-\nciones definidas por el usuario.\n\u2022 Un tipo de datos simple, para utilizar  en las definicion es de columnas de\nlas tablas. \nA modo de ejemplo, veamos un tipo compuesto y la funci\u00f3n que lo devuelve:\nPara el tipo de datos simple, la definici \u00f3n es m\u00e1s compleja, pues se debe indi-\ncar a PostgreSQL funciones que tratan co n este tipo que le permitir\u00e1n usarlo\nen operaciones, asignaciones, etc.\nA modo de ejemplo, vamos a crear el tipo \u201cnumero complejo\u201d, tal como lo\nhace la documentaci\u00f3n de PostgreSQL. En primer luga r, debemos definir la es-\ntructura donde alma cenaremos el tipo:\nDespu\u00e9s, las funciones que lo recibir\u00e1n o devolver\u00e1n:grant all  privileges  on proveedores to marc;\ngrant select  on precios to manuel;\ngrant update  on precios to group migrupo;\nrevoke all privileges  on precios to manuel;\ngrant select on  ganacias from public;\ncreate type  comptipo as (f1 int, f2 text);\ncreate function  gettipo() returns setof comptipo as\n  \u2018select id, nombre from clientes\u2019 language sql ;\ntypedef struct  Complex {\ndouble x;\ndouble y;\n} Complex;Tratar con el tipo de datos \nsimple\nHabitualmente, las funciones \nque tratar\u00e1n co n este tipo \nde datos se escribir\u00e1n en C. \uf8e9 FUOC \u2022 71Z799014MO 69 Bases de datos en PostgreSQL\nAhora estamos en condiciones de de finir las funciones, y el tipo:  PG_FUNCTION_INFO_V1(complex_in);\nDatum\ncomplex_in(PG_FUNCTION_ARGS)\n{\nchar *str = PG_GETARG_CSTRING(0);\ndouble x,\ny;\nComplex *result;\nif (sscanf(str, \u201c ( %lf , %lf )\u201d, &x, &y) != 2)\nereport(ERROR,\n(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),errmsg(\u201cinvalid input syntax for complex: \\\u201d%s\\\u201d\u201c, str)));\nresult = (Complex *) palloc(sizeof(Complex));\nresult->x = x;\nresult->y = y;PG_RETURN_POINTER(result);\n}\n PG_FUNCTION_INFO_V1(complex_out);\nDatum\ncomplex_out(PG_FUNCTION_ARGS)\n{\nComplex *complex = (Complex *) PG_GETARG_POINTER(0);\nchar *result;\nresult = (char *) palloc(100);\nsnprintf(result, 100, \u201c(%g,%g)\u201d, complex->x, complex->y);PG_RETURN_CSTRING(result);\n}\ncreate function  complex_in(cstring)\nreturns complex\nas \u2018filename\u2019\nlanguage  c immutable strict ;\ncreate function  complex_out(complex)\nreturns cstring\nas \u2018filename\u2019\nlanguage  c immutable strict ;\ncreate type complex (\ninternallength = 16, input = complex_in,\noutput = complex_out,\nalignment = double\n);\uf8e9 FUOC \u2022 71Z799014MO 70 Bases de datos en PostgreSQL\nEl proceso es un poco farragoso, pero compensa por la gran flexibilidad que\naporta al SGBD. A continuaci\u00f3n, podr\u00edamos crear algunos operadores para tra-\nbajar con este tipo (suma, resta, etc. ), mediante los pasos que ya conocemos.\nLa creaci\u00f3n de un dominio en PostgreSQL  consiste en un tipo (definido por el\nusuario o incluido en el SGBD), m\u00e1s un conjunto de restricciones. La sintaxis\nes la siguiente:\nEvidentemente, deber\u00edamos ha ber definido el operador complejo_mayor  que re-\ncibiera dos n\u00fameros complejos e indicara si el primero es mayor que el segundo.\n7.5. Plantilla de creaci\u00f3n de bases de datos\nPostgreSQL tiene definidas dos bases de datos de sistema, template0  y template1\n(que habremos visto en los ejemplos al listar las bases de datos del gestor), con\nun conjunto de objetos tales como los tipos de datos que soporta o los lengua-\njes de procedimie nto instalados.\nLa base de datos template0  se crea al instalar el servidor, con los objetos por\ndefecto del mismo, y la base de datos template1  se crea a continuaci\u00f3n de la\nanterior con algunos objetos m\u00e1s particulares del entorno o sistema operativo\ndonde se ha instalado Post greSQL. Esto hace que se a muy recomendable here-\ndar siempre de template1  (que es el comportamiento por defecto).\nEstas bases de datos se utilizan como \u201cpadres\u201d del resto de bases de datos que\nse crean, de modo que, al crear una nu eva base de datos, se copian todos los\nobjetos de template1 . \nVentajas de esta situaci\u00f3n\nSi queremos a\u00f1adir al g\u00fan objeto (una tabla, un tipo de datos, etc.) a todas las bases de\ndatos, s\u00f3lo tenemos que a\u00f1adirlo a template1 , y el resto de bases de datos que se hayan\ncreado a partir de \u00e9sta lo tendr\u00e1n disponible.\nSi se instala un lenguaje sobre la base de datos template1, autom\u00e1ticamente todas las bases\nde datos tambi\u00e9n usar\u00e1n el lenguaje. En las distribuciones de Linux es frecuente que se\nhaya realizado de este modo, por lo que no hay necesidad de instalarlo.\nPor supuesto, podemos escoge r otra plantilla para crea r bases de datos, especi-\nfic\u00e1ndola en la sentencia:create domain  country_code char(2) not null ;\ncreate domain  complejo_positivo complex not null check\n(complejo_mayor(value,(0,0)))\ncreate database  nuevbd template  plantillabdSe ha creado un dominio basado\nen un tipo definido por el sistema \ndonde la \u00fanica restricci\u00f3n\nes su longitud.\uf8e9 FUOC \u2022 71Z799014MO 71 Bases de datos en PostgreSQL\n7.6. Copias de seguridad\nHacer peri\u00f3dicamente copias de seguridad de la base de datos es una de las ta-\nreas principales del administrador de cualquier base de datos. En PostgreSQL,\nestas copias de seguridad se pueden hacer de dos maneras distintas:\n\u2022 Volcando a fichero las sentencias SQL necesarias para recrear las bases de\ndatos.\n\u2022 Haciendo copia a nivel de fichero de la base de datos.\nEn el primer caso, disponemos de la ut ilidad pg_dump, que realiza un volcado\nde la base de datos solicit ada de la siguiente manera:\npg_dump  es un programa cliente de la base de datos (como psql), lo que sig-\nnifica que podemos utilizar lo para hacer copias de  bases de datos remotas,\nsiempre que tengamos privilegios para ac ceder a todas sus tablas. En la pr\u00e1cti-\nca, esto significa que debemos ser el usuario administrador de la base de datospara hacerlo.\nSi nuestra base de datos usa los OID para referencias entre tablas, debemos indi-\nc\u00e1rselo a pg_dump  para que los vuelque tambi\u00e9n ( pg_dump -o ) en lugar de vol-\nver a crearlos cuando inserte los datos en  el proceso de recuperaci\u00f3n. Asimismo,\nsi tenemos BLOB en alguna de nuestras tablas, tambi\u00e9n debemos indic\u00e1rselo con\nel par\u00e1metro correspondiente ( pg_dump -b ) para que los incluya en el volcado. \nPara restaurar un volcado realizado con pg_dump , podemos utilizar directa-\nmente el cliente psql: \nUna vez recuperada una base de datos de  este modo, se recomienda ejecutar la\nsentencia analyze  para que el optimizador interno de consultas de PostgreS-\nQL vuelva a calcular los \u00edndices,  la densidad de las claves, etc.\nLas facilidades del sistema operativo Unix , permiten copiar una base de datos\na otra en otro servidor de la siguiente manera:\nPara hacer la copia de seguridad a nivel de fichero, simplemente copiamos los\nficheros binarios donde PostgreSQL almacena la base de datos (especificado en$ pg_dump demo > fichero_salida.sql\n$ psql demo < fichero_salida.sql\n$ pg_dump -h host1 demo | psql -h host2 demoM\u00e1s informaci\u00f3n\nHay otras opciones interesan-\ntes que podemos consultar mediante el par\u00e1metro -h.\npg_dump\npg_dump  realiza la copia \na partir de la base de datos de sistema template0 , por lo \nque tambi\u00e9n se volcar\u00e1n los ti-pos definidos, funciones, etc. de la base de datos. Cuando recuperemos esta base de da-tos, debemos crearla a partir de template0  si hemos perso-\nnalizado template1  (y no \nde template1  como lo har\u00eda\npor defecto la sentencia create database ) para \nevitar duplicidades.\uf8e9 FUOC \u2022 71Z799014MO 72 Bases de datos en PostgreSQL\ntiempo de compilaci\u00f3n, o en paquetes binarios, suele ser /var/lib/postgres/data ),\no bien hacemos un archivo comprimido con ellos:\nEl servicio PostgreSQL debe estar parado antes de realizar la copia.\nA menudo, en bases de datos grandes, es te tipo de volcados origina ficheros\nque pueden exceder los l\u00edmites del sist ema operativo. En estos casos tendre-\nmos que utilizar t\u00e9cnicas de creaci\u00f3n de  vol\u00famenes de tama\u00f1o fijo en los co-\nmandos tar u otros con los que estemos familiarizados.\n7.7. Mantenimiento rutinario de la base de datos\nHay una serie de actividades que el admi nistrador de un sistema gestor de ba-\nses de datos debe tener presentes consta ntemente, y que deber\u00e1 realizar peri\u00f3-\ndicamente. En el caso de PostgreSQL, \u00e9stas se limitan a un mantenimiento y\nlimpieza de los identificadores internos y de las estad\u00edsticas de planificaci\u00f3n de\nlas consultas, a una reindexaci\u00f3n peri\u00f3dic a de las tablas, y al tratamiento de los\nficheros de registro.\n7.7.1. vacuum  \nEl proceso que realiza la limpieza de la  base de datos en PostgreSQL se llama\nvacuum . La necesidad de llevar a cabo procesos de vacuum  peri\u00f3dicamente se\njustifica por los siguientes motivos:\n\u2022 Recuperar el espacio de disco perdido en borrados y actualizaciones de datos.\u2022 Actualizar las estad\u00edsticas de datos utilizados por el planificador de con-\nsultas SQL.\n\u2022 Protegerse ante la p\u00e9rd ida de datos por reutilizac i\u00f3n de identificadores de\ntransacci\u00f3n.\nPara llevar a cabo un vacuum , deberemos ejecutar peri\u00f3dicamente las senten-\ncias vacuum y analyze . En caso de que haya alg\u00fan problema o acci\u00f3n adicio-\nnal a realizar, el sistema nos lo indicar\u00e1:\n $ tar -cvzf copia_bd.tar.gz /var/lib/postgres/data\ndemo=# VACUUM;\nWARNING: some databases have not been vacuumed in 1613770184 transactions\nHINT: Better vacuum them within 533713463 transactions, or you may have a wraparound failure.\uf8e9 FUOC \u2022 71Z799014MO 73 Bases de datos en PostgreSQL\n7.7.2. Reindexaci\u00f3n\nLa reindexaci\u00f3n completa de la base de datos no es una tarea muy habitual,\npero puede mejorar sustancialmente la velocidad de las consultas complejasen tablas con mucha actividad.\n7.7.3. Ficheros de registro\nEs una buena pr\u00e1ctica mantener archivos de registro de la actividad del servi-\ndor. Por lo menos, de lo s errores que origina. Dura nte el desarrollo de aplica-\nciones puede ser muy \u00fatil disponer tamb i\u00e9n de un registro de las consultas\nefectuadas, aunque en bases de datos de  mucha actividad, disminuye el rendi-\nmiento del gestor y no es de mucha utilidad.\nEn cualquier caso, es conveniente disponer de mecanismos de rotaci\u00f3n de los fi-\ncheros de registro; es decir, que cada ci erto tiempo (12 horas, un d\u00eda, una sema-\nna...), se haga una copia de estos ficheros  y se empiecen unos nuevos, lo que nos\npermitir\u00e1 mantener un hist\u00f3rico de \u00e9stos (tantos como ficheros podamos almace-nar seg\u00fan el tama\u00f1o que tengan y nuestr as limitaciones de espacio en disco). \nPostgreSQL no proporciona directamente utilidades para re alizar esta rota-\nci\u00f3n, pero en la mayor\u00eda de sistemas  Unix vienen incluidas utilidades como\nlogrotate  que realizan esta tarea a partir  de una planificaci\u00f3n temporal.VACUUM\ndemo=# VACUUM VERBOSE ANALYZE ;\nINFO: haciendo vacuum a \u201cpublic.ganancia\u201d\nINFO:  \u201cganancia\u201d:  se encontraron 0 versiones de filas eliminables y 2 no eliminables en 1 p\u00e1ginas\nDETAIL: 0 versiones muertas de filas no pueden ser eliminadas a\u00fan.\nHubo 0 punteros de \u00edtem sin uso.\n0 p\u00e1ginas est\u00e1n completamente vac\u00edas.CPU 0.00s/0.00u sec elapsed 0.00 sec.\nINFO: analizando \u201cpublic.ganancia\u201d\nINFO: \u201cganancia\u201d: 1 p\u00e1ginas, 2 filas muestreadas, se estiman 2 filas en totalVACUUM\ndemo=# reindex database demo;\uf8e9 FUOC \u2022 71Z799014MO 74 Bases de datos en PostgreSQL\n8. Cliente gr\u00e1fico: pgAdmin3\nEl m\u00e1ximo exponente de cliente gr\u00e1fico de PostgreSQL es el software\npgAdmin3 que tiene licencia \u201cArtis t License\u201d, aprobada por la FSF.\nEn pgAdmin3 podemos ver y trabajar con casi todos los objetos de la base de\ndatos, examinar sus propiedades y realizar tareas administrativas. \n\u2022A g r e g a d o s\n\u2022C a s t s\n\u2022C o l u m n a s\u2022C o n s t r a i n t s  \u2022 Conversiones\u2022 Bases de datos\u2022 Dominios\n\u2022F u n c i o n e s\n\u2022G r u p o s\u2022\u00cd n d i c e s  \u2022 Lenguajes (PLpgsql, PLpython, PLperl, etc.)\u2022 Clases de operadores\u2022 Operadores\n\u2022 Servidores PostgreSQL\n\u2022R e g l a s\u2022E s q u e m a s\u2022S e c u e n c i a s  \u2022T a b l a s\u2022 Triggers\u2022 Tipos de datos\n\u2022U s u a r i o s\n\u2022V i s t a spgAdmin3 est\u00e1 disponible \nen http://www.pgadmin.org.\n\uf8e9 FUOC \u2022 71Z799014MO 75 Bases de datos en PostgreSQL\nUna caracter\u00edstica interesante de pgAdmin3  es que, cada vez que realizamos al-\nguna modificaci\u00f3n en un objeto, escrib e la/s sentencia/s SQL correspondiente/s,\nlo que hace que, adem\u00e1s de una herramienta muy \u00fatil, sea a la vez did\u00e1ctica.\npgAdmin3 tambi\u00e9n incorpora funcionalidad es para realizar consultas, exami-\nnar su ejecuci\u00f3n (como el comando explain ) y trabajar con los datos.\nTodas estas caracter\u00edsticas hacen de pg Admin3 la \u00fanica herramienta gr\u00e1fica\nque necesitaremos para trabajar con Post greSQL, tanto desde el punto de vista\ndel usuario como del administrador. Ev identemente, las acciones que pode-\nmos realizar en cada momento vienen  condicionadas por los permisos del\nusuario con el que nos conectemos a la base de datos.\n\uf8e9 FUOC \u2022 71Z799014MO 76 Bases de datos en PostgreSQL\nResumen\nPostgreSQL implementa las caracter\u00edsticas ne cesarias para competir con cual-\nquier otra base de datos co mercial, con la ventaja de tener una licencia de libre\ndistribuci\u00f3n BSD.\nLa migraci\u00f3n de bases de datos alojadas en productos comerciales a PostgreSQL se\nfacilita gracias a que soporta ampliament e el est\u00e1ndar SQL. PostgreSQL cuenta\ncon una serie de caracter\u00edsticas atractivas  como son la herencia de tablas (cla-\nses), un rico conjunto de tipos de da tos que incluyen arreglos, BLOB, tipos\ngeom\u00e9tricos y de direcci\u00f3nes de red. PostgreSQL incluye tambi\u00e9n el procesa-\nmiento de transacciones, integridad re ferencial y procedimientos almacenados.\nEn concreto, hay procedimientos docume ntados para migrar los procedimien-\ntos almacenados desarrollados en lenguajes propietarios de bases de datos co-merciales (PL/SQL) a PL/PGSQL.\nLa API se distribuye para varios lengua jes de programaci\u00f3n como C/C++, Perl,\nPHP, Python, TCL/Tk y ODBC.\nPor si esto fuera poco PostgreSQL es ex tensible. Es posible agregar nuevos tipos\nde datos y funciones al servidor que se  comporten como los ya incorporados.\nTambi\u00e9n es posible insertar nuevos le nguajes de programaci\u00f3n del lado del\nservidor para la creaci\u00f3n de procedim ientos almacenados. Todas estas ventajas\nhacen que muchos programadores lo elijan  para el desarrollo de aplicaciones\nen todos los niveles.\nEntre sus deficiencias principales po demos mencionar los OID. PostgreSQL\nest\u00e1 a\u00fan en evoluci\u00f3n, se espera que en futuras versiones se incluyan nuevas\ncaracter\u00edsticas y mejoras al dise\u00f1o interno del SGBD.\uf8e9 FUOC \u2022 71Z799014MO 77 Bases de datos en PostgreSQL\nBibliograf\u00eda\nDocumentaci\u00f3n de PostgreSQL de la dist ribuci\u00f3n: http://www. postgresql.org/docs/\nSilberschatz, A.; Korth, H.; Sudarshan,S.  (2002). Fundamentos de bases de datos  (4.\u00aa ed.).\nMadrid: McGraw Hill. \nWorsley, John C.; Drake, Joshua D.  (2002). Practical PostgreSQL . O\u2019Reilly.Desarrollo \nde aplicaciones \nen conexi\u00f3n \ncon bases de datos\nMarc Gibert Ginest\u00e0\uf8e9 FUOC \u2022 71Z799014MO Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\n\u00cdndice\nIntroducci\u00f3n .............................................................................................. 5\nObjetivos ..................................................................................................... 6\n1. Conexi\u00f3n y uso de bases de datos en lenguaje PHP .................... 7\n1.1. API nativa frente a API con abstracci\u00f3n ........................................... 7\n1.2. API nativa en MySQL ........................................................................ 8\n1.3. API nativa en PostgreSQL ................................................................. 121.4. Capa de abstracci\u00f3n PEAR::DB ......................................................... 17\n1.4.1. Capa de abstracci\u00f3n del motor de la base de datos .............. 191.4.2. Transacciones ........................................................................ 241.4.3. Secuencias ............................................................................. 24\n2. Conexi\u00f3n y uso de bases de  datos en lenguaje Java .................... 27\n2.1. Acceder al SGBD con JDBC ............................................................... 282.2. Sentencias preparadas ....................................................................... 312.3. Transacciones .................................................................................... 32\nResumen ...................................................................................................... 34\nBibliograf\u00eda ................................................................................................ 35\uf8e9 FUOC \u2022 71Z799014MO 5 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nIntroducci\u00f3n\nUn curso de bases de datos quedar\u00eda incompleto si \u00fanicamente vi\u00e9ramos el\nfuncionamiento y administraci\u00f3n de lo s dos gestores anteriormente comenta-\ndos. Uno de los principales objetivos de un SGBD es proporcionar un sistemade almacenamiento y consulta de datos al que se puedan conectar las aplica-ciones que desarrollemos.\nAs\u00ed pues, en este cap\u00edtulo vamos a ab ordar este tema, desde una perspectiva\ntotalmente pr\u00e1ctica, intentando expone r las bases para usar los SGBD vistos\nanteriormente desde algunos de los lenguajes de programaci\u00f3n y conectoresm\u00e1s usados. Los ejemplos proporcionados ser\u00e1n lo m\u00e1s simples posible paracentrarnos en el tema que nos ocupa y no en las particularidades del lenguaje\nde programaci\u00f3n en s\u00ed.\nEn primer lugar, veremos las herramienta s que ofrece PHP para conectarse con\nbases de datos, y proporci onaremos algunos ejemplos.\nA continuaci\u00f3n, pasaremos a examinar la  conexi\u00f3n JDBC a SGBD en general\ny a MySQL y PostgreSQL en particular , proporcionando tambi\u00e9n los ejemplos\nnecesarios. Tambi\u00e9n comentaremos alg\u00fan aspecto avanzado como el de la per-\nsistencia de la conexi\u00f3n al SGBD.\uf8e9 FUOC \u2022 71Z799014MO 6 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nObjetivos\nEl objetivo principal de esta unidad es  conocer las diferentes t\u00e9cnicas de co-\nnexi\u00f3n a bases de datos que ofrecen PHP y Java. \nM\u00e1s concretamente, los objetivos que deber\u00edais alcanzar al acabar el trabajo\ncon la presente unidad son los siguientes:  \n\u2022 Conocer las posibilidades que PHP y Ja va ofrecen para la conexi\u00f3n y uso de\nbases de datos en general, y de MySQL y PostgreSQL en particular.\n\u2022 Saber adaptar los programas desarrolla dos en estos lenguajes para que uti-\nlicen SGBD.\uf8e9 FUOC \u2022 71Z799014MO 7 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\n1. Conexi\u00f3n y uso de bases de datos en lenguaje PHP\nEl lenguaje de script  PHP se ha popularizado ex traordinariamente durante los\n\u00faltimos a\u00f1os, gracias a su sencillez y su sintaxis heredada de otros lenguajes\ncomo C, Perl o Visual Basic, que casi todos los desarrolladores ya conoc\u00edan en\nmayor o menor grado.\nSu f\u00e1cil integraci\u00f3n con los servidores web m\u00e1s populares (Apache, IIS, etc.),\nsin necesidad de recompila ciones o configuraciones complejas, ha contribui-\ndo tambi\u00e9n a que casi todos los proveedores de espacio web, desarrolladores\nde aplicaciones de software libre basada s en web, y proveedores de aplicacio-\nnes empresariales, lo us en para sus productos.\nA lo largo de su corta hist oria ha progresado signific ativamente, y la versi\u00f3n 5.0\nsupone un paso adelante en la orientaci\u00f3n a objetos, el tratamiento de excepcio-\nnes y el trabajo con XML, lo que le hace parecerse en prestaciones a los lenguajes\nm\u00e1s maduros en el \u00e1mbito empresarial.\nLa versi\u00f3n 5.0 era la m\u00e1s actualizada en el momento de confecci\u00f3n del presente material\n(finales del 2004). En este cap\u00edtulo, no obst ante, trabajaremos con la versi\u00f3n 4, ya que la\nversi\u00f3n 5.0 es muy reciente y los cambios que incorpora en cuanto a configuraci\u00f3n, mo-\ndelo de programaci\u00f3n, etc. no les ser\u00e1n fami liares a la mayor\u00eda de los estudiantes con co-\nnocimientos de PHP.\n1.1. API nativa frente a API con abstracci\u00f3n\nDesde la versi\u00f3n 2.0, PHP ha incorpor ado de forma nativa funciones para la\nconexi\u00f3n y uso de bases de datos. Al ser la rapidez una de las m\u00e1ximas de estelenguaje, y ante la ventaja de que pr oporciona mecanismos para la carga de\nlibrer\u00edas externas, se  crearon unas librer\u00edas para cada motor de base de datos,\nque conten\u00edan las funciones nece sarias para trabajar con \u00e9l.\nEstas API nativas son diferentes para ca da SGBD, tanto en los nombres de las\nfunciones que se utilizan para crear una conexi\u00f3n a la base  de datos, lanzar\nuna consulta, etc., como en el tratamiento de errores, resultados, etc.\nAunque se puede argumentar que al usar  la API del SGBD concreto que utili-\ncemos, dispondremos de operadores o funcionalidades espec\u00edficas de ese mo-\ntor que una librer\u00eda est\u00e1nd ar no puede proporcionar, con el paso del tiempo\nse ha visto que la utilizaci\u00f3n de estas AP I s\u00f3lo est\u00e1 indicada (y aun as\u00ed, no es\nrecomendable) para aplicac iones que sepamos seguro que no van a cambiar elComo actualmente hay aplicaciones \nweb desarrolladas en PHP que usan la API concreta del SGBD para el que fueron pensadas, las revisaremos eneste apartado.\n\uf8e9 FUOC \u2022 71Z799014MO 8 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nSGBD con el que trabajan, ya que la re visi\u00f3n del c\u00f3digo PHP, cuando hay un\ncambio de SGBD, es muy co stosa y proclive a errores.\n1.2. API nativa en MySQL\nPara trabajar con la API nativa de MySQL en PHP, deberemos haber compilado\nel int\u00e9rprete con soporte para este SG BD, o bien disponer ya del binario de\nPHP precompilado con el soporte incorporado. \nEn el caso de tenerlo que compilar, \u00fanicamente deberemos indicar como op-\nci\u00f3n --with-mysql . Posteriormente, o en el caso de que ya dispongamos del\nbinario, podemos validar que el soport e para MySQL est\u00e1 incluido correcta-\nmente en el int\u00e9rprete con la ejecuci\u00f3n del siguiente comando:\nA partir de aqu\u00ed, PHP proporciona unos par\u00e1metros de configuraci\u00f3n que nos\npermitir\u00e1n controlar algu nos aspectos del funciona miento de las conexiones\ncon el SGBD, y las propias funciones de trabajo con la base de datos.\nEn cuanto a los par\u00e1metros, deber\u00e1n situarse en el fichero php.ini , o bien\nconfigurarse para nuestra aplicaci\u00f3n en concreto desd e el servidor web. Desta-\ncan los siguientes:\nmysql.allow_persistent : indica si vamos a permit ir conexiones persisten-\ntes a MySQL. Los valores posibles son true  o false .\nmysql.max_persistent : n\u00famero m\u00e1ximo de conexiones persistentes per-\nmitidas por proceso.\nmysql.max_links : n\u00famero m\u00e1ximo de conexion es permitidas  por proceso,\nincluyendo las persistentes.\nmysql.connect_timeout : tiempo que ha de transcurrir, en segundos, antes\nde que PHP abandone el intento de conexi\u00f3n al servidor.\nLas conexiones persistentes son conexiones a la base de datos que se mantienen abiertas\npara evitar el tiempo de latencia que se pier de en conectar y desconectar. El int\u00e9rprete,\nal ejecutar la sentencia de co nexi\u00f3n a la base de datos, examina si hay alguna otra co-\nnexi\u00f3n abierta sin usar, y devuelve \u00e9sta en lugar de abrir una nueva. Lo mismo sucede al\ndesconectar, el int\u00e9rprete pued e realizar la desconexi\u00f3n si hay suficientes conexiones a\u00fan\nabiertas, o bien mantener la conexi\u00f3n abierta para futuras consultas.$ php -i | grep MySQL\nsupported databases => MySQL\nMySQL Support => enabled$\uf8e9 FUOC \u2022 71Z799014MO 9 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nPor lo que respecta a la utilizaci\u00f3n de la API para la conexi\u00f3n y consulta de\nbases de datos, empezaremos con un ejemplo:\nEn las cinco primeras l\u00edneas se establece la conexi\u00f3n y se selecciona la base de\ndatos con que se va a trabajar. El c\u00f3digo es  bastante expl\u00edcito y la mayor\u00eda de erro-\nres al respecto suelen deberse a una mala configuraci\u00f3n de los permisos del usua-rio sobre la base de datos con la que debe trabajar.\nConviene estar muy atento, sobre todo a las direcciones de origen de la co-\nnexi\u00f3n, ya que, aunque podemos usar localhost  como nombre de equipo,\nsi el int\u00e9rprete y el SGBD est\u00e1n en el mismo servidor, suele ocurrir que PHPresuelve localhost  al nombre real del equipo e intenta conectarse con esta\nidentificaci\u00f3n. As\u00ed pues, debemos exam inar cuidadosamente  los archivos de\nregistro de MySQL y los usuarios y priv ilegios del mismo si falla la conexi\u00f3n.1 <?php\n2 // Conectando y eligiendo la base de datos con que vamos a trabajar3 $link = mysql_connect(\u2018host_mysql\u2019, \u2018usuario_mysql\u2019, \u2018password_mysql\u2019) or die(\u2018No puedo conectarme: \u2018 . mysql_error());4 echo \u2018Conexi\u00f3n establecida\u2019;\n5 mysql_select_db(\u2018mi_database\u2019,$link) or die(\u2018No he podido acceder a la base de\ndatos\u2019);6 7 // Realizando una consulta SQL8 $query = \u2018SELECT * FROM mi_tabla\u2019;9 $result = mysql_query($query,$link) or die(\u2018Consulta err\u00f3nea: \u2018 . mysql_error());\n10\n11 // Mostramos los resultados en HTML12 echo \u201c<table>\\n\u201d;13 while ($line = mysql_fetch_array($result, MYSQL_ASSOC)) {14 echo \u201c\\t<tr>\\n\u201d;15 foreach ($line as $col_value) {\n16 echo \u201c\\t\\t<td>$col_value</td>\\n\u201d;\n17 }18 echo \u201c\\t</tr>\\n\u201d;19 }20 echo \u201c</table>\\n\u201d;2122 // Liberamos el resultset\n23 mysql_free_result($result);\n2425 // Cerramos la conexi\u00f3n26 mysql_close($link);27 ?> \uf8e9 FUOC \u2022 71Z799014MO 10 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nPara establecer una conexi\u00f3n persis tente, debemos ut ilizar la funci\u00f3n\nmysql_pconnect()  con los mismos par\u00e1metros.\nA continuaci\u00f3n, se utiliza la funci\u00f3n mysql_query()  para lanzar la consulta\na la base de datos.\nLa funci\u00f3n mysql_error()  es universal, y devuelve el \u00faltimo error ocurrido\nen el SGBD con nuestra co nexi\u00f3n, o con la conexi\u00f3n $link  que le indique-\nmos como par\u00e1metro.\nLa funci\u00f3n mysql_query()  puede devolver los si guientes resultados:\n\u2022 FALSE si ha habido un error.\n\u2022 Una referencia a una estructura si la  sentencia es de consulta y ha tenido\n\u00e9xito.\n\u2022 TRUE si la sentencia es de actualiz aci\u00f3n, borrado o inserci\u00f3n y ha tenido\n\u00e9xito.\nLa funci\u00f3n mysql_affected_rows()  nos permite conocer el n\u00famero de filas\nque se han visto afectadas por sentencias  de actualizaci\u00f3n, borrado o inserci\u00f3n.\nLa funci\u00f3n mysql_num_rows()  nos permite conocer el n\u00famero de filas de-\nvuelto por sentencias de consulta.\nUna vez obtenido el recurso a partir de los resultados de la consulta, PHP pro-\nporciona multitud de  formas de iterar sobre sus resultados o de acceder a uno\nde ellos directamente. Comentamos las m\u00e1s destacadas:\n\u2022$fila =  mysql_fetch_array($recurso, <tipo_de_array>)\nEsta funci\u00f3n va iterando so bre el recurso, devolviendo una fila cada vez, hasta\nque no quedan m\u00e1s filas, y devuelve FALSE. La forma del array  devuelto de-\npender\u00e1 del par\u00e1metro <tipo_de_array>  que puede tomar estos valores:\n\u2013 MYSQL_NUM: devuelve un array  con \u00edndices num\u00e9ricos para los campos.\nEs decir, en $fila[0]  tendremos el primer campo del SELECT, en $fi-\nla[1] , el segundo, etc.\n\u2013 MYSQL_ASSOC: devuelve un array  asociativo en el que los \u00edndices son los\nnombres de campo o alias que hayamos indicado en la sentencia SQL.\n\u2013 MYSQL_BOTH: devuelve un array  con los dos m\u00e9todos de acceso.Utilidad de la sentencia \nde conexi\u00f3n\nHemos proporcionado la\nsentencia SQL a la funci\u00f3n y el enlace nos ha devuelto la sentencia de conexi\u00f3n. Esta funcionalidad es absolutamen-te necesaria si se trabaja con varias conexiones simult\u00e1nea-mente, si \u00fanicamente hay una conexi\u00f3n establecida \nen el script , este par\u00e1metro es \nopcional.\uf8e9 FUOC \u2022 71Z799014MO 11 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nRecuperando el ejemplo inicia l, entre las l\u00edneas 7 y 21:\n\u2022$objeto  = mysql_fetch_object($recurso)\nEsta funci\u00f3n va iterando  sobre los resultados, de volviendo un objeto cada\nvez, de manera que el acceso a los datos de cada campo se realiza a trav\u00e9s\nde las propiedades del obje to. Al igual que en el array  asociativo, hay que\nvigilar con los nombres de los campos  en consulta, evitando que devuelva\ncampos con el mismo nombre fruto de combinaciones de varias tablas, ya\nque s\u00f3lo podremos acceder al \u00faltimo de ellos:\nVolvemos sobre el ejemplo inicial\n\u2022$valor = mysql_result($recurso,$numero_de_fila,$numero_de_campo)  \nEsta funci\u00f3n consulta dire ctamente un valor de un campo de una fila espe-\ncificada. Puede ser \u00fatil si queremos conocer un resultado sin necesidad de\nrealizar bucles innecesarios. Eviden temente, hemos de saber exactamente\nd\u00f3nde se encuentra.\n\u2022$exito = mysql_data_seek($recurso,$fila)  \nEsta funci\u00f3n permite mover el puntero de ntro de la hoja de resultados re-\npresentada por $recurso , hasta la fila que dese emos. Puede ser \u00fatil para7 // Realizando una consulta SQL\n8 $query = \u2018SELECT * FROM mi_tabla\u2019;\n9 $result = mysql_query($query,$link) or die(\u2018Consulta err\u00f3nea: \u2018 . mysql_error());\n1011 // Mostramos los resultados en HTML\n12 echo \u201c<table>\\n\u201d;\n13 while ($line = mysql_fetch_array($result, MYSQL_BOTH)) {14 echo \u201c\\t<tr>\\n\u201d;\n15 for($i=0;$i<sizeof($line);$i++) {\n16 echo \u201c\\t\\t<td>$line[$i]</td>\\n\u201d;17 }\n18 echo \u201c<td>Nombre: $line[\u2018nombre\u2019]</td>\u201c;\n19 echo \u201c\\t</tr>\\n\u201d;20 }\n21 echo \u201c</table>\\n\u201d;\n7 // Realizando una consulta SQL\n8 $query = \u2018SELECT nombre,apellidos FROM mi_tabla\u2019;9 $result = mysql_query($query,$link) or die(\u2018Consulta err\u00f3nea: \u2018 . mysql_error());\n10\n11 // Mostramos los resultados en HTML12 echo \u201c<table>\\n\u201d;\n13 while ($object = mysql_fetch_array($result, MYSQL_BOTH)) {\n14 echo \u201c\\t<tr>\\n\u201d;15 echo \u201c<td>Nombre: \u201c . $object->nombre . \u201c</td>\u201c;\n16 echo \u201c<td>Apellidos: \u201c . $object->apellidos . \u201c</td>\u201c;\n17 echo \u201c\\t</tr>\\n\u201d;18 }\n19 echo \u201c</table>\\n\u201d;\uf8e9 FUOC \u2022 71Z799014MO 12 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\navanzar o para retroceder y volver a recorrer la hoja  de resultados sin tener\nque ejecutar la sentencia SQL de nuevo. Si la fila solicitada no existe en la\nhoja de resultados, el resultado ser\u00e1 FA LSE, al igual que si la hoja no con-\ntiene ning\u00fan resultado. Es decir, el valor de $fila  debe estar entre 0 (la pri-\nmera fila) y mysql_num_rows()-1 , excepto cuando no hay ning\u00fan\nresultado, en cuyo caso devolver\u00e1 FALSE.\nFinalmente, comentaremos las funcione s de liberaci\u00f3n y desconexi\u00f3n. En el\nprimer caso, PHP realiza un  excelente trabajo liberando recursos de memoria\ncuando la ejecuci\u00f3n en curso ya no los va  a utilizar m\u00e1s. Aun as\u00ed, si la consulta\ndevuelve una hoja de datos muy grande, puede ser conveniente liberar el re-\ncurso cuando no lo necesitemos.\nPor lo que respecta al cierre de la conexi\u00f3n, tampoco suele ser necesario, ya\nque PHP cierra todas las conexiones al fi nalizar la ejecuci\u00f3n y, adem\u00e1s, el cie-\nrre siempre est\u00e1 condiciona do a la configuraci\u00f3n de las conexiones persisten-\ntes. Tal como ya hemos comentado, si activamos las conexiones persistentes\n(o bien hemos conectado con mysql_pconnect ), esta funci\u00f3n no tiene nin-\ng\u00fan efecto y, en todo caso, ser\u00e1 PHP quien decida cu\u00e1ndo se va a cerrar cada\nconexi\u00f3n.\nYa hemos comentado que las API espec\u00ed ficas para cada motor incluyen un\nconjunto de funciones que pod\u00eda ayudar a trabajar con sus aspectos particula-\nres, a continuaci\u00f3n, enumeramos las m\u00e1s importantes:\n\u2022mysql_field_flags , mysql_field_name , mysql_field_table ,\nmysql_field_type : estas funciones recibe n como par\u00e1metro un $ re-\ncurso  y un \u00edndice de campo dentro de la consulta ejecutada y devuelven\ninformaci\u00f3n sobre el campo; en conc reto, sus restriccion es, nombre, tabla\na la que corresponden y tipo de campo. Pueden ser muy \u00fatiles para trabajar\ncon consultas gen\u00e9ricas so bre bases de datos y/o campos que no conoce-\nmos al realizar el script . \n\u2022mysql_insert_id : esta funci\u00f3n devuelve el \u00faltimo identificador obteni-\ndo de una inserci\u00f3n en un campo autoincremental.\n\u2022mysql_list_dbs , mysql_list_tables , mysql_list_fields : con dis-\ntintos par\u00e1metros, estas funciones permiten consultar datos de administra-\nci\u00f3n del motor de la base de datos.\n1.3. API nativa en PostgreSQL\nPara trabajar con la API nativa de Po stgreSQL en PHP, deberemos haber com-\npilado el int\u00e9rprete con so porte para este SGBD, o bien  disponer ya del binario\nde PHP precompilado con el soporte incorporado. Bibliograf\u00eda\nHay otras funciones m\u00e1s \nespec\u00edficas para obtener informaci\u00f3n sobre el cliente que origina la conexi\u00f3n, o sobre el propio servidor donde se est\u00e1 ejecutando. Conviene consultar la documentaci\u00f3n para obtener informaci\u00f3n sobre usos m\u00e1s avanzados de esta API.\uf8e9 FUOC \u2022 71Z799014MO 13 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nEn el caso de tenerlo que compilar, \u00fanicamente debemos indicar como opci\u00f3n\n--with-pgsql . Posteriormente, o en el caso de que ya dispongamos del bina-\nrio, podemos validar que el  soporte para PostgreSQL est\u00e1 incluido correcta-\nmente en el int\u00e9rprete con la ejecuci\u00f3n del siguiente comando:\nA partir de aqu\u00ed, PHP proporciona unos par\u00e1metros de configuraci\u00f3n que nos\npermitir\u00e1n controlar algu nos aspectos del funciona miento de las conexiones\ncon el SGBD, y las propias funciones de trabajo con la base de datos.\nEn cuanto a los par\u00e1metros, deber\u00e1n situarse en el fichero php.ini  o bien\nconfigurarse para nuestra aplicaci\u00f3n en concreto desd e el servidor web. Desta-\ncan los siguientes:\n\u2022pgsql.allow_persistent : indica si vamos a permitir el uso de conexio-\nnes persistentes. Los valores son true  o false .\n\u2022pgsql.max_persistent : n\u00famero m\u00e1ximo de conexiones persistentes\npermitidas por proceso.\n\u2022pgsql.max_links : n\u00famero m\u00e1ximo de conexiones permitidas por proce-\nso, incluyendo las persistentes.\n\u2022pgsql.auto_reset_persistent : detecta autom\u00e1ticamente conexiones\npersistentes cerra das y las elimina.\nPor lo que respecta a la utilizaci\u00f3n de la API para la conexi\u00f3n y consulta de\nbases de datos, reproduciremos el anterior ejemplo:  $ php -i | grep PostgreSQLPostgreSQLPostgreSQL Support => enabledPostgreSQL(libpq) Version => 7.4.6$\nEste par\u00e1metro disminuye \nligeramente el rendimiento\ndel sistema.\n1 <?php\n2 // Conectando y eligiendo la base de datos con que vamos a trabajar3 $link = pg_connect(\u201chost=host_pgsql port=5432 dbname=mi_database user=user_pgsqlpassword=pass_pgsql\u201d);4 $stat = pg_connection_status($link);\n5 if ($stat === 0) {\n6 echo \u2018Conexi\u00f3n establecida\u2019;\uf8e9 FUOC \u2022 71Z799014MO 14 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nEn las diez primeras l\u00edneas, establec emos la conexi\u00f3n y comprobamos que se\nha realizado correctamente.\nA diferencia de MySQL, la selecci\u00f3n de la base de datos se hace en el momento\nde la conexi\u00f3n. En cambio , la comprobaci\u00f3n de la conexi\u00f3n es un poco m\u00e1s\ncomplicada.\nPara establecer una conexi\u00f3n persis tente, debemos ut ilizar la funci\u00f3n\npg_pconnect()  con los mismos par\u00e1metros.\nA continuaci\u00f3n, se utiliza la funci\u00f3n pg_query()  para lanzar la consulta a la\nbase de datos.\nPara comprobar errores, la  API de PostgreSQL distingue entre un error de co-\nnexi\u00f3n, y errores sobre los recursos devu eltos. En el primer caso, deberemos\nusar pg_connection_status() , mientras que en el segundo podemos optar\npor pg_last_error()  o bien pg_result_error($recurso)  para obtener\nel mensaje de error que pueda haber devuelto un recurso en concreto.7 } else {\n8   die \u2018No puedo conectarme\u2019;9}1011 // Realizando una consulta SQL12 $query = \u2018SELECT * FROM mi_tabla\u2019;\n13 $result = pg_query($link,$query) or die(\u2018Consulta err\u00f3nea: \u2018 . pg_last_error());\n1415 // Mostramos los resultados en HTML16 echo \u201c<table>\\n\u201d;17 while ($line = pg_fetch_array($result, PGSQL_ASSOC)) {18 echo \u201c\\t<tr>\\n\u201d;19 foreach ($line as $col_value) {\n20 echo \u201c\\t\\t<td>$col_value</td>\\n\u201d;\n21 }22 echo \u201c\\t</tr>\\n\u201d;23 }24 echo \u201c</table>\\n\u201d;25\n26 // Liberamos el resultset\n27 pg_free_result($result);28 29 // Cerramos la conexi\u00f3n30 pg_close($link);31 ?> \nRecordad\nLa mayor\u00eda de los errores \nen este aspecto se originan por una mala configuraci\u00f3n de los permisos de los usuarios en el SGBD. Una forma de probarlo que suele ofrecer m\u00e1s informa-ci\u00f3n es intentar la conexi\u00f3n con el cliente de la base de datos desde la l\u00ednea de comandos, es-pecificando el mismo usuario, base de datos y contrase\u00f1a que estamos utilizando en el script.\nUtilidad de la sentencia \nde conexi\u00f3n\nAqu\u00ed se aplican los mismos \nconsejos que d\u00e1bamos en el apartado anterior, y las mismas consideraciones en cuanto al par\u00e1metro $link  y su opcio-\nnalidad si \u00fanicamente tenemos una conexi\u00f3n establecida con el mismo usuario y contrase\u00f1a.\uf8e9 FUOC \u2022 71Z799014MO 15 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nLa funci\u00f3n pg_query() puede devolver los si guientes resultados:\n\u2022 FALSE si ha habido un error.\n\u2022 Una referencia a una estructura si la sentencia ha tenido \u00e9xito.\nLa funci\u00f3n pg_affected_rows($recurso)  nos permite conocer el n\u00famero\nde filas que se han visto afectadas por sentencias de actua lizaci\u00f3n, borrado o\ninserci\u00f3n. Esta funci\u00f3n deber\u00e1 recibir como par\u00e1metro el recurso devuelto por\nla funci\u00f3n pg_query() .\nLa funci\u00f3n pg_num_rows($recurso)  nos permite conocer el n\u00famero de filas\ndevuelto por sentencias de consulta.\nUna vez obtenido el recurso a partir de los resultados de la consulta, PHP pro-\nporciona multitud de  formas de iterar sobre sus resultados o de acceder a uno\nde ellos directamente. Comentamos las m\u00e1s destacadas:\n\u2022$fila  = pg_fetch_array($recurso, <tipo_de_array>)  \nEsta funci\u00f3n va iterando sobre el re curso, devolviendo una fila cada vez,\nhasta que no quedan m\u00e1s filas y devuelve FALSE. La forma del array  de-\nvuelto, depender\u00e1 del par\u00e1metro <tipo_de_array>  que puede tomar\nestos valores:\n\u2022 PG_NUM: devuelve un array  con \u00edndices num\u00e9ricos para los campos. Es de-\ncir, en $fila[0]  tendremos el primer campo del SELECT, en $fila[1] ,\nel segundo, etc.\n\u2022 PG_ASSOC: devuelve un array  asociativo donde los \u00edndices son los nom-\nbres de campo o alias que hayamo s indicado en la sentencia SQL.\n\u2022 PG_BOTH: devuelve un array  con los dos m\u00e9todos de acceso.\nRecuperando el ejemplo inicial,  entre las l\u00edneas 11 y 24:\n11 // Realizando una consulta SQL\n12 $query = \u2018SELECT * FROM mi_tabla\u2019;13 $result = pg_query($query,$link) or die(\u2018Consulta err\u00f3nea: \u2018 . pg_last_error());\n14// Mostramos los resultados en HTML\n15 echo \u201c<table>\\n\u201d;16 while ($line = pg_fetch_array($result, PGSQL_BOTH)) {\n17 echo \u201c\\t<tr>\\n\u201d;\n18 for($i=0;$i<sizeof($line);$i++) {19 echo \u201c\\t\\t<td>$line[$i]</td>\\n\u201d;\n20 }\n21 echo \u201c<td>Nombre: $line[\u2018nombre\u2019]</td>\u201c;22 echo \u201c\\t</tr>\\n\u201d;\n23 }\n24 echo \u201c</table>\\n\u201d;\uf8e9 FUOC \u2022 71Z799014MO 16 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\n\u2022$objeto = pg_fetch_object($recurso)  \nEsta funci\u00f3n va iterando  sobre los resultados, de volviendo un objeto cada\nvez, de forma que el acceso a los datos de cada campo se realiza por mediode las propiedades del obje to. Al igual que en el array  asociativo, hay que\nvigilar con los nombres de los campos  en consulta, evitando que devuelva\ncampos con el mismo nombre fruto de combinaciones de varias tablas, yaque s\u00f3lo podremos acceder al \u00faltimo de ellos.\nVolvemos sobre el ejemplo inicial\nPodemos pasar a la funci\u00f3n pg_fetch_object()  un segundo par\u00e1metro\npara indicar la fila conc reta que queremos obtener:\n$resultado = pg_fetch_all($recurso)Esta funci\u00f3n devuelve toda la hoja de datos correspondiente a $recurso ;\nes decir, una array  con todas las filas y column as que forman el resultado\nde la consulta. \n\u2022$exito = pg_result_seek($recurso,$fila)  \nEsta funci\u00f3n permite mover el puntero de ntro de la hoja de resultados re-\npresentada por $recurso  hasta la fila que dese emos. Deben tomarse las\nmismas consideracione s que en la funci\u00f3n mysql_data_seek() .\nEn cuanto a la liberaci\u00f3n de recursos y la desconexi\u00f3n de la base de datos, es\ntotalmente aplicable lo ex plicado para MySQL, incluy endo los aspectos rela-\ncionados con las conexiones persistentes.\nAl igual que en MySQL, PHP tambi\u00e9n proporciona funciones espec\u00edficas para\ntrabajar con algunos aspectos particulares de PostgreSQL. Al tener \u00e9ste m\u00e1s\nfuncionalidad que se aleja de lo est\u00e1ndar debido a su soporte a objetos, estas11 // Realizando una consulta SQL\n12 $query = \u2018SELECT nombre,apellidos FROM mi_tabla\u2019;13 $result = pg_query($query,$link) or die(\u2018Consulta err\u00f3nea: \u2018 . pg_last_error());\n14 // Mostramos los resultados en HTML\n15 echo \u201c<table>\\n\u201d;16 while ($object = pg_fetch_array($result, PGSQL_BOTH)) {17 echo \u201c\\t<tr>\\n\u201d;\n18 echo \u201c<td>Nombre: \u201c . $object->nombre . \u201c</td>\u201c;\n19 echo \u201c<td>Apellidos: \u201c . $object->apellidos . \u201c</td>\u201c;20 echo \u201c\\t</tr>\\n\u201d;\n21 }\n22 echo \u201c</table>\\n\u201d;\uf8e9 FUOC \u2022 71Z799014MO 17 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nfunciones cobrar\u00e1n m\u00e1s importancia. A continuaci\u00f3n comentamos las m\u00e1s\ndestacadas:\n\u2022pg_field_name , pg_field_num , pg_field_size , pg_field_type : es-\ntas funciones proporcionan informac i\u00f3n sobre los campos que integran\nuna consulta. Sus nombres son suficiente mente expl\u00edcitos acerca de su co-\nmetido.\n\u2022pg_last_oid : esta funci\u00f3n nos devuelve el OID obtenido por la inserci\u00f3n\nde una tupla si el recurso que recibe  como par\u00e1metro es el correspondiente\na una sentencia INSERT. En caso contrario devuelve FALSE.\n\u2022pg_lo_create , pg_lo_open , pg_lo_export , pg_lo_import ,\npg_lo_read , pg_lo_write : estas funciones (entre otras) facilitan el tra-\nbajo con objetos grandes (LOB) en PostgreSQL.\nLas funciones pg_lo_import  y pg_lo_export  pueden tomar ficheros como\npar\u00e1metros, facilitando la inserci\u00f3n de objetos binarios en la base de datos.\n1.4. Capa de abstracci\u00f3n PEAR::DB\nEl PEAR (PHP extension and application repository ) se define como un marco de\ntrabajo y un sistema de distribuci\u00f3n de librer\u00edas reutilizables para PHP. Es si-\nmilar en concepto al CPAN ( comprehensive perl archive network ) del lenguaje\nPerl o al PyPI ( Python package index ) de Python.\nEl PEAR pretende proporcionar una libre r\u00eda estructurada de c\u00f3digo y librer\u00edas\nreutilizables, mantener un  sistema para proporcionar a la comunidad herra-\nmientas para compartir sus desarrollos y fo mentar un estilo de codificaci\u00f3n es-\nt\u00e1ndar en PHP.\nPEAR, debe ser el primer recurso para solventar cualquier carencia detectada\nen las funciones nativas de PHP. Como  buena pr\u00e1ctica general en el mundo\ndel software libre, siempre es  mejor usar, aprender o me jorar a partir de lo que<?php\n$database = pg_connect(\u201cdbname=jacarta\u201d);\npg_query($database, \u201cbegin\u201d);\n$oid = pg_lo_create($database);echo \u201c$oid\\n\u201d;\n$handle = pg_lo_open($database, $oid, \u201cw\u201d);\necho \u201c$handle\\n\u201d;pg_lo_write($handle, \u201clarge object data\u201d);\npg_lo_close($handle);\npg_query($database, \u201ccommit\u201d);\n?> \nNota\nHay otras funciones que \ntienen el mismo cometido \nque combinaciones de algunas \nde las funciones comentadas anteriormente (por ejemplo, pg_select  o pg_insert , \npg_copy_from ), pero que no \nse comentan en este material por su extensi\u00f3n y por su poco uso.\nPEAR\nSi nuestra instalaci\u00f3n de PHP es \nreciente, ya dispondremos de PEAR instalado (a no ser que lo hayamos compilado con la opci\u00f3n --without-pear .\uf8e9 FUOC \u2022 71Z799014MO 18 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nhan hecho otros, que proponernos reinve ntar la rueda. Adem\u00e1s, si hacemos\nmejoras a las librer\u00edas que usemos de PEAR, siempre podemos contribuir a esos\ncambios mediante las herramientas que nos proporciona.\nEn cierta forma, PEAR se comporta como un gestor de paquetes m\u00e1s de los que\npueden incorporar las distribuciones  GNU/Linux m\u00e1s recientes (como apt,\nyum o YOU). Este gestor de paquetes se  compone del ejecutable \u2018pear\u2019 al que\npodemos proporcionar un conjunto de par\u00e1metros seg\u00fan las acciones que de-\nseemos realizar:\nPEAR (y PHP) ya viene con un conjunto de paquetes instalados, lo que se de-\nnomina el PFC (PHP foundation classes ). Estos paquetes proporcionan a PHP la\nm\u00ednima funcionalidad  necesaria para que PEAR fu ncione y para que dispon-\ngamos de las librer\u00edas b\u00e1sicas de PHP.\nA continuaci\u00f3n presentamos las opciones m\u00e1s habituales de PEAR:$ pear list\nInstalled packages:\n===================Package Version StateArchive_Tar 1.2 stableConsole_Getopt 1.2 stableDB 1.6.8 stable\nhttp 1.3.3 stable\nMail 1.1.4 stableNet_SMTP 1.2.6 stableNet_Socket 1.0.5 stablePEAR 1.3.4 stablePhpDocumentor 1.3.0RC3 beta\nXML_Beautifier 1.1 stable\nXML_Parser 1.2.2 stableXML_RPC 1.1.0 stableXML_Util 1.1.1 stable\nComando Resultado\npear list Lista de los paquetes instalados.\npear list-all Lista de todos los paquet es disponibles en PEAR.\npear list-upgradesLista de los paquetes instalados con actualizaci\u00f3n \ndisponible.\npear info <paquete> Proporciona informaci\u00f3n sobre el paquete.\npear install <paquete> Descarga e instala el paquete.\npear search <texto> Busca paquetes en el repositorio PEAR.\npear upgrade <paquete> Actualiza el paquete si es necesario.\npear upgrade-allActualiza todos los paquetes instalados con \nactualizaci\u00f3n disponible.\npear uninstall <paquete> Desinstala el paquete.\uf8e9 FUOC \u2022 71Z799014MO 19 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\n1.4.1. Capa de abstracci\u00f3n del motor de la base de datos\nParece evidente que, para la inmensa mayor\u00eda de aplicaciones basadas en PHP,\nel uso de su librer\u00eda nativa de acceso a bases de datos va a condicionar el SGBDa usar con la aplicaci\u00f3n. En aplicaciones comerciales,  o que no pueden ni de-\nsean estar cerradas a un \u00fanico motor, no  ser\u00e1 imprescindible disponer de unas\nfunciones que encapsulen la comunicaci \u00f3n con el SGBD y que sean indepen-\ndientes de \u00e9ste en las interfaces que o frecen, mientras que internamente lla-\nmar\u00e1n a las funciones nativas del SGBD concreto con que se est\u00e9 trabajando\nen cada momento.\nAs\u00ed pues, y buscando en PEAR, encontra mos el m\u00f3dulo \u2018DB\u2019, una capa de abs-\ntracci\u00f3n y encapsulamiento de la comunicaci\u00f3n con el  SGBD. Al tener que in-\ncorporar todas las funcionalidades de lo s motores que soporta, el resultado ser\u00e1\nsiempre el m\u00ednimo conjunto de presta ciones comunes a todos los SGBD. Las\nprestaciones m\u00e1s destacadas que ofrece la  versi\u00f3n actual 1.6.8 son las siguientes:\n\u2022 Interfaz orientada a objetos.\n\u2022 Una sintaxis com\u00fan para identifi car SGBD y cadenas de conexi\u00f3n.\n\u2022 Emulaci\u00f3n de \u201csentencias preparadas\u201d en los motores que no las soportan.\u2022 C\u00f3digos de errores comunes.\n\u2022 Emulaci\u00f3n de secuencias o autoincrem entos en SGBD que no los soportan.\n\u2022S o p o r t e  p a r a  t r a n s a c c i o n e s .\u2022 Interfaz para obtener informaci\u00f3n del metadato (informaci\u00f3n sobre la ta-\nbla o la base de datos).\n\u2022 Compatible con PHP4 y PHP5.\u2022 Motores soportados: dbase, fbsql, in terbase, informix, msql, mssql, mysql,\nmysqli, oci8, odbc, pgsql, sqlite y sybase.\n Versiones\nLa versi\u00f3n 1.6.8. era la m\u00e1s\nactualizada en el momento de elaboraci\u00f3n de este material (finales de 2004).\n1 <?php\n2 // Incluimos la librer\u00eda una vez instalada mediante PEAR\n3 require_once \u2018DB.php\u2019;\n45 // Creamos la conexi\u00f3n a la base de datos, en este caso PostgreSQL\n6 $db =& DB::connect(\u2018pgsql://usuario:password@servidor/basededatos\u2019);\n78 // Comprobamos error en la conexi\u00f3n\n9 if (DB::isError($db)) {\n10 die($db->getMessage());11}\n12\uf8e9 FUOC \u2022 71Z799014MO 20 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nLa estructura del c\u00f3digo y hasta la sint axis de las sentencias es similar a los\nejemplos nativos vistos anteriormente, exceptuando las partes de las senten-\ncias que hac\u00edan referencia al moto r de base de datos en particular.\nA continuaci\u00f3n, vamos a avanzar por el c\u00f3digo ampliando la informaci\u00f3n so-\nbre cada paso.\nLa conexi\u00f3n se especifica mediante una sintaxis de tipo DSN ( data source na-\nme). Los DSN admiten multitud de vari antes, dependiendo del motor al que\nnos conectemos, pero en casi todos los casos, tienen la forma siguiente:\n\u2022C o n e x i \u00f3 n  a  M y S Q L\nmysql://usuario:password@servidor/basededatos\n\u2022 Conexi\u00f3n a MySQL a trav\u00e9s de un socket  UNIX: \nmysql://usuario:password@unix(/camino/al/socket)/basededatos\n\u2022 Conexi\u00f3n a PostgreSQL\npgsql://usuario:password@servidor/basededatos\n\u2022 Conexi\u00f3n a PostgreSQL en  un puerto espec\u00edfico:\npgsql://usuario:password@tcp(servidor:1234)/basededatos\nEn cualquier llamada a un m\u00e9todo de l paquete DB, \u00e9ste puede devolver el\nobjeto que le corresponde (una hoja de  resultados, un objeto representando\nla conexi\u00f3n, etc.) o bien un objeto qu e represente el error que ha tenido la\nllamada. De \u00e9sta manera, para compro bar los errores que puede originar cada\nsentencia o intento de conexi\u00f3n, bastar\u00e1 con comprobar el tipo del objeto\ndevuelto:13// Realizamos la consulta:\n14$res =& $db->query(\u2018SELECT * FROM clients\u2019);\n1516// Comprobamos que la consulta se ha realizado correctamente\n17if (DB::isError($res)) {\n18die($res->getMessage());19}\n20\n21// Iteramos sobre los resultados22while ($row =& $res->fetchRow()) {\n23 echo $row[0] . \u201c\\n\u201d;\n24}25\n26// Liberamos la hoja de resultados\n27$res->free()2829// Desconectamos de la base de datos\n30$db->disconnect();\n31?>\nmotorphp://usuario:contrase\u00f1a@servidor/basededatos?opcion=valor\uf8e9 FUOC \u2022 71Z799014MO 21 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nLa clase DB_Error  ofrece varios m\u00e9todos. A pe sar de que el m\u00e1s utilizado es\ngetMessage() , getDebugInfo()  o getCode()  pueden ampliar la informa-\nci\u00f3n sobre el error.\nPara realizar consultas, disponem os de dos mecanismos diferentes:\n\u2022 Enviar la consulta directamente al SGBD.\n\u2022 Indicar al gestor que prepare la ejec uci\u00f3n de una sentencia SQL y posterior-\nmente indicarle que la ejecute una o m\u00e1s veces.\nEn la mayor\u00eda de los casos, optaremo s por el primer mecanismo y podremos\nproceder como sigue:\nEn ocasiones nos podemos encontrar ejecutando la misma consulta varias ve-\nces, con cambios en los datos o en el va lor de las condicione s. En estos casos,\nes m\u00e1s indicado utilizar el segundo mecanismo.\nSupongamos que tenemos que insertar un conjunto de clientes en nuestra base\nde datos. Las sentencias que ejecutar\u00eda mos ser\u00edan parecidas a las siguientes:\nEn lugar de esto, podemos indicarle al motor de la base de datos que prepare\nla sentencia, del modo siguiente:\nUtilizaremos la variable $sth  que nos ha devuelto la sentencia prepare  cada\nvez que ejecutemos el query :8 // Comprobamos error en la conexi\u00f3n\n9 if (DB::isError($db)) {10 die($db->getMessage());11 }\n13 // Realizamos la consulta:\n14 $res =& $db->query(\u2018SELECT * FROM clients\u2019);\nEjemplo\nPensemos en un conjunto de \nactualizaciones o inserciones seguidas o en un conjunto de consultas donde vamos cam-biando un intervalo de fechas o el identificador del clientesobre el que se realizan.\nINSERT INTO Clientes (nombre, nif) VALUES (\u2018Jos\u00e9 Antonio Ram\u00edrez\u2019,\u201929078922Z\u2019);\nINSERT INTO Clientes (nombre, nif) VALUES (\u2018Miriam Rodr\u00edguez\u2019,\u201945725248T\u2019);...\n$sth = $db->prepare(\u2018INSERT INTO Clientes (nombre,nif) VALUES (?,?)\u2019);\n$db->execute($sth, \u2018Jos\u00e9 Antonio Ram\u00edrez\u2019,\u201929078922Z\u2019);$db->execute($sth, \u2018Miriam Rodriguez\u2019,\u201945725248T\u2019);\uf8e9 FUOC \u2022 71Z799014MO 22 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nTambi\u00e9n podemos pasar una array  con todos los valores:\nY tenemos la opci\u00f3n de pasar una array  de dos dimensiones con todas las sen-\ntencias a ejecutar, mediante el m\u00e9todo executeMultiple() :\nA continuaci\u00f3n, examinarem os los m\u00e9todos de iterar  sobre los resultados. En\nel ejemplo inicial hemo s utilizado la funci\u00f3n fetchRow()  de la manera si-\nguiente:\nPero tambi\u00e9n disponem os de la funci\u00f3n fetchInto(),  que recibe como pa-\nr\u00e1metro el array  donde queremos que se almacene el resultado:\nTanto fetchRow()  como fetchInto()  aceptan otro par\u00e1metro para indicar\nel tipo de estructura de datos que va a almacenar en $row :\n\u2022 DB_FETCHMODE_ORDERED: es la opci\u00f3n  por defecto. Almacena el resul-\ntado en una array  con \u00edndice num\u00e9rico.\n\u2022 DB_FETCHMODE_ASSOC: almacena el resultado en una array  asociativa\nen el que las claves son el nombre del campo.\n\u2022 DB_FETCHMODE_OBJECT: almacena el resultado en un objeto donde dis-\npondremos de atributos con el nombre de cada campo para obtener el valor\nen cada iteraci\u00f3n.$datos = array(\u2018Miriam Rodriguez\u2019,\u201945725248T\u2019);\n$db->execute($sth, $datos);\n$todosDatos = array(array(\u2018Jos\u00e9 Antonio Ram\u00edrez\u2019,\u201929078922Z\u2019),\narray(\u2018Miriam Rodriguez\u2019,\u201945725248T\u2019));\n$sth = $db->prepare(\u2018INSERT INTO Clientes (nombre,nif) VALUES (?, ?)\u2019);$db->executeMultiple($sth, $todosDatos);\n21 // Iteramos sobre los resultados22 while ($row =& $res->fetchRow()) {23 echo $row[0] . \u201c\\n\u201d;24 }\n21 // Iteramos sobre los resultados22 while ($res->fetchRow()) {23 echo $row[0] . \u201c\\n\u201d;24 }\uf8e9 FUOC \u2022 71Z799014MO 23 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\no bien:\nLa funci\u00f3n fetchInto() acepta un tercer par\u00e1metro para indicar el n\u00famero\nde fila que queremos obtener, en caso de que no deseemos iterar sobre la pro-\npia funci\u00f3n:\nHay otros m\u00e9todos para obtener diferent es vistas del resultado como los si-\nguientes:\n\u2022getAll() : obtiene una array  de dos dimensiones con toda la hoja de resul-\ntados. Tendr\u00eda una forma como la siguiente:21 // Iteramos sobre los resultados en modo asociativo\n22 while ($res->fetchInto (($row,DB_FETCHMODE_ASSOC)) {\n23 echo $row[\u2018nombre\u2019] . \u201c\\n\u201d;24 echo $row[\u2018nif\u2019] . \u201c\\n\u201d;\n25 }\n21 // Iteramos sobre los resultados en modo objeto\n22 while ($res->fetchInto (($row,DB_FETCHMODE_OBJECT)) {\n23 echo $row->nombre . \u201c\\n\u201d;\n24 echo $row->nif . \u201c\\n\u201d;25 }\n21 // Obtenemos la tercera fila de la consulta22 $res->fetchInto ($row,DB_FETCHMODE_ASSOC,3); {\n23 echo $row->nombre . \u201c\\n\u201d;\n24 echo $row->nif . \u201c\\n\u201d;\nArray(\n[0] => Array\n(\n[cf] => Juan\n[nf] => 5\n[df] => 1991-01-11 21:31:41\n)\n[1] => Array\n(\n[cf] => Kyu\n[nf] => 10\n[df] => 1992-02-12 22:32:42\n)\n)\uf8e9 FUOC \u2022 71Z799014MO 24 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\n\u2022getRow() : devuelve s\u00f3lo la primera fila  de la hoja de resultados.\n\u2022getCol() : devuelve s\u00f3lo la columna indica da de la hoja de resultados.\nDe la misma manera que en las librer \u00edas nativas, hay m\u00e9todos que proporcio-\nnan informaci\u00f3n sobre la consulta en s\u00ed:\n\u2022numRows() : n\u00famero de filas de la  hoja de resultados.\n\u2022numCols() : n\u00famero de columnas de la hoja de resultados.\n\u2022affectedRows() : n\u00famero de filas de la tabl a afectadas por la sentencia de\nactualizaci\u00f3n, inserci\u00f3n o borrado.\n1.4.2. Transacciones\nPEAR::DB proporciona mecanismos para tratar las transacciones independien-\ntemente del SGBD con que trabajemos.\nComo ya hemos comentado, la operativ a con las transaccion es est\u00e1 relaciona-\nda con las sentencias begin , commit  y rollback  de SQL. PEAR::DB envuelve\nestas sentencias en llamadas a m\u00e9todos suyos, del modo siguiente:\n1.4.3. Secuencias\nPEAR::DB incorpora un mecanismo propio de secuencias\n(AUTO_INCREMENT en MySQL), que es independiente de la base de datos\nutilizada y que puede ser de gran utilidad en identifica dores, claves primarias,\netc. El \u00fanico requisito es que se usen  sus m\u00e9todos de trabajo con secuencias,\nsiempre que se est\u00e9 trabajando con esa base de datos; es decir, no se debe crear\nla secuencia en el SGBD y, despu\u00e9s, tr abajar con ella con los m\u00e9todos que ofre-\nce PEAR::DB. Si la secuencia la creamos mediante la base de datos, entoncesdeberemos trabajar con ella con las fu nciones extendidas de SQL que nos pro-\nporcione ese SGBD (en PostgreSQL la funci\u00f3n nextval()  o en MySQL la in-\nserci\u00f3n del valor 0 en un campo AUTO_INCREMENT).// Desactivamos el comportamiento de COMMIT autom\u00e1tico.\n$db->autocommit(false);..\n..\nif (...) {\n$db->commit();\n} else {\n$db->rollback();\n}Atenci\u00f3n\nEn MySQL s\u00f3lo funcionar\u00e1 \nel soporte de transacciones si la base de datos est\u00e1 almace-nada con el mecanismo InnoDB.\nEn PostgreSQL no hay restric-\nci\u00f3n alguna.\nEn ning\u00fan sitio...\n... se hace un begin . Al desac-\ntivar el autocommit  (que est\u00e1 \nactivado por defecto) todas las sentencias pasar\u00e1n a formar parte de una transacci\u00f3n, que se registrar\u00e1 como definitivaen la base de datos al llamar al m\u00e9todo commit()  o bien se \ndesechar\u00e1 al llamar al m\u00e9todo rollback() , volviendo la \nbase de datos al estado en el que estaba despu\u00e9s del \u00faltimo commit() .\uf8e9 FUOC \u2022 71Z799014MO 25 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nDisponemos de las siguientes funcio nes para trabajar con secuencias:\n\u2022createSequence($nombre_de_secuencia) : crea la secuencia o devuel-\nve un objeto DB_Error en caso contrario.\n\u2022nextId($nombre_de_secuencia) : devuelve el siguiente identificador\nde la secuencia.\n\u2022dropSequence($nombre_de_secuencia) : borra la secuencia.\nFinalmente, en el aspecto relacionad o con los metadatos de las tablas,\nPEAR::DB ofrece la funci\u00f3n tableInfo(),  que proporciona informaci\u00f3n de-\ntallada sobre una tabla o sobre las column as de una hoja de resultados obteni-\nda de una consulta. \nO bien:\nEl resultado ser\u00e1 similar al siguiente:  // Creamos la secuencia:\n$tmp = $db->createSequence(\u2018miSecuencia\u2019);if (DB::isError($tmp)) {\ndie($tmp->getMessage());\n}\n// Obtenemos el siguiente identificador\n$id = $db->nextId(\u2018mySequence\u2019);if (DB::isError($id)) {\ndie($id->getMessage());\n}\n// Usamos el identificador en una sentencia\n$res =& $db->query(\u201cINSERT INTO miTabla (id, texto) VALUES ($id, \u2018Hola\u2019)\u201d);\n// Borramos la secuencia\n$tmp = $db->dropSequence(\u2018mySequence\u2019);\nif (DB::isError($tmp)) {\ndie($tmp->getMessage());\n}\n$info = $db->tableInfo(\u2018nombretabla\u2019);\nprint_r($info);\n$res =& $db->query(\u2018SELECT * FROM nombretabla\u2019);$info = $db->tableInfo($res);\nprint_r($info);\n[0] => Array (\n  [table] => nombretabla\n  [name] => nombre\uf8e9 FUOC \u2022 71Z799014MO 26 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\n[type] => string\n  [len] => 255\n  [flags] => )\n[1] => Array (\n  [table] => nombretabla  [name] => nif\n  [type] => string\n  [len] => 20  [flags] => primary key not null\n)Funcionalidades\nHay funcionalidades m\u00e1s avan-\nzadas de esta librer\u00eda que au-mentan continuamente. De todas formas, con las pre-sentadas basta para identificar las ventajas de trabajar con una capa de abstracci\u00f3n del motor de base de datos donde se al-macenan los datos de nuestra aplicaci\u00f3n.\uf8e9 FUOC \u2022 71Z799014MO 27 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\n2. Conexi\u00f3n y uso de bases de datos en lenguaje Java\nEl acceso a bases de datos desde Java se realiza mediante el est\u00e1ndar JDBC ( Java\ndata base conectivity ), que permite un acceso unif orme a las bases de datos in-\ndependientemente del SGBD. De esta ma nera, las aplicacione s escritas en Java\nno necesitan conocer las es pecificaciones de un SGBD  en particular, basta con\ncomprender el funcionamien to de JDBC. Cada SGBD que quiera utilizarse con\nJDBC debe contar con un adaptador o controlador.\nLa estructura de JDBC se puede expresar gr\u00e1ficamente como sigue:\nHay drivers  para la mayor\u00eda de SGBD, tanto de software libre como de c\u00f3digo\nabierto. Adem\u00e1s, hay drivers  para trabajar con otros tipos de datos (hojas de\nc\u00e1lculo, ficheros de texto, etc.) como si fueran SGBD sobre los que podemosrealizar consultas SQL.\nPara usar la API JDBC con un SGBD en particular, necesitaremos el driver  con-\ncreto del motor de base de datos, que me dia entre la tecnolog\u00eda JDBC y la base\nde datos. Dependiendo de  m\u00faltiples factores, el driver  puede estar escrito com-\npletamente en Java, o bien  haber usado m\u00e9todos JNI ( Java native interface ) para\ninteractuar con otros lenguajes o sistemas. \nLa \u00faltima versi\u00f3n de desarrollo de la API JDBC proporciona tambi\u00e9n un puen-\nte para conectarse a SGBD que dispongan de drivers  ODBC ( open database\n\uf8e9 FUOC \u2022 71Z799014MO 28 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nconnectivity ). Este est\u00e1ndar es muy com\u00fan sobre todo en entornos Microsoft\ny s\u00f3lo deber\u00eda usarse si no disponemos del driver  nativo para nuestro SGBD.\nEn el caso concreto de MySQL y Post greSQL, no tendremos ning\u00fan problema\nen encontrar los drivers JDBC:\n\u2022 MySQL Connector/J: es el driver  oficial para MySQL y se distribuye bajo li-\ncencia GPL. Es un driver  nativo escrito completamente en Java.\n\u2022 JDBC para PostgreSQL: es el driver  oficial para PostgreSQL y se distribuye\nbajo licencia BSD. Es un driver  nativo escrito completamente en Java.\nTanto uno como otro, en su distribuci\u00f3n en formato binario, consisten en un\nfichero .jar ( Java archive ) que debemos situar en el CLASSPATH de nuestro pro-\ngrama para poder incluir sus clases.\nJava incluye la posibilidad de cargar cl ases de forma din\u00e1mi ca. \u00c9ste es el caso\nde los controladores de bases de datos: antes de realizar cu alquier interacci\u00f3n\ncon las clases de JDBC, es preciso registra r el controlador. Es ta tarea se realiza\ncon el siguiente c\u00f3digo:\no bien:\nA partir de este momento, JDBC est\u00e1 capacitado para in teractuar con MySQL\no PostgreSQL.\n2.1. Acceder al SGBD con JDBC\nLa interfaz JDBC est\u00e1 definida en la lib rer\u00eda java.sql. Vamos a importar a nues-\ntra aplicaci\u00f3n Java todas las clases definidas en ella.\nPuesto que JDBC puede realizar cone xiones con m\u00faltiples SGDB, la clase\nDriverManager  configura los detalles de la  interacci\u00f3n con cada uno en\nparticular. Esta clase es la responsable de realizar  la conexi\u00f3n, entregando\nun objeto de la clase Connection .String controlador = \u201ccom.mysql.jdbc.Driver\u201d\nClass.forName(controlador).newInstance();\nClass.forName(\u201corg.postgresql.Driver\u201d);\nimport java.sql.*;\uf8e9 FUOC \u2022 71Z799014MO 29 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nEl destino de la conexi\u00f3n se especifica mediante un URL de JDBC con la sin-\ntaxis siguiente:\nLa parte protocolo_sgdb  de la URL especifica el tipo de SGBD con el que se\nrealizar\u00e1 la conexi\u00f3n, la clase DriverManager  cargar\u00e1 el m\u00f3dulo correspon-\ndiente a tal efecto.\nEl subnombre  tiene una sintaxis espec\u00edfica para cada SGDB que tanto para\nMySQL como para PostgreSQL es //servidor/base_de_datos .\nLas sentencias en JDBC tambi\u00e9n son objetos que deberemos crear a partir de\nuna conexi\u00f3n:\nAl ejecutar una sentencia, el SGBD en trega unos resultados que JDBC tambi\u00e9n\nrepresenta en forma de objeto , en este caso de la clase ResultSet : \nPara acceder a los datos de cada columna de la hoja de resultados, la clase Resul-\ntSet  dispone de varios m\u00e9todos seg\u00fan el tipo de la informaci\u00f3n de la columna: String url=\u201cjdbc:mysql://localhost/demo\u201d;\nString usuario=\u201cyo\u201dString contasenia=\u201ccontrase\u00f1a\u201dConnection conexion = DriverManager.getConnection (url,usuario,contrasenia);\njdbc:<protocolo_sgbd>:<subnombre>\nStatement sentenciaSQL = conexion.createStatement();\nLa variable res contiene el resultado \nde la ejecuci\u00f3n de la sentencia, \ny proporciona un cursor que \npermite leer las filas una a una.\nResultSet res = sentencia.executeQuery(\u201cSELECT * FROM tabla\u201d);\ngetArray() getInt()\ngetClob() getBoolean()\ngetString() getLong()\ngetAsciiStream() getByte()getDate() getObject()getTime() getObject()\ngetBigDecimal() getBytes()\ngetDouble() getBytes()getTimestamp() getRef()\ngetBinaryStream() getRef()\ngetFloat() getCraracterStream()getURL() getShort()\ngetBlob()\uf8e9 FUOC \u2022 71Z799014MO 30 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nEn el ejemplo anterior no se ha previs to nada para tratar  con los errores que\npuedan producirse, porque en  Java el tratamiento de errores se realiza a trav\u00e9s\nde Exceptions . En JDBC se han previsto ex cepciones para los errores que\npueden producirse a lo largo de todo el uso de la API: conexi\u00f3n, ejecuci\u00f3n dela sentencia, etc.\nRevisemos el ejemplo, utilizando ex cepciones para tratar los errores.  import java.sql.*;\n// Atenci\u00f3n, no debe importarse com.mysql.jdbc ya que se carga din\u00e1micamente!!\npublic static void main(String[] args) {\n// Cargamos el driver JDBC para MySQL\nString controlador = \u201ccom.mysql.jdbc.Driver\u201d\nClass.forName(controlador).newInstance();\n// Conectamos con la BD\nString url=\u201cjdbc:mysql://localhost/uoc\u201d;\nString usuario=\u201cyo\u201dString contasenia=\u201ccontrase\u00f1a\u201d\nConnection conexion = DriverManager.getConnection (url,usuario,contrasenia);\n// Creamos una sentencia SQL\nStatement sentenciaSQL = conexion.createStatement();\n// Ejecutamos la sentencia\nResultSet res = sentencia.executeQuery(\u201cSELECT * FROM tabla\u201d);\n// Iteramos sobre la hoja de resultados\nwhile (res.next()) {\n// Obtenemos el campo \u2018nombre\u2019 en forma de String\nSystem.out.println(res.getString(\u201cnombre\u201d) );\n}\n// Finalmente, se liberan los recursos utilizados.\nres.close();sentencia.close();\nconexion.close();\n}\nimport java.sql.*;\n// Atenci\u00f3n, no debe importarse com.mysql.jdbc ya que se carga \n// din\u00e1micamente!!\npublic static void main(String[] args) {\ntry {\n// Cargamos el driver JDBC para MySQL\nString controlador = \u201ccom.mysql.jdbc.Driver\u201d\nClass.forName(controlador).newInstance();\n} catch (Exception e) {\nSystem.err.println(\u201cNo puedo cargar el controlador de MySQL ...\u201d);\ne.printStackTrace();\n}\ntry {\n// Conectamos con la BD\nString url=\u201cjdbc:mysql://localhost/uoc\u201d;\nString usuario=\u201cyo\u201dString contasenia=\u201ccontrase\u00f1a\u201d\nConnection conexion = DriverManager.getConnection (url,usuario,contrasenia);\uf8e9 FUOC \u2022 71Z799014MO 31 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nMientras que la operaci\u00f3n executeQuery()  de la clase Statement  devuelve\nun objeto ResultSet , la operaci\u00f3n executeUpdate () s\u00f3lo devuelve su \u00e9xito\no fracaso. Las sentencias SQL que se utilizan con executeUpdate () son insert ,\nupdate , o delete , porque no devuelven ning\u00fan resultado. \n2.2. Sentencias preparadas\nLas sentencias preparadas de JDBC pe rmiten la \u201cprecompilaci\u00f3n\u201d del c\u00f3digo\nSQL antes de ser ejecutado, permitiend o consultas o actualizaciones m\u00e1s efi-\ncientes. En el momento de compilar la se ntencia SQL, se analiza cu\u00e1l es la es-\ntrategia adecuada seg\u00fan la s tablas, las columnas, los \u00edndices y las condiciones\nde b\u00fasqueda implicados. Este proceso,  obviamente, consume tiempo de pro-\ncesador, pero al realizar la compilaci\u00f3n una sola vez, se lo gra mejorar el rendi-\nmiento en siguientes consultas iguales con valores diferentes.\nOtra ventaja de las sentencias preparad as es que permiten la parametrizaci\u00f3n:\nla sentencia SQL se escribe una vez, in dicando las posiciones de los datos que\nvan a cambiar y, cada vez que se utilic e, le proporcionar emos los argumentos\nnecesarios que ser\u00e1n sustituidos en lo s lugares correspondientes. Los par\u00e1me-\ntros se especifican con el car\u00e1cter \u2018?\u2019.// Creamos una sentencia SQL\nStatement sentenciaSQL = conexion.createStatement();\n// Ejecutamos la sentenciaResultSet res = sentencia.executeQuery(\u201cSELECT * FROM tabla\u201d);\n// Iteramos sobre la hoja de resultados\nwhile (res.next()) {\n// Obtenemos el campo \u2018nombre\u2019 en forma de String\nSystem.out.println(res.getString(\u201cnombre\u201d) );\n}\n// Finalmente, se liberan los recursos utilizados.\nres.close();\nsentencia.close();\nconexion.close();\n} catch (SQLException e) {\nSystem.out.println(\u201cExcepci\u00f3n del SQL: \u201c + e.getMessage());\nSystem.out.println(\u201cEstado del SQL: \u201c + e.getSQLState());\nSystem.out.println(\u201cError del Proveedor: \u201c + e.getErrorCode());\n}\n}\npublic void Insertar_persona(String nombre, direccion, telefono){\nStatement sentencia = conexion.CreateStatement();sentencia.executeUpdate( \u201cinsert into personas values(\u201c\n+ nombre + \u201c,\u201d\n+ domicilio + \u201c,\u201d+ telefono + \u201c)\u201d );\n} Errores\nTodos los errores de JDBC \nse informan a trav\u00e9s de SQLExeption .\nSQLWarning  presenta las\nadvertencias de acceso alas bases de datos.\uf8e9 FUOC \u2022 71Z799014MO 32 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nAl utilizar esta clase, obviamente, de beremos llamar primer o al m\u00e9todo que\nprepara la inserci\u00f3n, y posteriormente llamar tantas veces como sea necesario\nal m\u00e9todo insertarPersona .\nSe definen tres par\u00e1metros en la senten cia SQL, a los cuales se hace referencia\nmediante n\u00fameros enteros consecutivos:\nLa clase PreparedStatement  incluye un conjunto de operaciones de la for-\nma setXXXX() , donde XXXX  es el tipo de dato para los campos de la tabla. Una\nde esas operaciones es precisamente setString()  que inserta la variable en\nun campo de tipo cadena.\n2.3. Transacciones\nLa API JDBC incluye soporte para tran sacciones, de forma que se pueda desha-\ncer un conjunto de operaciones relacionadas en caso necesario. Este compor-\ntamiento es responsa bilidad de la clase Connection .\nPor omisi\u00f3n, cada sentencia se ejecuta en el momento en que se solicita y no\nse puede deshacer. Podemos cambiar este comportamiento con la operaci\u00f3n\nsiguiente:\nDespu\u00e9s de esta operaci\u00f3 n, es necesario llamar a commit()  para que todas las\nsentencias SQL pendientes  se hagan definitivas:public class Actualizacion{\nprivate PreparedStatement sentencia;\npublic void prepararInsercion(){\nString sql = \u201cinsert into personas values ( ?, ? ,? )\u201d;\nsentencia = conexion.prepareStatement(sql);\n}\npublic void insertarPersona(String nombre, direcci\u00f3n, telefono)\n{\nsentencia.setString(1, nombre);\nsentencia.setString(2, direccion);sentencia.setString(3, telefono);\nsentencia.executeUpdate();\n}\n}\nString sql = \u201cinsert into personas values ( ?, ? ,? )\u201d;\nconexion.setAutoCommit(false);Ejemplo\nEl segundo de los tres par\u00e1me-\ntros se especifica con senten-\ncia.setString(2, direccion);\uf8e9 FUOC \u2022 71Z799014MO 33 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nEn caso contrario, desharemos todas las actualizaciones despu\u00e9s del \u00faltimo\ncommit() :sentencia.executeUpdate(...);\n...sentencia.executeUpdate(...);...conexion.commit(); // Se hacen permanentes las dos actualizaciones anteriores\nsentencia.executeUpdate(...);...sentencia.executeUpdate(...);...sentencia.executeUpdate(...);...conexion.rollback(); // Cancela las tres \u00faltimas actualizaciones\uf8e9 FUOC \u2022 71Z799014MO 34 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nResumen\nHemos presentado algunas de las formas m\u00e1s habituales de conectarse a los\nSGBD que hemos visto en m\u00f3dulo s anteriores desde PHP y Java.\nHemos podido comprobar que no existe n demasiadas variaciones ni restric-\nciones entre MySQL y PostgreSQL en cuanto a su acceso desde lenguajes deprogramaci\u00f3n, sino al contrario, los esfuerzos se encaminan en homogeneizar\nel desarrollo e independizarlo de l SGBD con el que trabajamos.\nEn PHP, hemos repasado los m\u00e9todos nativos y visto sus particularidades. He-\nmos comprobado que, a no ser que nece sitemos caracter\u00edsticas propias y muy\navanzadas de un SGBD, no es aconsejable usar esos m\u00e9todos por los problemasque nos puede ocasionar un cambio de gestor de base de datos en el futuro.\nAun as\u00ed, es interesante revisarlos po rque encontraremos muchas aplicaciones\nde software libre desarrolladas en PH P que los utilizan.\nPEAR::DB es un ejemplo de librer\u00eda de abstracci\u00f3n (no es la \u00fanica) bien hecha\ny con el soporte de la fundaci\u00f3n que ma ntiene PHP. Tiene todo lo que pode-\nmos desear y actualmente es completame nte estable y usable en entornos em-\npresariales.\nEn Java, hemos visto JDBC. Aunque la API da mucho m\u00e1s de s\u00ed, creemos que\nhemos cumplido los objetivos de este cap\u00edtulo, sin entrar en conceptos ques\u00f3lo programadores expertos en Java podr\u00edan apreciar.\nAs\u00ed pues, se han proporcionado los elementos de referencia y los ejemplos ne-\ncesarios para trabajar con bases de datos en nues tras aplicaciones.\uf8e9 FUOC \u2022 71Z799014MO 35 Desarrollo de aplicaciones en conexi\u00f3n con bases de datos\nBibliograf\u00eda\nDocumentaci\u00f3n de PHP: http://www.php.net/docs.php\nPEAR :: The PHP Extension and Applic ation Repository: http://pear.php.net/\nPear::DB Database Abstraction Laye r: http://pear.php.net/package/DB\nDBC Technology: http://java.sun.com/products/jdbc/MySQL Connector/J: http://dev.m ysql.com/downloads/connector/j\nPostgreSQL JDBC Driver: http://jdbc.postgresql.org/Caso de estudio\nMarc Gibert Ginesta\n\uf8e9 FUOC \u2022 71Z799014MO Caso de estudio\n\u00cdndice\nIntroducci\u00f3n .............................................................................................. 5\nObjetivos ..................................................................................................... 6\n1. Presentaci\u00f3n del caso de estudio ..................................................... 7\n2. El modelo relacional y el \u00e1lgebra relacional ............................... 8\n2.1. Determinar las relaciones ................................................................. 82.2. Definici\u00f3n de claves ......................................................................... 92.3. Reglas de integridad .......................................................................... 112.4. \u00c1lgebra relacional ............................................................................. 12\n3. El lenguaje SQL .................................................................................... 13\n3.1. Sentencias de definici\u00f3n ................................................................... 13\n3.2. Sentencias de manipulaci\u00f3n ............................................................. 15\n4. Introducci\u00f3n al dise\u00f1o de bases de datos ..................................... 17\n4.1. Dise\u00f1o conceptual: el modelo ER ..................................................... 174.2. Dise\u00f1o l\u00f3gico: la transformaci\u00f3n del modelo ER \nal modelo relacional ......................................................................... 19\n5. Bases de datos en MySQL ................................................................... 22\n6. Bases de datos en PostgreSQL ........................................................... 24\n7. Desarrollo de aplicaciones  en conexi\u00f3n con bases \nde datos .................................................................................................. 25\nResumen ...................................................................................................... 30\uf8e9 FUOC \u2022 71Z799014MO 5 Caso de estudio\nIntroducci\u00f3n\nEste m\u00f3dulo forma parte del curso \u201cBases  de datos\u201d del itinerario \u201cAdministra-\ndor web y comercio electr\u00f3n ico\u201d dentro del M\u00e1ster Internacional de Software\nLibre de la Universitat Oberta de Catalunya.\nEl m\u00f3dulo est\u00e1 estructurado en apartados que corresponden al resto de los m\u00f3-\ndulos de la asignatura, de modo que el estudiante puede ir siguiendo este caso\nde estudio a medida que va progresando en el curso.\nAunque algunos de los m\u00f3dulos ya disponen de ejercicios de autoevaluaci\u00f3n,\nel caso de estudio presenta una visi\u00f3n  completa de un proyecto de bases de\ndatos y proporciona una visi\u00f3n pr\u00e1ctica de cada uno de ellos.\uf8e9 FUOC \u2022 71Z799014MO 6 Caso de estudio\nObjetivos\nLos objetivos que deber\u00edais alcanzar al finalizar el trabajo con la presente uni-\ndad son los siguientes:  \n\u2022 Comprender desde un punto de vista pr\u00e1ctico los conceptos explicados en\nlas unidades did\u00e1cticas te\u00f3ricas.\n\u2022 Disponer de un modelo de referencia  para emprender proyectos de bases\nde datos.\n\u2022 Adquirir el criterio suficiente para identificar las actividades clave y tomar\ndecisiones en un proyecto que im plique el uso de bases de datos.\uf8e9 FUOC \u2022 71Z799014MO 7 Caso de estudio\n1. Presentaci\u00f3n del caso de estudio\nAcabamos de entrar a trabajar en una peque\u00f1a empresa \u2013SuOrdenadorAMedi-\nda, S.L.\u2013 dedicada a la venta de ordenadores a particulares y otras empresas.Cuando nos hicieron la entrevista de trabajo, comentamos nuestra pasi\u00f3n por\nel software libre y en concreto hicimo s hincapi\u00e9 en nuestro conocimiento de\nlos motores de bases de datos libres y las ventajas que pod\u00edan aportar respectode los gestores propietarios. No sabemo s si eso fue lo que convenci\u00f3 a la per-\nsona de recursos humanos o no, pero, en todo caso, y visto el resultado de la\nreuni\u00f3n que hemos tenido en nuestro pr imer d\u00eda de trabajo, vamos a tener\nque aplicar nuestros conocimientos a fondo.\nNos han contado que, hasta ahora, la gesti\u00f3n de la empresa se llevaba a cabo\ncon programas propietarios de gesti\u00f3n y contabilidad, pero que debido a pro-\nblemas con la empresa que desarrollaba estos programas, se est\u00e1 considerando\nla migraci\u00f3n de la gesti\u00f3n administrativa y de operaciones a entornos abiertos.\nPara acabar de decidirse, nos proponen  que empecemos por renovar el sistema\nde gesti\u00f3n de peticiones e incidencias por parte de los clientes, de modo que\nest\u00e9 basada en software libre.\nActualmente, las peticiones e incidencia s se reciben telef\u00f3 nicamente, por co-\nrreo electr\u00f3nico o en persona en alguno de los locales que tiene la empresa. La\npersona que atiende al tel\u00e9fono o lee lo s correos electr\u00f3nicos de plantea una\nserie de preguntas al cliente y escribe en una plantilla de documento las res-\npuestas. A continuaci\u00f3n, se imprime el  documento y se deja en una bandeja\nque recogen los t\u00e9cn icos cada ma\u00f1ana.\nA medida que los t\u00e9cnicos van avanzando en la soluci\u00f3n de la incidencia (o han\nllamado al cliente para pedir m\u00e1s datos) , van apuntando las acciones y el estado\ndel problema en la hoja que recogieron, hasta que la incidencia queda resuelta.\nEn ese momento, la dejan en una bandeja que recoge cada ma\u00f1ana el personalde administraci\u00f3n, que se pone en contac to con el cliente y factura el importe\ncorrespondiente a las horas de tr abajo y componentes sustituidos.\nEs obvio que este sistema presenta numerosas deficiencias, y que el rendimien-\nto tanto de los t\u00e9cnicos, como del pers onal administrativo y de atenci\u00f3n al\ncliente podr\u00eda aumentar enormemente si muchos de estos procesos fueran au-\ntom\u00e1ticos, centralizados y, a poder ser, conectados con el resto del sistema deinformaci\u00f3n de la empresa.\n\u00c9ste es, a grandes rasgos, el problema  que se nos plante a, y que utilizaremos\ncomo caso de estudio para aplicar los conocimientos adquiridos durante el de-\nsarrollo del curso.\uf8e9 FUOC \u2022 71Z799014MO 8 Caso de estudio\n2. El modelo relacional y el \u00e1lgebra relacional\nVisto el proyecto planteado, decidimo s hacer las cosas bien hechas para, de\npaso, impresionar a nuestro jefe con nu estros conocimientos en bases de da-\ntos. El primer paso ser\u00e1 presentarl e un documento que describa el modelo\nrelacional que vamos a utilizar, en el que incluiremos algunas consultas demuestra para que pueda comprobar qu\u00e9 ser\u00e1 capaz de hacer con nuestro pro-\nyecto cuando est\u00e9 acabado.\n2.1. Determinar las relaciones\nEn primer lugar determinaremos las re laciones, sus atributos y los dominios\nde cada uno de ellos:\nEn la relaci\u00f3n PETICION , hemos decidido que convendr\u00eda tener una referen-\ncia interna de la petici\u00f3n, que nos ayudar \u00e1 al hablar de ella con el cliente (si\ntuviese varias abiertas) y evitar\u00e1 confusiones al trabajar. El resto de atributos\nson bastante expl\u00edcitos.\nComo una petici\u00f3n puede evolucionar co n el tiempo, a medida que se piden\nm\u00e1s datos al cliente, la in cidencia va evolucionando, etc., hemos creado las re-\nlaciones NOTA_PETICION  y MATERIAL_PETICION  para reflejarlo.\nTambi\u00e9n hemos tenido que definir las relaciones CLIENTE  y EMPLEADO  para\npoder relacionarlas con las peticiones y las notas qu e se vayan generando du-\nrante su resoluci\u00f3n.\nA continuaci\u00f3n vamos a definir los dominios de los atributos:\n PETICION(referencia,  cliente,  resumen,  estado,  fecharecepcion,  fechainicio,  fechafin,  \ntiempoempleado)\nNOTA_PETICION(peticion, nota, fecha, empleado)\nMATERIAL_PETICION(nombrematerial, peticion, cantidad, precio)CLIENTE(nombre, nif, telefono, email)EMPLEADO(nombre, nif)\nPETICION:dominio(referencia)=n\u00famerosdominio(cliente)=NIF\uf8e9 FUOC \u2022 71Z799014MO 9 Caso de estudio\nAl definir los dominios de cada atributo, ya nos hemos avanzado en la toma\nde algunas decisiones: al decidir, por ejemplo, que el dominio del atributo em-\npleado  en la relaci\u00f3n NOTA_PETICION  es NIF, estamos impl\u00edcitamente deter-\nminando que la clave primaria de la relaci\u00f3n EMPLEADO  ser\u00e1 del dominio NIF\ny que usaremos un atributo de este dominio para referirnos a \u00e9l. \n2.2. Definici\u00f3n de claves\nAunque algunas claves ya se intuyen a pa rtir de los atributo s de las relaciones,\nvamos a determinarlas para completar el caso. dominio(resumen)=texto\ndominio(estado)=estadosdominio(fecharecepcion)=fechayhoradominio(fechainicio)=fechayhoradominio(fechafin)=fechayhoradominio(tiempoempleado)=horasyminutos\nNOTA_PETICION:\ndominio(peticion)=n\u00famerosdominio(nota)=textodominio(fecha)=fechayhoradominio(empleado)=NIF\nMATERIAL_PETICION:\ndominio(nombrematerial)=nombreMaterialdominio(peticion)=n\u00famerosdominio(precio)=preciodominio(cantidad)=n\u00fameros\nCLIENTE:\ndominio(nombre)=nombreClientedominio(nif)=NIFdominio(telefono)=tel\u00e9fonosdominio(email)=emails\nEMPLEADO:\ndominio(nombre)=nombreEmpleadodominio(nif)=NIF\nEste proceso descrito indicando directamente su resultado, normalmen-\nte es fruto de una revisi\u00f3n de las entidades a medida que se van defi-\nniendo y analizando las necesidades de \u00e9stas.\nNota\nLa regla de integridad del mode-\nlo correspondiente a la clave pri-maria obligar\u00e1 a que no existan dos notas sobre la misma peti-ci\u00f3n hechas en la misma fecha y hora por parte del mismo em-pleado, lo cual es perfectamente l\u00edcito y coherente.\uf8e9 FUOC \u2022 71Z799014MO 10 Caso de estudio\nAhora podemos reescrib ir las relaciones:\nLas claves for\u00e1neas ya se intuyen a part ir de las relaciones, aunque vamos a co-\nmentarlas para completar el caso:\nNOTA_PETICION:\nTiene de clave for\u00e1nea el atributo {peticion},  que establece la relaci\u00f3n (y\npertenece al mismo dominio) con el atributo {referencia}  de la relaci\u00f3n\nPETICION .\nTambi\u00e9n tiene la clave for\u00e1nea {empleado},  que establece la relaci\u00f3n con\nEMPLEADO  a partir de su clave primaria {nif}.\nMATERIAL_PETICION:\nTiene de clave for\u00e1nea el atributo  {peticion},  que establece la relaci\u00f3n (y\npertenece al mismo dominio) con el atributo {referencia}  de la relaci\u00f3n\nPETICION .PETICION:\nClaves candidatas: {referencia}Clave primaria: {referencia}\nNOTA_PETICION: \nClaves candidatas: {peticion,fecha,empleado}\nClave primaria: {peticion, fecha,empleado}\nMATERIAL_PETICION:\nClaves candidatas: {nombrematerial,peticion}Clave primaria: {nombrematerial,peticion}\nCLIENTE:\nClaves candidatas: {nif}Clave primaria: {nif}\nEMPLEADO:\nClaves candidatas: {nif}Clave primaria: {nif}En todos los casos s\u00f3lo tenemos \nuna clave candidata y, por lo tanto, \nno caben dudas a la hora de \nescoger la clave primaria. Esto no \ntiene por que ser as\u00ed: en la relaci\u00f3n \nEMPLEADO , podr\u00edamos haber \nincluido m\u00e1s atributos (n\u00famero de \nla seguridad social, un n\u00famero de \nempleado interno, etc.) que ser\u00edan \nclaves candidatas susceptibles\nde ser clave primaria. \nPETICION(referencia , cliente, resumen, estado, fecharecepcion, fechainicio, fechafin,\ntiempoempleado)\nNOTA_PETICION(pet icion, nota, fecha , empleado )\nMATERIAL_PETICION(nombrematerial , peticion , cantidad, precio)\nCLIENTE(nombre, nif , telefono, email)\nEMPLEADO(nombre, nif )\uf8e9 FUOC \u2022 71Z799014MO 11 Caso de estudio\n2.3. Reglas de integridad\nEn este punto, no es nece sario preocuparse por las regl as de integridad del mo-\ndelo que tratan sobre la clave primar ia, ya que nos vend r\u00e1n impuestas en el\nmomento de crear las tablas en el SGBD. \nEs conveniente, no obstante, fijar las de cisiones sobre la integridad referencial;\nen concreto, qu\u00e9 vamos a hacer en caso de  restricci\u00f3n. As\u00ed pu es, para cada re-\nlaci\u00f3n que tiene una clave primaria refe renciada desde otra, deberemos decidir\nqu\u00e9 pol\u00edtica cabe aplicar en ca so de modificaci\u00f3n o borrado:\nPETICION\n\u2022 Modificaci\u00f3n del atributo {referencia}  referenciado desde\nNOTA_PETICION  y MATERIAL_PETICION : aqu\u00ed podemos optar por la res-\ntricci\u00f3n o por la actualizaci\u00f3n en cascada (m\u00e1s c\u00f3moda, aunque no todos\nlos SGBD la implementan, como veremos m\u00e1s adelante).\n\u2022 Borrado del atributo {referencia}.  Aqu\u00ed optaremos por una pol\u00edtica de\nrestricci\u00f3n. Si la petici\u00f3n tiene nota s asociadas o materiales, significa que ha\nhabido alguna actividad y, por lo tant o, no deber\u00edamos poder borrarla. Si se\ndesea anularla, ya estableceremos un estado de la misma que lo indique.\nCLIENTE\n\u2022 Modificaci\u00f3n del atributo {nif}  referenciado desde PETICION . Es proba-\nble que si un cliente cambia de NIF (p or un cambio del tipo de sociedad,\netc.) deseemos mantener sus peticiones . Aqu\u00ed la pol\u00edtica debe ser de actua-\nlizaci\u00f3n en cascada.\n\u2022 Borrado del atributo {nif} . Es posible que si queremos borrar un cliente,\nes porque hemos terminado toda relaci\u00f3n  con \u00e9l y, por lo tanto, es cohe-\nrente utilizar aqu\u00ed la pol\u00edtica de anulaci\u00f3n.\nEMPLEADO\n\u2022 Modificaci\u00f3n del atributo {nif}  referenciado desde NOTA_PETICION.  No\nes probable que un empleado cambie su  NIF, salvo caso de error. Aun as\u00ed,\nen caso de que se produzca, es pref erible la actualizaci\u00f3n en cascada.\n\u2022 Borrado del atributo {nif}.  Aunque eliminemos un empleado si termina\nsu relaci\u00f3n con la empresa, no deber\u00ed amos eliminar sus notas. La mejor op-\nci\u00f3n es la restricci\u00f3n.\uf8e9 FUOC \u2022 71Z799014MO 12 Caso de estudio\n2.4. \u00c1lgebra relacional\nPara probar el modelo, una buena opci\u00f3n es intentar realizar algunas consul-\ntas sobre \u00e9l y ver si obtenemos los resu ltados deseados. En nuestro caso, vamos\na realizar las sigu ientes consultas:\n\u2022 Obtenci\u00f3n de una petici\u00f3n ju nto con los dato s del cliente:\n\u2022 Obtenci\u00f3n de una petici\u00f3n con todas sus notas:\n\u2022 Obtenci\u00f3n de los datos de todos lo s empleados que han participado en la\npetici\u00f3n 5:\nEjercicio\nOs sugerimos que intent\u00e9is m\u00e1s operaciones so bre el modelo para familiarizaros con \u00e9l.R:= PETICION [cliente=nif] CLIENTE\nNP(peticionnota,  nota,  fechanota,  empleado):=NOTA_PETICION(peticion , nota,  fecha, empleado )\nR:=PETICION[peticion=peticionnota]NOTA_PETICION\nNP:=NOTA_PETICION[peticion=5]RA:=EMPLEADO[nif=empleado]NPR:=RA[nombre,nif]\uf8e9 FUOC \u2022 71Z799014MO 13 Caso de estudio\n3. El lenguaje SQL\nUna vez terminado el mode lo relacional, decidimos completar la documenta-\nci\u00f3n que ven\u00edamos realizando con las sentencias SQL correspondientes. As\u00ed,\nveremos en qu\u00e9 se concretar\u00e1 el modelo relacional.\nComo a\u00fan no sabemos en qu\u00e9 sistema gest or de base de datos vamos a implan-\ntar la soluci\u00f3n, decidimos simplemente an otar las sentencias  seg\u00fan el est\u00e1ndar\nSQL92, y, posteriormente, ya examinar emos las particularidades del sistema\ngestor escogido para adaptarlas.\n3.1. Sentencias de definici\u00f3n\n\u2022 Creaci\u00f3n de la base de datos\n\u2022 Definici\u00f3n de dominios\n\u2022 Creaci\u00f3n de las tablas  CREATE SCHEMA GESTION_PETICIONES; Atenci\u00f3n\nEn algunos casos es conveniente \nla definici\u00f3n de dominios para facilitar el trabajo posterior de mantenimiento de la coherencia de la base de datos. No es acon-sejable definir dominios para cada dominio relacional, pero s\u00ed en los casos en que una colum-na puede tomar una serie de va-lores determinados.\nCREATE DOMAIN dom_estados AS CHAR (20) \nCONSTRAINT estados_validos CHECK (VALUE IN (\u2018Nueva\u2019,\u2019Se necesitan m\u00e1s datos\u2019,\u2019Aceptada\u2019,\u2019Confirmada\u2019,\n\u2019Resuelta\u2019,\n\u2018Cerrada\u2019)) \nDEFAULT \u2018Nueva\u2019; \nCREATE TABLE PETICION ( referencia INTEGER NOT NULL, \ncliente INTEGER NOT NULL, \nresumen CHARACTER VARYING (2048), \nestado dom_estados NOT NULL, fecharecepcion TIMESTAMP NOT NULL, \nfechainicio TIMESTAMP, fechafin TIMESTAMP, \ntiempoempleado TIME, PRIMARY KEY (referencia), FOREIGN KEY cliente REFERENCES CLIENTE(nif) \nON DELETE CASCADE \nON UPDATE CASCADE, \nCHECK (fecharecepcion < fechainicio), \nCHECK (fechainicio < fechafin) ); Atenci\u00f3n\nAqu\u00ed deberemos tener en \ncuenta las reglas de integridad, ya que habr\u00e1 que explicitarla pol\u00edtica escogida como restricci\u00f3n.\uf8e9 FUOC \u2022 71Z799014MO 14 Caso de estudio\n\u2022 Creaci\u00f3n de vistas\n\u2013 Peticiones pendientes:CREATE TABLE NOTA_PETICION ( peticion INTEGER NOT NULL, \nnota CHARACTER VARYING (64000), fecha TIMESTAMP NOT NULL, empleado CHARACTER (9), FOREIGN KEY (peticion) REFERENCES PETICION(referencia) \nON DELETE NO ACTION \nON UPDATE CASCADE,\nFOREIGN KEY (empleado) REFERENCES EMPLEADO(nif) \nON DELETE NO ACTION ON UPDATE CASCADE ); \nCREATE TABLE MATERIAL_PETICION ( nombrematerial CHARACTER \nVARYING (100) NOT NULL,\npeticion INTEGER NOT NULL, precio DECIMAL(8,2), cantidad INTEGER, FOREIGN KEY (peticion) REFERENCES PETICION(referencia) \nON DELETE NO ACTION \nON UPDATE CASCADE ); \nCREATE TABLE CLIENTE ( nombre CHARACTER VARYING (100) NOT\nNULL, \nnif CHARACTER (9) NOT NULL, \ntelefono CHARACTER (15), \nemail CHARACTER (50), PRIMARY KEY (nif) ); \nCREATE TABLE EMPLEADO (nombre CHARACTER VARYING (100) NOT\nNULL, \nnif CHARACTER (9) NOT NULL, \nPRIMARY KEY (nif) ); \nFunci\u00f3n de vistas\nLas vistas agilizar\u00e1n las consul-\ntas que prevemos que van a ser mas frecuentes.\nCREATE VIEW peticiones_pendientes (referencia, nombre_cliente, resumen, estado, duracion,\nfecharecepcion) AS (SELECT P.referencia, C.nombre, P.resumen, P.estado, (P.fechainicio P.fecharecepcion),\nP.fecharecepcion FROM PETICION P JOIN CLIENTE C ON P.cliente = C.nif WHERE estado NOT IN (\u2018Resuelta\u2019,\u2019Cerrada\u2019) ORDER BY fecharecepcion ) \uf8e9 FUOC \u2022 71Z799014MO 15 Caso de estudio\n\u2013 Tiempo y precio de los materiales em pleados para las peticiones termina-\ndas en el mes en curso: \n3.2. Sentencias de manipulaci\u00f3n\nA continuaci\u00f3n, decidimos indicar algu nas sentencias de manipulaci\u00f3n co-\nrrientes para completar la documentaci\u00f3n. De esta manera, cuando empece-mos el desarrollo, tendremos mucho m\u00e1s cl aras estas operaciones sobre la base\nde datos:\n\u2022 Nuevo cliente:\nINSERT INTO CLIENTE VALUES (\u2018Juan P\u00e9rez\u2019,\u201942389338A\u2019,\u2019912223354\u2019,\u2019juanperez@gmail.com\u2019); \n\u2022 Nueva petici\u00f3n: \nINSERT INTO PETICION VALUES (5,\u201942389338A\u2019, \u2018No le arranca el ordenador\u2019,\n\u2019Nueva\u2019,CURRENT_TIMESTAMP,NULL,NULL,NULL); \n\u2022 Cambio de estado de la petici\u00f3n, a\u00f1adimos una nota y un material:\nUPDATE PETICION SET estado=\u2018Aceptada\u2019 WHERE referencia=5; \nINSERT INTO NOTA_PETICION VALUES (5,\u2019Parece un problema del disco duro. Vamos examinarlom\u00e1s a fondo.\u2019,CURRENT_TIMESTAMP,\u201935485411G\u2019); \nINSERT INTO MATERIAL_PETICION VALUES (\u2018Disco duro 20Gb\u2019,5,250.00,1); \n\u2022 Materiales solicitados en la petici\u00f3n 5:\nSELECT nombrematerial, cantidad, precio FROM MATERIAL_PETICION WHERE peticion=5\n\u2022 N\u00famero de peticiones abiertas del cliente \u201842389338A\u2019:\nSELECT COUNT(*) FROM PETICION WHERE cliente=\u201842389338A\u2019 AND estado NOT IN (\u2018Resuelta\u2019,\n\u2019Cerrada\u2019); CREATE VIEW peticiones_terminadas (referencia, nombre_cliente, resumen,tiempo_empleado, importe_materiales) AS (\nSELECT P.referencia, C.nombre, P.resumen, P.tiempoempleado, SUM(M.precio) FROM PETICION P, CLIENTE C, MATERIAL_PETICION M WHERE P.cliente=C.nif AND M.peticion=P.referencia AND estado=\u2018Resuelta\u2019 GROUP BY P.referencia)\uf8e9 FUOC \u2022 71Z799014MO 16 Caso de estudio\nLa creaci\u00f3n de vistas del apartado anterior nos ha mostrado tambi\u00e9n algunas\nconsultas complejas que repetimos a continuaci\u00f3n: \n\u2022 Peticiones abiertas:\nSELECT P.referencia, C.nombre, P.resumen, P.estado, (P.fechainicio   P.fecharecepcion),\nP.fecharecepcion FROM PETICION P JOIN CLIENTE C ON P.cliente = C.nif WHERE estado NOT IN(\u2018Resuelta\u2019,\u2019Cerrada\u2019) ORDER BY fecharecepcion; \n\u2022 Tiempo y precio de los materiales em pleados para las peticiones termina-\ndas en el mes en curso:\nSELECT P.referencia, C.nombre, P.resumen, P.tiempoempleado, SUM(M.precio) FROM PETICION\nP, CLIENTE C, MATERIAL_PETICION M WHERE P.cliente=C.nif AND M.peticion=P.referencia ANDestado=\u2018Resuelta\u2019 GROUP BY P.referencia;\nFinalmente, vamos a practicar con las co nsultas que realizamos en \u00e1lgebra re-\nlacional en el apartado anterior: \n\u2022 Obtenci\u00f3n de una petici\u00f3n ju nto con los dato s del cliente:\nR:= PETICION [cliente=nif] CLIENTE \nSELECT * FROM PETICION JOIN CLIENTE ON PETICION.cliente=CLIENTE.nif; \n\u2022 Obtenci\u00f3n de una petici\u00f3n con todas sus notas:\nNP(peticionnota,nota,fechanota,empleado):=NOTA_PETICION (peticion,nota,fecha,empleado)\nR:=PETICION[referencia=peticionnota]NPSELECT PETICION.*, peticion AS peticionnota, nota, fecha as fechanota, empleado FROM PETICION JOIN NOTA_PETICION ON referencia=peticionnota; \n\u2022 Obtenci\u00f3n de los datos de todos lo s empleados que han participado en la\npetici\u00f3n 5:\nNP:=NOTA_PETICION[peticion=5] \nRA:=EMPLEADO[nif=empleado]NP R:=RA[nombre,nif] \nSELECT E.nombre, E.nif FROM EMPLEADO E, NOTA_PETICION N WHERE E.nif=NOTA_PETICION.empleado\nAND NOTA_PETICION.peticion=5;\uf8e9 FUOC \u2022 71Z799014MO 17 Caso de estudio\n4. Introducci\u00f3n al dise\u00f1o de bases de datos\nAunque las sentencias SQL de creaci\u00f3n de tablas son bastante claras para\nun usuario t\u00e9cnico, de cara a la reuni\u00f3 n previa a la toma de decisi\u00f3n sobre\nel SGBD concreto en el que vamos a implantar la soluci\u00f3n, necesitaremos\nalgo m\u00e1s. \nTeniendo en cuenta que entre los asis tentes a la reuni\u00f3n no hay m\u00e1s t\u00e9cni-\ncos especializados en bases de datos que nosotros, hemos pensado que dis-\nponer un modelo entidad-relaci\u00f3n del sistema nos ayudar\u00e1 a comunicar\nmejor la estructura que estamos planteando y, de paso, a demostrar (o, sies necesario, corregir) que el modelo relacional que planteamos al inicio es\nel correcto.\n4.1. Dise\u00f1o conceptual: el modelo ER\nVamos a plantear en primer lugar el mo delo obtenido y, despu\u00e9s, comentare-\nmos los aspectos m\u00e1s interesantes:\nEl modelo, expresado de este modo, es mucho m\u00e1s comprensible por parte de\npersonal no t\u00e9cnico o no especializado en tecnolog\u00edas de bases de datos.\n\uf8e9 FUOC \u2022 71Z799014MO 18 Caso de estudio\nA partir de la expresi\u00f3n gr\u00e1fica del modelo, identificamo s limitaciones o pun-\ntos de mejora, que anotamos a continuaci\u00f3n:\n\u2022 Probablemente, debemos incluir inform aci\u00f3n de facturaci\u00f3n a clientes por\nlas peticiones realizadas.\n\u2022 Probablemente, habr\u00e1 peticiones que puedan agruparse en una entidad su-\nperior (un proyecto o trabajo), o bien peticiones relacionadas entre ellas\n(peticiones que deban reso lverse antes que otras). \nUna vez identificadas estas limitaciones,  vamos a ampliar el modelo para co-\nrregirlas e impresionar a nuestros superiores de cara a la reuni\u00f3n.\n\u2022 Informaci\u00f3n de fact uraci\u00f3n a clientes:\nLo \u00fanico que hemos introducido ha sido la entidad FACTURA , que se relaciona\ncon N peticiones y con un \u00fanico cliente. Un CLIENTE  puede tener varias fac-\nturas asociadas, pero una petici\u00f3n s\u00f3lo  puede pertenecer a una \u00fanica factura. \n\u2022 Grupos de peticiones y relaciones entre ellas.\n\uf8e9 FUOC \u2022 71Z799014MO 19 Caso de estudio\nLa pertenencia a un proyecto ser\u00e1 opcion al, y as\u00ed lo indicamos en el diagrama.\nPor lo que respecta a las relaciones de pe ticiones entre ellas, se trata de una in-\nterrelaci\u00f3n recursiva. Si queremos contemplar casos como los siguientes, de-bemos expresar la relaci\u00f3n como M:N re cursiva y opcional. En la interrelaci\u00f3n\nRELACIONA,  debemos contemplar alg\u00fan atributo que indique de qu\u00e9 tipo de\nrelaci\u00f3n se trata en cada caso:\n\u2022 Una petici\u00f3n depende de una o m\u00e1s peticiones.\n\u2022 Una petici\u00f3n bloquea a una o m\u00e1s peticiones.\u2022 Una petici\u00f3n es la duplicada de una o m\u00e1s peticiones.\u2022 Una petici\u00f3n est\u00e1 relacionada con una o m\u00e1s peticiones. \n4.2. Dise\u00f1o l\u00f3gico: la transforma ci\u00f3n del modelo ER al modelo \nrelacional\nEn el apartado anterior sugerimos unas ampliaciones sobre el modelo ER que\nproporcionaban m\u00e1s prestaciones al proyecto. A continuaci\u00f3n, vamos a reali-zar la transformaci\u00f3n al modelo relacional de estas ampliaciones:\n\u2022 Informaci\u00f3n de fact uraci\u00f3n a clientes.\nSeg\u00fan las transformaciones vistas en el  m\u00f3dulo \u201cEl lenguaje SQL\u201d, la entidad\nFACTURA  se transforma en la relaci\u00f3n FACTURA , con los siguientes atributos: \nDonde cliente  es una clave for\u00e1nea que co rresponde a la interrelaci\u00f3n TIE-\nNE entre CLIENTE  y FACTURA . Un cliente puede tener N facturas, pero una fac-\ntura pertenece s\u00f3lo a un \u00fanico cliente.FACTURA(numfactura , fecha, cliente) \n\uf8e9 FUOC \u2022 71Z799014MO 20 Caso de estudio\nLa interrelaci\u00f3n entre FACTURA  y PETICION  del tipo 1:N se transforma tam-\nbi\u00e9n en una nueva clave for\u00e1nea, que aparece siempre en el lado N de la inte-\nrrelaci\u00f3n; o sea, en la relaci\u00f3n PETICION . Si existen peticiones que no deban\nfacturarse (porque se han cerrado sin resolverse, o eran duplicadas de otras,etc.), su clave for\u00e1nea tomar\u00eda el valor NULO . \n\u2022 Grupos de peticiones y relaciones entre ellas.\nPor una parte, la entidad proyecto debe transformarse en la relaci\u00f3n PROYECTO ,\ncon atributos como los siguientes:\nLa relaci\u00f3n 1:N entre PROYECTO  y PETICI\u00d3N  se transformar\u00e1 en la inserci\u00f3n\nde una nueva clave for\u00e1nea en la relaci\u00f3n PETICION , que podr\u00e1 tener valor\nNULO  si la petici\u00f3n no pertenece a ning\u00fan proyecto; es decir, si se trata de una\npetici\u00f3n aislada. La relaci\u00f3n PETICION  quedar\u00eda as\u00ed: \nPor lo que respecta a las re laciones entre peticiones, se trata de una interrela-\nci\u00f3n recursiva N:M, y por lo tanto se  transformar\u00e1 en una nueva relaci\u00f3n,\nPETICION_RELACION :PROYECTO(codigo , nombre, fechainicio, fechafin) \nPETICION(referencia , cliente, resumen, estado, fecharecepcion, fechainicio, fechafin,\ntiempoempleado, factura, proyecto) \nPETICION_RELACION(referencia_peticion1, referencia_peticion2, tiporelacion ) \uf8e9 FUOC \u2022 71Z799014MO 21 Caso de estudio\nEn este caso, y seg\u00fan el valo r que pueda tomar el atributo {tiporelacion} ,\ntendr\u00e1 importancia o no qu \u00e9 referencia de petici\u00f3n aparece en cada atributo\nde la relaci\u00f3n.\nEn cambio, si el atributo {tiporelacion}  indica un bloqueo o una depen-\ndencia entre relaciones (porque una debe  resolverse antes que otra, por ejem-\nplo), entonces s\u00ed tiene sentido qu\u00e9 referencia de petici\u00f3n se almacena en elatributo 1 y cu\u00e1l en el 2. En todo ca so, esta tarea corresp onder\u00e1 a la soluci\u00f3n\nque se adapte y trabaje con la base de datos en \u00faltimo t\u00e9rmino, no al propio\nmodelo.Ejemplo\nSi la relaci\u00f3n debe indicar sim-\nplemente que dos peticiones est\u00e1n relacionadas, entonces no importa qu\u00e9 referencia sea, la 1 o la 2. \uf8e9 FUOC \u2022 71Z799014MO 22 Caso de estudio\n5. Bases de datos en MySQL\nUna vez hemos terminado el proceso de dise\u00f1o de nuestra soluci\u00f3n, en cuanto\na su sistema de informaci\u00f3n, es hora de implantarlo sobre un sistema gestorde bases de datos.\nYa que disponemos de dos alternativas  (MySQL y PostgreSQL), y no nos co-\nrresponde tomar la decisi\u00f3n final (s\u00f3l o hacer la recomend aci\u00f3n), vamos a ela-\nborar una lista con los aspectos clave en la toma de decisiones y a puntuar, o\ncomentar, cada SGBD seg\u00fa n los \u00edtems siguientes:\n\u2022 Modelo de licencia, precio.\n\u2022 Soporte por parte del fabricante.\u2022 Conexi\u00f3n desde PHP.\n\u2022 Prestaciones en creaci\u00f3n de las estructuras (tablas, \u00edndices, etc.).\n\u2022 Prestaciones en tipos de datos.\u2022 Prestaciones en consultas simples.\u2022 Prestaciones en consultas complejas.\u2022 Prestaciones en manipulaci\u00f3n de datos.\u2022 Facilidad en la administraci\u00f3n de usuarios.\n\u2022 Facilidad en la gesti\u00f3n de copias de seguridad.\nConcepto Valoraci\u00f3n Comentarios\nModelo de licencia, \nprecio2 Aunque no nos planteamos vender nuestra soluci\u00f3n, \nni comercializarla con una licencia propietaria, la licencia dual de MySQL siempre ser\u00e1 un aspecto que tendremos que tener en cuenta  si alguien se interesa \npor nuestra aplicaci\u00f3n.\nSoporte por parte \ndel fabricante3 Tenemos tanto la opci\u00f3n de contratar soporte en \nvarias modalidades, como la de optar por consultar a la ampl\u00edsima gama de usuarios del producto. En todo caso, en ambas situaciones obtendremos un excelente soporte.\nConexi\u00f3n desde PHP 3 PHP siempre ha incluido soporte para este SGBD bien \ncon funciones especiales de dicadas que aprovechan al \nm\u00e1ximo sus caracter\u00edsticas, o bien con librer\u00edas PEAR como DB que nos abstraen del SGBD y que soportan MySQL a la perfecci\u00f3n. Au nque recientemente ha \nhabido alg\u00fan problema con la licencia y parec\u00eda que PHP no incluir\u00eda soporte para MySQL en sus \u00faltimas versiones, MySQL ha hech o una excepci\u00f3n con PHP \n(que sin duda ha contribuido mucho a la popularizaci\u00f3n de MySQL) por el bien de la comunidad y de sus usuarios.\nPrestaciones en \ncreaci\u00f3n de las estructuras (tablas, \u00edndices, etc.)2 MySQL es francamente f\u00e1cil de manejar en este \naspecto, y aunque no ofre ce todas las prestaciones \ncontempladas en el est\u00e1ndar, es \u201csatisfactorio\u201d para la aplicaci\u00f3n que estamos planeando.\nPrestaciones en tipos \nde datos2 Los tipos de datos soportados por MySQL as\u00ed\ncomo los operadores incluidos en el SGBD sonm\u00e1s que suficientes para nuestra aplicaci\u00f3n. \nPrestaciones en \nconsultas simples3 \u00c9sa es precisamente la ca racter\u00edstica que hace que \nMySQL sea uno de los SGBD mejor posicionados.Nota\nMostraremos esta lista en \nforma de tabla, y al final elabo-raremos unas conclusiones. Aunque no realicemos una ponderaci\u00f3n de cada aspecto de la lista anterior, la simple comparaci\u00f3n nos servir\u00e1 para llegar a una conclusi\u00f3n r\u00e1pida.\nClave de valoraci\u00f3n\n\u2022 1: no satisfactorio\n\u2022 2: satisfactorio\u2022 3: muy satisfactorio\uf8e9 FUOC \u2022 71Z799014MO 23 Caso de estudio\nConcepto Valoraci\u00f3n Comentarios\nPrestaciones en \nconsultas complejas2 Hasta hace poco, MySQL no soportaba subconsultas y \nesto implicaba un mayor es fuerzo por parte de los \nprogramadores. Ahora ya las soporta y a un nivel igual al de sus competidores.\nPrestaciones en \nmanipulaci\u00f3n de datos3 MySQL incluye multitud de opciones no est\u00e1ndares \npara cargar datos externos, insertar o actualizar sobre la base de consultas complejas y la utilizaci\u00f3n de operadores como condiciones para la manipulaci\u00f3n.\nFacilidad en la \nadministraci\u00f3n de usuarios3 Soporta muy bien el est\u00e1ndar en cuanto a la creaci\u00f3n \nde usuarios y la gesti\u00f3n de sus privilegios con GRANT y REVOKE. Adem\u00e1s, todos estos datos est\u00e1n accesibles en tablas de sistema,  lo que hace muy sencilla la verificaci\u00f3n de permisos.\nFacilidad en la \ngesti\u00f3n de copias de seguridad3 Disponemos tanto de herram ientas de volcado, como \nla posibilidad de copia binaria de la base de datos. Adem\u00e1s, dada su popularida d varios fabricantes de \nsoluciones de copias de seguridad proporcionan conectores para realizar backups  de la base de \ndatos en caliente.\nConclusi\u00f3n 2,6 Estamos ante un \u201cm\u00e1s que satisfactorio\u201d SGBD \npara la soluci\u00f3n que nos planteamos. No hay ninguna carencia insalvable.\uf8e9 FUOC \u2022 71Z799014MO 24 Caso de estudio\n6. Bases de datos en PostgreSQL\nConcepto Valoraci\u00f3n Comentarios\nModelo de licencia, \nprecio3 La licencia BSD no nos li mita en ning\u00fan aspecto. \nSimplemente tendremos que in cluir la nota sobre la \nmisma en nuestro software, tanto si lo queremos comercializar como si no.\nSoporte por parte \ndel fabricante2 PostgreSQL no ofrece soporte directamente, \naunque s\u00ed que proporciona los mecanismos para que \nla comunidad lo ofrezca (listas de correo, IRC, enlaces, etc.). Tambi\u00e9n tiene una lista (corta) de empresas que ofrecen soporte profesional de PostgreSQL. En Espa\u00f1a \ns\u00f3lo hay una, y no es una empresa de desarrollo de software.\nConexi\u00f3n desde PHP 3 PHP siempre ha incluido soporte para este SGBD, bien \ncon funciones especiales dedicadas que aprovechan al m\u00e1ximo sus caracter\u00edsticas o bien con librer\u00edas PEAR como DB, que nos abstraen del SGBD y que soportan PostgreSQL a la perfecci\u00f3n.\nPrestaciones en \ncreaci\u00f3n de las estructuras (tablas, \u00edndices, etc.)3 PostgreSQL es muy potente en este aspecto, ofrece \npr\u00e1cticamente todas las prestaciones contempladas en el est\u00e1ndar, y tiene un fant\u00e1stico sistema de extensi\u00f3n.\nPrestaciones en tipos \nde datos3 Los tipos de datos soport ados por PostgreSQL, as\u00ed \ncomo los operadores incluidos en el SGBD son m\u00e1s que suficientes para nues tra aplicaci\u00f3n. Adem\u00e1s, \nsu sistema de extensiones y definici\u00f3n de tipos y dominios incluye casi todo  lo que podamos necesitar.\nPrestaciones en \nconsultas simples3 Por supuesto, PostgreSQL no decepciona en este \npunto.\nPrestaciones en \nconsultas complejas3 PostgreSQL ha soportado su bconsultas, vistas y todo \nlo que podamos necesitar en nuestra aplicaci\u00f3n desde hace varios a\u00f1os. Su implementaci\u00f3n de \u00e9stas es ya muy estable.\nPrestaciones en \nmanipulaci\u00f3n de datos3 PostgreSQL incluye multitud de opciones no \nest\u00e1ndares para cargar datos externos, insertar o actualizar sobre la base de consultas complejas y la utilizaci\u00f3n de oper adores como condiciones \npara la manipulaci\u00f3n.\nFacilidad en la \nadministraci\u00f3n de usuarios2 Soporta bastante bien el est\u00e1ndar en cuanto \na la creaci\u00f3n de usuarios y la gesti\u00f3n de sus privilegios con GRANT y REVOKE. Su sistema m\u00faltiple de autenticaci\u00f3n lo hace demasiado complejo en este aspecto.\nFacilidad en la \ngesti\u00f3n de copias de seguridad3 Disponemos tanto de herram ientas de volcado, como \nde la posibilidad de copia bi naria de la base de datos. \nConclusi\u00f3n 2,8 Estamos ante el SGBD casi  ideal. S\u00f3lo le falta facilitar la \ngesti\u00f3n de usuarios y mejorar su soporte.Clave de valoraci\u00f3n\n\u2022 1: no satisfactorio\n\u2022 2: satisfactorio\u2022 3: muy satisfactorio\uf8e9 FUOC \u2022 71Z799014MO 25 Caso de estudio\n7. Desarrollo de aplicaciones en conexi\u00f3n con bases \nde datos\nEn la reuni\u00f3n mantenida con la direcc i\u00f3n se examinaron muy cuidadosamen-\nte los an\u00e1lisis de lo s SGBD seleccionados. Al ser la  diferencia de valoraci\u00f3n tan\nleve, no fue f\u00e1cil tomar una decisi\u00f3n, pe ro al final se decidi\u00f3 la implementa-\nci\u00f3n de la soluci\u00f3n sobre el SGBD PostgreSQL.\nSe decidi\u00f3, tambi\u00e9n, hacer la implem entaci\u00f3n en PHP, abstray\u00e9ndonos del\nSGBD con el que trabaj\u00e1ramos. As\u00ed, en caso de que la mayor dificultad en laadministraci\u00f3n de PostgreSQL nos hiciera rectificar la decisi\u00f3n en el futuro, el\ntiempo de puesta en marcha del cambio ser\u00eda m\u00ednimo.\nAntes de iniciar la implantaci\u00f3n, vamo s a realizar unas pruebas conceptuales\nde la propia implementaci\u00f3n que, desp u\u00e9s, pasaremos a un equipo de desarro-\nllo interno para que haga el resto. En  concreto, tomaremos algunas de las con-\nsultas vistas en el cap\u00edtulo 3 y programaremos los scripts  PHP de las p\u00e1ginas\ncorrespondientes, document\u00e1ndolas al m\u00e1ximo para facilit ar el trabajo al\nequipo de desarrollo.\nEn primer lugar, crearemos un fichero .p hp con la conexi\u00f3n a la base de datos,\npara incluirlo en todos los PHP que lo va yan a necesitar, y evitar, as\u00ed, tener que\nrepetir c\u00f3digo cada vez. Esta acci\u00f3n tambi\u00e9n ayudar\u00e1 a mantener centralizadoslos datos de la conexi\u00f3n y, en caso de que debi\u00e9ramos cambiar el usuario o la\ncontrase\u00f1a o cualquier otro dato de la  conexi\u00f3n, s\u00f3lo tend r\u00edamos que actuali-\nzar dicho fichero. \ndatosconexion.php\n<?php\n// Incluimos la librer\u00eda una vez instalada mediante PEAR\nrequire_once \u2018DB.php\u2019;\n// Creamos la conexi\u00f3n a la base de datos, en este caso PostgreSQL\n$db =& DB::connect(\u2018pgsql://usuario:password@servidor/basededatos \u2019);\n// Comprobamos error en la conexi\u00f3n\nif (DB::isError($db)) {\ndie($db->getMessage());\n}\n?>\uf8e9 FUOC \u2022 71Z799014MO 26 Caso de estudio\na. Nuevo cliente. P\u00e1gina de resultado de la inserci\u00f3n de un nuevo cliente\nc. Cambio de estado de la petici\u00f3n:   <?php\n// Incluimos el fichero con los datos de la conexi\u00f3n.\ninclude_one \u2018datosconexion.php\u2019;\n// Utilizamos el m\u00e9todo quoteSmart() para evitar que determinados caracteres\n// (intencionados o no) puedan romper la sintaxis de la sentencia SQL.\n// El m\u00e9todo insertar\u00e1 autom\u00e1ticamente comillas alrededor de las cadenas\n// de texto, o tratar\u00e1 los valores NULL correctamente seg\u00fan el SGBD, etc.$db->query(\u201cINSERT INTO CLIENTE VALUES (\u201c\n. $db->quoteSmart($_REQUEST[\u2018nombre\u2019]) . \u201c,\u201d\n. $db->quoteSmart($_REQUEST[\u2018dni\u2019]). \u201c,\u201d . $db->quoteSmart($_REQUEST[\u2018telefono\u2019]) . \u201c,\u201d \n. $db->quoteSmart($_REQUEST[\u2018email\u2019]) . \u201c)\u201d);\nif (DB::isError($db)) {\necho \u201c<h2>Error al insertar el cliente</h2>\u201c;\ndie($db->getMessage());\n}  \n$db->disconnect();\n<?php\ninclude_once \u2018datosconexion.php\u2019;\n// Vamos a trabajar con todas las operaciones de esta p\u00e1gina en forma de \n// transacci\u00f3n, ya que, si se produce un error al insertar una nota o un// material, la petici\u00f3n puede quedar en un estado err\u00f3neo.\n$db->autoCommit(false);\n// Le decimos a PHP que almacene en un buffer la salida, para poder as\u00ed\n// rectificar en caso de producirse un error.\nob_start();\n// Suponemos que los estados nos llegan directamente con los valores\n// soportados por el dominio, por ejemplo, a partir de los valores\n// fijos de un desplegable.\n// Suponemos que la fecha de inicio y fecha de fin nos llegan en formato\n// espa\u00f1ol dd/mm/yyyy y los convertimos a YYYY-mm-dd seg\u00fan ISO 8601.\n// Suponemos que el tiempo empleado nos llega en dos campos, horas y minutos, de\n// forma que concaten\u00e1ndolos e insertando un \u201c:\u201d en medio, obtenemos una// hora en formato ISO 8601.\uf8e9 FUOC \u2022 71Z799014MO 27 Caso de estudio\nif (isset($_REQUEST[\u2018fechainicio\u2019]) && !empty($_REQUEST[\u2018fechainicio\u2019])) {\n$fechainicio_array=split(\u201c/\u201d,$_REQUEST[\u2018fechainicio\u2019]);$fechainciioDB=date(\u201cY-M-d\u201d, mktime(0, 0, 0, $fechainicio[1], $fechainicio[0], \n$fechainicio[2]));} else {\n$fechainicioDB=NULL;\n}\nif (isset($_REQUEST[\u2018fechafin\u2019]) && !empty($_REQUEST[\u2018fechafin\u2019])) {\n$fechafin_array=split(\u201c/\u201d,$_REQUEST[\u2018fechafin\u2019]);$fechafinDB=date(\u201cY-M-d\u201d, mktime(0, 0, 0, $fechafin[1], $fechafin[0], $fechafin[2]));\n} else {\n$fechafinDB=NULL;\n}\n$db->query(\u201cUPDATE PETICION SET \u201c\n. \u201ccliente=\u201c . $db->quoteSmart($_REQUEST[\u2018cliente\u2019]) . \u201c,\u201d. \u201cresumen=\u201c . $db->quoteSmart($_REQUEST[\u2018resumen\u2019]) . \u201c,\u201d. \u201cestado=\u201c . $db->quoteSmart($_REQUEST[\u2018estado\u2019]) . \u201c,\u201d. \u201cfechainicio=\u201c . $db->quoteSmart($fechainicioDB) . \u201c,\u201d. \u201cfechafin\u201d . $db->quoteSmart($fechafinDB) . \u201c,\u201d. \u201ctiempoempleado=\u201c  . $db->quoteSmart($_REQUEST[\u2018hora\u2019] . \u201c:\u201d . $_REQUEST[\u2018minutos\u2019]));\nif (DB::isError($db)) {\necho \u201c<h2>Error al insertar el cliente</h2>\u201c;ob_flush();die($db->getMessage());\n} else {\necho \u201c<h2>Petici\u00f3n actualizada correctamente</h2>\u201c;\n}\n// Comprobamos si han a\u00f1adido alguna nota\nif (isset($_REQUEST[\u2018texto_nota\u2019]) && !empty($_REQUEST[\u2018texto_nota\u2019])) {\n// Tenemos el identificador de petici\u00f3n en $_REQUEST[\u2018referencia\u2019]$db->query(\u201cINSERT INTO NOTA_PETICION VALUES (\u201c. $db->quoteSmart($_REQUEST[\u2018referencia\u2019]) . \u201c,\u201d . $db->quoteSmart($_REQUEST[\u2018texto_nota\u2019]) . \u201c,\u201d . $db->quoteSmart(date(\u201cY-M-d\u201d,mktime())) . \u201c,\u201d. $db->quoteSmart($_REQUEST[\u2018nifEmpleado\u2019]) . \u201c)\u201d);if (DB::isError($db)) {\nob_clean();echo \u201c<h2>Error al insertar la nota. Datos de la petici\u00f3n no actualizados</h2>\u201c;ob_flush();$db->rollback();die($db->getMessage());\n} else {\necho \u201c<h3>Nota actualizada correctamente</h2>\u201c;\n}\n} \uf8e9 FUOC \u2022 71Z799014MO 28 Caso de estudio\nf. y g. Peticiones abiertas de un clie nte y resumen de los materiales usados \nen cada una  // Comprobamos si han a\u00f1adido alg\u00fan material+\nif (isset($_REQUEST[\u2018nombrematerial\u2019]) && !empty($_REQUEST[\u2018nombrematerial\u2019])) {\n// Tenemos el identificador de la petici\u00f3n en $_REQUEST[\u2018referencia\u2019]$db->query(\u201cINSERT INTO MATERIAL_PETICION VALUES \u201c\n. $db->quoteSmart($_REQUEST[\u2018nombrematerial\u2019]) . \u201c,\u201d\n. $db->quoteSmart($_REQUEST[\u2018referencia\u2019]) . \u201c,\u201d. $db->quoteSmart($_REQUEST[\u2018precio\u2019]) . \u201c,\u201d\n. $db->quoteSmart($_REQUEST[\u2018cantidad\u2019]) . \u201c)\u201d);\nif (DB::isError($db)) {\nob_clean();\necho \u201c<h2>Error al insertar el material. Datos de la petici\u00f3n no actualizados</h2>\u201c;\nob_flush();\n$db->rollback();\ndie($db->getMessage());\n} else {\necho \u201c<h3>Material actualizado correctamente</h2>\u201c;\n}\n}\n$db->commit();\n$ob_flush();\n$db->disconnect();\n?>\n<?phpinclude_once \u2018datosconexion.php\u2019;\n// Buscamos las peticiones abiertas de un cliente\n$res=$db->query(\u201cSELECT P.referencia, P.resumen, P.estado, P.fecharecepcion FROM \nPETICION P JOIN CLIENTE C ON P.cliente=C.nif WHERE ESTADO NOT IN (\u2018Resuelta\u2019,\n\u2019Cerrada\u2019) ORDER BY fecharecepcion\u201d);\nif (DB::isError($db)) {\ndie($db->getMessage());\n} \n// Antes de empezar la iteraci\u00f3n por las peticiones, vamos a preparar la consulta\n// correspondiente a los materiales empleados en cada una.\n$queryMaterial=$db->prepare(\u201cSELECT SUM(M.precio) as precioMateriales, \nCOUNT(M.nombrematerial) numMateriales FROM MATERIAL_PETICION M WHERE M.peticion=? \u201c);\nif (DB::isError($db)) {\ndie($db->getMessage());\n} \uf8e9 FUOC \u2022 71Z799014MO 29 Caso de estudio\nMediante estos tres ejemplos, disponemos ya de una base tanto de c\u00f3digo,\ncomo de estilo y mecanismos de comp robaci\u00f3n de error,  para desarrollar el\nresto de la aplicaci\u00f3n, sin tener en cuenta su dise\u00f1o.\nHemos intentado escoger consultas y op eraciones representativas del funcio-\nnamiento de la aplicaci\u00f3n y, a la vez, que se correspondieran con las vistas en\napartados anteriores. Adem\u00e1s, hemos introducido algunas funciones PHP quesuelen utilizarse en combinaci\u00f3n con el  trabajo en bases de datos para tipos\nconcretos, y para el tratamiento de errore s, para evitar que el usuario reciba in-\nformaci\u00f3n confusa en la p\u00e1gina de resultados.echo \u201c<table>\u201c;\necho \u201c<tr><th>Referencia</th><th>Resumen</th><th>Estado</th><th>Duraci\u00f3n</th><th>\nFecharecepci\u00f3n</th><th>Precio materiales</th><th>N\u00fam. materiales</th></tr>\u201c;while($res->fetchInto($row,DB_FETCHMODE_ASSOC)) {\necho \u201c<tr>\u201c;\necho \u201c<td>\u201c . $row[\u2018referencia\u2019] . \u201c</td>\u201c;echo \u201c<td>\u201c . $row[\u2018resumen\u2019] . \u201c</td>\u201c;\necho \u201c<td>\u201c . $row[\u2018estado\u2019] . \u201c</td>\u201c;\necho \u201c<td>\u201c . $row[\u2018fecharecepcion\u2019] . \u201c</td>\u201c;$resMaterial=$db->execute($queryMaterial,$row[\u2018referencia\u2019]);\nif (DB::isError($db)) {\ndie($db->getMessage());\n} else {\n$res->fetchInto($rowMaterial,DB_FETCHMODE_ASSOC);echo \u201c<td>\u201c . $rowMaterial[\u2018precioMateriales\u2019] . \u201c</td>\u201c;\necho \u201c<td>\u201c . $rowMaterial[\u2018numMateriales\u2019] . \u201c</td>\u201c;\n}echo \u201c</tr>\u201c;\n}\necho \u201c</table>\u201c;\n?>\uf8e9 FUOC \u2022 71Z799014MO 30 Caso de estudio\nResumen\nEn esta unidad hemos visto las actividade s m\u00e1s destacadas de las fases iniciales\nde un proyecto de desarrollo con conexi\u00f3n a bases de datos.\nM\u00e1s que resolver el propio caso, se trat aba de identificar los aspectos clave de\nlos casos reales y enlazarlos con el co ntenido del resto de unidades del curso.\nHabr\u00e9is podido identificar qu\u00e9 actividade s son m\u00e1s relevantes para el resulta-\ndo final del proyecto, en cu\u00e1les conviene  invertir m\u00e1s tiempo y cu\u00e1les no son\ntan cr\u00edticas para los objetivos de \u00e9ste u otro caso similar. \nSi hab\u00e9is seguido la planif icaci\u00f3n sugerida y repasado cada unidad a la que que\nse hac\u00eda referencia, habr\u00e9is podido comp render la aplicaci\u00f3n pr\u00e1ctica del ma-\nterial y se habr\u00e1n alcanzado los objetivos que nos propon\u00edamos al redactar esta\nunidad did\u00e1ctica.\nTambi\u00e9n es posible leer este caso de es tudio como un cap\u00edtulo final del curso,\ndonde se desarrolla un ejemplo completo. Se ha intentado redactarlo con\neste doble cometido.Ap\u00e9ndice:GNU Free\nDocumentationLicense\nAp\u00e9ndice:GNU FreeDocumentationLicense\uf8e9 FUOC \u2022 71Z799014MO 3 Ap\u00e9ndice: GNU Free Documentation License\nGNU Free Documentation License\n  Version 1.2, November 2002\n Copyright (C) 2000,2001,2002  Fr ee Software Foundation, Inc.\n     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n Everyone is permitted to copy  and distribute verbatim copies\n of this license document, but changing it is not allowed.\n0. PREAMBLE\nThe purpose of this License is to make a manual, textbook, or other\nfunctional and useful document \"free\"  in the sense of freedom: to assure\neveryone the effective freedom to copy and redistribute it , with or without\nmodifying it, either commercially or  noncommercially. Secondarily, this\nLicense preserves for the au thor and publisher a way to get credit for their\nwork, while not being considered responsible for modifications made byothers.\nThis License is a kind of \"copyleft\", wh ich means that derivative works of the\ndocument must themselves be free in the same sense.  It complements the\nGNU General Public License, which is a copyleft license designed for free\nsoftware. We have designed this Licens e in order to use it for manuals for\nfree software, because free software needs free documentation: a free\nprogram should come with manuals providing the same freedoms that thesoftware does.  But this License is not limited to software manuals; it can beused for any textual work, regardless of subject matter or whether it ispublished as a printed book.  We re commend this License principally for\nworks whose purpose is instruction or reference.\n1. APPLICABILITY AND DEFINITIONS\nThis License applies to any manual or other work, in any medium, that\ncontains a notice placed by the copyrigh t holder saying it can be distributed\nunder the terms of this License.  Such  a notice grants a world-wide, royalty-\nfree license, unlimited in  duration, to use that work under the conditionsGNU Free Documentation License\uf8e9 FUOC \u2022 71Z799014MO 4 Ap\u00e9ndice: GNU Free Documentation License\nstated herein.  The \"Document\", below, refers to any such manual or work.\nAny member of the public is a licens ee, and is addressed as \"you\".  You\naccept the license if you copy, modify  or distribute the work in a way\nrequiring permission under copyright law.\nA \"Modified Version\" of the Document means any work containing the\nDocument or a portion of it, either co pied verbatim, or with modifications\nand/or translated into another language.\nA \"Secondary Section\" is a named appendix or a front-matter section of the\nDocument that deals exclus ively with the relationsh ip of the publishers or\nauthors of the Document to the Document's overal l subject (or to related\nmatters) and contains nothin g that could fall directly within that overall\nsubject.  (Thus, if the Document is in part a textbook of mathematics, a\nSecondary Section may not explain any ma thematics.)  The relationship could\nbe a matter of historical connection with  the subject or with related matters, or\nof legal, commercial, philosophical, ethical or political position regarding\nthem.\nThe \"Invariant Sections\" are certain Secondary Sections whose titles are\ndesignated, as being those of Invariant Sections, in the notice that says that\nthe Document is released under this License.  If a section does not fit theabove definition of Secondary then it is not allowed to be designated as\nInvariant.  The Document may contai n zero Invariant Sec tions.  If the\nDocument does not identify any Inva riant Sections then  there are none.\nThe \"Cover Texts\" are certain short pa ssages of text that are listed, as\nFront-Cover Texts or Back-C over Texts, in the notice that says that the\nDocument is released under this Lice nse.  A Front-Cover Text may be at\nmost 5 words, and a Back-Cover Text may be at most 25 words.\nA \"Transparent\" copy of the Docume nt means a machine-readable copy,\nrepresented in a format whose specification is available to the general\npublic, that is suitable for revising  the document straightforwardly with\ngeneric text editors or (for images composed of pixels) generic paint\nprograms or (for drawings) some wide ly available drawing editor, and that\nis suitable for input to text formatters or for automatic translation to a variety\nof formats suitable for input to text fo rmatters.  A copy made in an otherwise\nTransparent file format whose mark up, or absence of markup, has been\narranged to thwart or discourage subs equent modification by readers is not\nTransparent.\uf8e9 FUOC \u2022 71Z799014MO 5 Ap\u00e9ndice: GNU Free Documentation License\nAn image format is not Transparent if used for any substantial amount of\ntext.  A copy that is not \"Tra nsparent\" is called \"Opaque\".\nExamples of suitable formats for Transparent copies include plain ASCII\nwithout markup, Texinfo input format , LaTeX input format, SGML or XML\nusing a publicly available DTD, an d standard-conforming simple HTML,\nPostScript or PDF designed for human modification.  Examples of\ntransparent image formats include PNG, XCF and JPG.  Opaque formats\ninclude proprietary formats that can be read and edited only by proprietary\nword processors, SGML or XML for which the DTD and/or processing tools\nare not generally available, and th e machine-generate d HTML, PostScript\nor PDF produced by some word proc essors for output purposes only.\nThe \"Title Page\" means, for a printed book, the title page  itself, plus such\nfollowing pages as are needed to hold , legibly, the material this License\nrequires to appear in the title page.  For works in formats which do not have\nany title page as such, \"Title Page\" means the text near the most prominent\nappearance of the work's title, preceding the beginn ing of the body of the\ntext.\nA section \"Entitled XYZ\" means a named subunit of the Document whose title\neither is precisely XYZ or contains XYZ in parentheses following text that\ntranslates XYZ in another language.  (Here XYZ stands for a specific section\nname mentioned below, such as \"Acknowledgements\", \"Dedications\",\n\"Endorsements\", or \"History\".)  To \"Preserve the Title\" of such a section when\nyou modify the Document means that it remains a section \"Entitled XYZ\"\naccording to this definition.\nThe Document may include Warranty Disclaimers next  to the notice which\nstates that this License applies to the Document.  These Warranty\nDisclaimers are considered to be includ ed by reference in this License, but\nonly as regards disclaiming warranties: any other implication that these\nWarranty Disclaimers may have is void and has no effect on the meaning\nof this License.\n2. VERBATIM COPYING\nYou may copy and distribute the Document in any medium, either\ncommercially or noncommerc ially, provided that this License, the copyright\nnotices, and the license notice saying  this License applies to the Document\nare reproduced in all copies, and that you add no other conditions\uf8e9 FUOC \u2022 71Z799014MO 6 Ap\u00e9ndice: GNU Free Documentation License\nwhatsoever to those of this License.  You may not use technical measures to\nobstruct or control the reading or further copying of the copies you make ordistribute.  However, you may accept compensation in exchange for copies.If you distribute a large enough number  of copies you must also follow the\nconditions in section 3.\nYou may also lend copies, under the sa me conditions stated above, and you\nmay publicly display copies.\n3. COPYING IN QUANTITY\nIf you publish printed copies (or co pies in media that commonly have\nprinted covers) of the Document, numbering more than 100, and the\nDocument's license notice requires Cover Texts, yo u must enclose the copies\nin covers that carry, clearly and legi bly, all these Cover Texts: Front-Cover\nTexts on the front cover, and Back-Cov er Texts on the back cover.  Both\ncovers must also clearly and legibly id entify you as the publisher of these\ncopies.  The front cover mu st present the full title wi th all words of the title\nequally prominent and visible.  You may add other material on the covers\nin addition.\nCopying with changes limite d to the covers, as long as they preserve the title\nof the Document and satisfy these co nditions, can be treated as verbatim\ncopying in other respects.\nIf the required texts for either cover are too voluminous to fit legibly, you\nshould put the first ones listed (as many as fit reasonably) on the actualcover, and continue the rest onto adjacent pages.\nIf you publish or distribute Opaque  copies of the Document numbering\nmore than 100, you must  either include a machin e-readable Transparent\ncopy along with each Opaque copy, or  state in or with each Opaque copy\na computer-network locati on from which the general network-using public\nhas access to download using public-standard network protocols a\ncomplete Transparent copy of the Document, free of added material.\nIf you use the latter option, you must  take reasonably prudent steps, when\nyou begin distribution of Opaque copi es in quantity, to ensure that this\nTransparent copy will remain thus accessible at the stated location until atleast one year after the last time you di stribute an Opaque copy (directly or\nthrough your agents or retailers) of that edition to the public.\uf8e9 FUOC \u2022 71Z799014MO 7 Ap\u00e9ndice: GNU Free Documentation License\nIt is requested, but not required, th at you contact the authors of the\nDocument well before redistributing any large number of copies, to give\nthem a chance to provide you with an updated version of the Document.\n4. MODIFICATIONS\nYou may copy and distribute a Modified  Version of the Document under the\nconditions of sections 2 and 3 above, provided that you release the\nModified Version under precisely this License, with the Modified Version\nfilling the role of the Document, thus licensing distributi on and modification\nof the Modified Version to whoever possesses a copy of it.  In addition, youmust do these things in the Modified Version:\nA. Use in the Title Page (and on the co vers, if any) a title distinct from that\nof the Document, and from those of prev ious versions (which should, if there\nwere any, be listed in the History se ction of the Document).  You may use\nthe same title as a previous version if the original publisher of that version\ngives permission.\nB. List on the Title Page, as authors, one or more persons or entities\nresponsible for authorship of the mo difications in the Modified Version,\ntogether with at least five of the principal authors of the Document (all of itsprincipal authors, if it has fewer than five), unless they release you from thisrequirement.\nC. State on the Title page the name of  the publisher of the Modified Version,\nas the publisher.\nD. Preserve all the copyrigh t notices of the Document.\nE. Add an appropriate co pyright notice for your modifications adjacent to\nthe other copyright notices.\nF. Include, immediately after the copy right notices, a license notice giving\nthe public permission to use the Modi fied Version under the terms of this\nLicense, in the form show n in the Addendum below.\nG. Preserve in that license notice th e full lists of Invariant Sections and\nrequired Cover Texts given in the Document's license notice.\nH. Include an unaltered copy of this License.\uf8e9 FUOC \u2022 71Z799014MO 8 Ap\u00e9ndice: GNU Free Documentation License\nI. Preserve the section Entitled \"History \", Preserve its Title, and add to it an\nitem stating at least the title, year,  new authors, and publisher of the\nModified Version as given on the Title Page.  If there is no section Entitled\n\"History\" in the Document, create one stating the title, year, authors, and\npublisher of the Document  as given on its Title Page, then add an item\ndescribing the Modified Version as stated in the previous sentence.\nJ. Preserve the network lo cation, if any, given in the Document for public\naccess to a Transparent copy of the Document, and likewise the networklocations given in the Document for previous versions it was based on.\nThese may be placed in the \"History \" section. You may omit a network\nlocation for a work that was published at least four years before theDocument itself, or if the original publ isher of the version it refers to gives\npermission.\nK. For any section Entitl ed \"Acknowledgements\" or  \"Dedications\", Preserve\nthe Title of the section, and preserve in the sect ion all the substance and\ntone of each of the contributor ackn owledgements and/or dedications given\ntherein.\nL. Preserve all the Invari ant Sections of the Document , unaltered in their text\nand in their titles.  Sec tion numbers or the equi valent are not considered\npart of the section titles.\nM. Delete any section Entitled \"Endor sements\".  Such a section may not be\nincluded in the Modified Version.\nN. Do not retitle any existing section to be Entitled \"Endorsements\" or to\nconflict in title with any Invariant Section.\nO. Preserve any Wa rranty Disclaimers.\nIf the Modified Version includes new front-matter sections or appendices\nthat qualify as Secondary Sections and contain no material  copied from the\nDocument, you may at your  option designate some or all of these sections\nas invariant.  To do this, add their titles  to the list of Invariant Sections in the\nModified Version's license notice. These ti tles must be distinct from any other\nsection titles.\nYou may add a section Entitled \"End orsements\", provided it contains\nnothing but endorsements of your Modified Versio n by various parties--for\uf8e9 FUOC \u2022 71Z799014MO 9 Ap\u00e9ndice: GNU Free Documentation License\nexample, statements of p eer review or that the te xt has been approved by\nan organization as the authoritative definition of a standard.\nYou may add a passage of up to five  words as a Front-Cover Text, and a\npassage of up to 25 words as a Back-Cover Text, to the end of the list of\nCover Texts in the Modified Version.  Only one passage of Front-Cover Text\nand one of Back-Cover Text may be  added by (or th rough arrangements\nmade by) any one entity.  If the Docume nt already includes a cover text for\nthe same cover, previously added by you or by arrangement made by the\nsame entity you are acting on behalf  of, you may not add another; but you\nmay replace the old one, on explicit pe rmission from the previous publisher\nthat added the old one.\nThe author(s) and publisher( s) of the Document do not by this License give\npermission to use their names for pu blicity for or to assert or imply\nendorsement of any Modified Version.\n5. COMBINING DOCUMENTS\nYou may combine the Document with other documents released under this\nLicense, under the terms defined in se ction 4 above for modified versions,\nprovided that you include in the combination all of the Invariant Sections of\nall of the original documents, unmodified, and list them all as InvariantSections of your combined work in it s license notice, and that you preserve\nall their Warranty Disclaimers.\nThe combined work need only contain one copy of this License, and\nmultiple identical Invarian t Sections may be replaced with a single copy.  If\nthere are multiple Invari ant Sections with the sa me name but different\ncontents, make the title of each such section unique by adding at the end of\nit, in parentheses, the name of the original author or publisher of that\nsection if known, or else a unique number.\nMake the same adjustment to  the section titles in the list of Invariant Sections\nin the license notice of the combined work.\nIn the combination, you must combine an y sections Entitled  \"History\" in the\nvarious original documents, forming on e section Entitled \"History\"; likewise\ncombine any sections Entitled \"A cknowledgements\", and any sections\nEntitled \"Dedications\".  You must delete  all sections Entitl ed \"Endorsements\".\uf8e9 FUOC \u2022 71Z799014MO 10 Ap\u00e9ndice: GNU Free Documentation License\n6. COLLECTIONS OF DOCUMENTS\nYou may make a collection consisting of the Document and other\ndocuments released under this License,  and replace the individual copies of\nthis License in the various documents with a single copy that is included inthe collection, provided that you follow the rules of this License for verbatimcopying of each of the documents in all other respects.\nYou may extract a single document from such a collection, and distribute it\nindividually under this License, provid ed you insert a copy of this License\ninto the extracted docume nt, and follow this License in all other respects\nregarding verbatim copying of that document.\n7. AGGREGATION WITH INDEPENDENT WORKS\nA compilation of the Document or its derivatives with other separate and\nindependent documents or works, in or on a volume of a storage ordistribution medium, is ca lled an \"aggregate\" if th e copyright resulting from\nthe compilation is not used to limit the legal rights of the compilation's users\nbeyond what the individual works permit.\nWhen the Document is included in an  aggregate, this License does not\napply to the other works in the aggregate which are not themselves\nderivative works of the Document.\nIf the Cover Text requirement of sectio n 3 is applicable to these copies of\nthe Document, then if the Document is  less than one half of the entire\naggregate, the Document's Cover Te xts may be placed on covers that\nbracket the Document within  the aggregate, or the electronic equivalent of\ncovers if the Document is in electronic form.\nOtherwise they must appear on prin ted covers that bracket the whole\naggregate.\n8. TRANSLATION\nTranslation is considered a kind of  modification, so you may distribute\ntranslations of the Document under the terms of section 4. ReplacingInvariant Sections with translations re quires special perm ission from their\uf8e9 FUOC \u2022 71Z799014MO 11 Ap\u00e9ndice: GNU Free Documentation License\ncopyright holders, but you may include tr anslations of some or all Invariant\nSections in addition to the original vers ions of thes e Invariant Sections.  You\nmay include a translation of this License, and all the license notices in theDocument, and any Warranty Disclaimers, provided that you also include\nthe original English version of this Lice nse and the original versions of those\nnotices and disclaimers.  In case of a disagreemen t between the translation\nand the original version of this License or a notice or disclaimer, the original\nversion will prevail.\nIf a section in the Document is Enti tled \"Acknowledgements\", \"Dedications\",\nor \"History\", the requiremen t (section 4) to Preserve its Title (section 1) will\ntypically require changing the actual title.\n9. TERMINATION\nYou may not copy, modify, sublicense, or  distribute the Document except as\nexpressly provided for under this Licens e. Any other attempt to copy, modify,\nsublicense or distribute the Docu ment is void, and will automatically\nterminate your rights under this License. However, parties who have\nreceived copies, or rights, from you un der this License will not have their\nlicenses terminated so long as such  parties remain in full compliance.\n10. FUTURE REVISIONS OF THIS LICENSE\nThe Free Software Foundati on may publish new, revised versions of the\nGNU Free Documentation License from time to time.  Such new versions will\nbe similar in spirit to the present versio n, but may differ in  detail to address\nnew problems or concerns.  See http://www.gnu.org/copyleft/.\nEach version of the License is given a distinguishing version number. If the\nDocument specifies that a particular numbered version of this License \"or\nany later version\" applies to it, you ha ve the option of following the terms\nand conditions either of that specified version or of any la ter version that has\nbeen published (not as a draft) by the Free Software Foundation.  If the\nDocument does not specify a version number of this License, you may\nchoose any version ever published (not  as a draft) by the Free Software\nFoundation.\uf8e9 FUOC \u2022 71Z799014MO 12 Ap\u00e9ndice: GNU Free Documentation License\nADDENDUM: How to use this License for your documents\nTo use this License in a document you have written, include a copy of the\nLicense in the document and put the fo llowing copyright an d license notices\njust after the title page:\nCopyright (c)  YEAR  YOUR NAME.\n    Permission is granted to copy, distribute and/or modify this document\nunder the terms of the GNU Free Docu mentation License, Version 1.2 or\nany later version published by the Free Software Foundation; with no\nInvariant Sections, no Front-Cover Texts, and no Back-Cover Texts.\n    A  c o p y  o f  t h e  l i c e n s e  i s  i n c l u d ed in the section entitled \"GNU Free\nDocumentation License\".\nIf you have Invariant Sec tions, Front-Cover Texts and Back-Cover Texts,\nreplace the \"with...Texts.\" line with this:\nwith the Invariant Section s being LIST THEIR TITLES , with the Front-Cover\nTexts being LIST, and with the Back-Cover Texts being LIST.\nIf you have Inva riant Sections without Cover Texts, or some other\ncombination of the three, merge those two alternatives to suit the situation.\nIf your document contains nontrivial examples of program code, we\nrecommend releasing these examples in para llel under your choice of free\nsoftware license, such as the GNU Gene ral Public License, to permit their\nuse in free software.U\nFormaci\u00f3n de PosgradoLa universidadvirtual", "language": "PDF", "image": "PDF", "pagetype": "PDF", "links": "PDF"}