{"title": "PDF", "author": "PDF", "url": "http://biblioteca.usbbog.edu.co:8080/Biblioteca/BDigital/72724.pdf", "hostname": "PDF", "description": "PDF", "sitename": "PDF", "date": "PDF", "id": "PDF", "license": "PDF", "body": "PDF", "comments": "PDF", "commentsbody": "PDF", "raw_text": "PDF", "text": " \n RAE  \n1. TIPO DE DOCUMENTO: TRABAJO DE GRADO  \n2. TITULO:  DESARROLLO DE UN CONTROLADOR MIDI NO CONVENCIONAL, \nIMPLEMENTADO EN UN SISTEMA EMBEBIDO, UTILIZANDO EL KINECT.  \n3. AUTOR:  ANDR\u00c9 S CABALLERO PAZ  \n4. LUGAR:  BOGOT \u00c1 \n5. FECHA:  ENERO 17 DE 2013  \n6. PALABRAS CLAVES:  SISTEMAS EMBEBI DOS, DSP, LINUX, UBUNTU, PURE \nDATA, KINECT, INNOVACI\u00d3N.  \n7. DESCRIPCION DEL TRABAJO: El documento presenta el desarrollo de un \ncontrolador MIDI no convencional implementado en un Sistema Embebido \nutilizando el Kinect. El dispositivo permite utilizar el protoco lo MIDI para controlar \nhardware y/o software remoto v\u00eda WiFi por medio de la captura de movimientos. \nCon la utilizaci\u00f3n de este tipo herramientas tecnol\u00f3gicas se puede construir \ncontroladores no convencionales aplicados a la ingenier\u00eda de sonido, integrabl es a \ndiferentes redes de comunicaci\u00f3n de forma pr\u00e1ctica, eficaz e innovadora.  \n8. LINEA DE INVESTIGACION:  AN\u00c1LISIS Y PROCESAMIENTO DE SE\u00d1ALES . \n9. FUENTES CONSULTADAS :  \n1. Abbott, Doug. Linux for Embedded and Real -Time Application. Newnes. 2003 . \n2. Webb, Jarrett - Ashley, James. Beginning Kinect Programming with the Microsoft \nKinect SDK. Apress, 2012  \n10. CONTENIDOS:   INTRODUCCI\u00d3N, PLANTEAMIENTO DEL PROBLEMA, \nMETODOLOG\u00cdA, L\u00cdNEA D E INVESTIGACI\u00d3N, MARCO TE\u00d3RICO, \nDESARROLLO INGENIERIL, AN\u00c1LISIS DE RESULTADOS, CONCLUSIONES , \nPRODUCTOS, RECOMENDACIONES, BIBLIOGRAF\u00cdA, GLOSARIO, ANEXOS . \n11. METODOLOGIA:  EMP\u00cdRICO -ANAL\u00cdTICA  \n12. CONCLUSIONES:  El docum ento presenta el dise\u00f1o y desarrollo de un controlador \nMIDI no convencional utilizando el Kinect, implementado en el Sistema Embebido \nPandaboard ES. En el S.E. se implement\u00f3 la distribuci\u00f3n de Ubuntu, la cual \npermite la instalaci\u00f3n y configuraci\u00f3n de los p rogramas y servicios con los cuales \nse realiza la transmisi\u00f3n de los datos en protocolo MIDI a un computador fijo \nadquiriendo los datos a partir de movimientos capturados por el Kinect.  \n   \n DESARROLLO DE UN CONTROLADOR MIDI NO CONVENCIONAL, \nIMPL EMENTADO EN UN SISTEMA EMBEBIDO, UTILIZANDO EL KINECT.  \n \n \n \n \n \n \n \n \nANDR\u00c9S CABALLERO PAZ  \n \n \n \n \n \n \n \n \n \n \nUNIVERSIDAD DE SAN BUENAVENTURA  \nFACULTAD DE INGENIER\u00cdA  \nINGENIER\u00cdA DE SONIDO  \nBOGOT\u00c1  \n2012   \n DESARROLLO DE UN CONTROLADOR MIDI NO CONVENCIONAL, \nIMPLEMENTADO EN UN SIST EMA EMBEBIDO, UTILIZANDO EL KINECT.  \n \n \n \n \nANDR\u00c9S CABALLERO PAZ  \n \n \n \n \nTrabajo de Grado  para optar al t\u00edtulo de Ingeniero de Sonido  \n \n \n \n \nDirector  \nIng. NELSON FELIPE ROSAS JIM\u00c9NEZ., MSc.  \n \n \n \n \n \n \nUNIVERSIDAD DE SAN BUENAVENTURA  \nFACULTAD DE INGENIER\u00cdA  \nINGENIER\u00cdA DE SO NIDO  \nBOGOT\u00c1  \n2012   \n Nota de aceptaci\u00f3n:  \n__________________________________________________________________\n__________________________________________________________________\n__________________________________________________________________\n____________________ ______________________________________________\n__________________________________________________________________\n_______________________________________________________  \n \n \n \n \n \n \n \n \n \n_____________________________  \nPresidente del Jurado  \n \n \n \n \n \n______________________ _______  \nJurado  \n \n \n \n \n \n_____________________________  \nJurado  \n \n \n \n \n \n \nCiudad y fecha (dd/mes/a\u00f1o)      __________,___/____/________   \n  \n \n\"A mis padres y  a mi hermano, V\u00edctor Andr\u00e9s, Adriana y Felipe\"  \n\u201cA mi novia, Kelly\u201d  \nEste trabajo ha sido posible gracias a ellos  \n \n \n \n   \n Agradecimientos  \n \n \n \nA mi profesor y director de tesis Nelson Rosas Jim\u00e9nez, por su apoyo \nincondicional, confianza y orientaci\u00f3n a lo largo del proyecto.  \n \nA mis amigos Andr\u00e9s Alonso y Juan Carlos S\u00e1nchez, quienes aportaron directa o \nindirectamente en est e proceso y estuvieron presentes a lo largo del mismo.  \n \nA mis compa\u00f1eros de tr abajo y amigos Katherine Garc\u00eda, Nicol\u00e1s Calder\u00f3n , \nJohanna Gait\u00e1n , Mar\u00eda Fernanda Bosc\u00e1n y Andrea Gualtero, por ser un apoyo a lo \nlargo de la carrera.  \n \nPor \u00faltimo pero  a las pers onas m\u00e1s importantes en mi vida, mis padres V\u00edctor \nAndr\u00e9s  y Adriana, mi hermano Felipe  y mi novia Kelly , gracias por su  amor,  \ncomprensi\u00f3n y paciencia en los momentos m\u00e1s complicados, por hacer parte de \nmi vida en esta etapa que finaliza.  \n \n \n \n \n \n   \n Tabla de C ontenido  \n \nINTRODUCCI\u00d3N  ................................ ................................ ................................ ... 12 \n1. PLANTEAMIENTO DEL PROBLEMA  ................................ .............................  14 \n1.1.  ANTECEDEN TES ................................ ................................ .....................  14 \n1.2.  DESCRIPCI\u00d3N Y FORMULACI\u00d3N DEL PROBLEMA  .............................  20 \n1.3.  JUSTIFICACI\u00d3N  ................................ ................................ .......................  20 \n1.4.  OBJETIVOS  ................................ ................................ ..............................  21 \n1.4.1.  Objetivo General  ................................ ................................ ................  21 \n1.4.2.  Objetivos Espec\u00edficos  ................................ ................................ .........  21 \n1.5.  ALCANCES Y LIMITACIONES  ................................ ................................ . 21 \n1.5.1.  Alcances  ................................ ................................ .............................  21 \n1.5.2.  Limitaciones  ................................ ................................ .......................  21 \n2. METODOLOG\u00cdA  ................................ ................................ ..............................  22 \n2.1.  ENFOQUE DE LA INVESTIGACI\u00d3N  ................................ ........................  22 \n2.2.  HIP\u00d3TESIS  ................................ ................................ ...............................  22 \n2.3.  VARIABLES  ................................ ................................ ..............................  22 \n2.3.1.  Independientes  ................................ ................................ ...................  22 \n2.3.2.  Dependientes  ................................ ................................ .....................  23 \n3. L\u00cdNEA DE INVESTIGACI\u00d3N DE LA UNIVERSIDAD/ SUB -L\u00cdNEA DE LA \nFACULTAD/ CAMPO TEM\u00c1TICO DEL PROGRAMA  ................................ ............  23 \n4. MARCO TE\u00d3RICO  ................................ ................................ ..........................  24 \n4.1.  Controlador MIDI ................................ ................................ .......................  24 \n4.1.1.  Bytes MIDI  ................................ ................................ ..........................  26 \n4.1.2.  Mensaje de Nota On/Off  ................................ ................................ ..... 27 \n4.1.3.  Mensaje de Cambio de Programa  ................................ ......................  27 \n4.1.4.  Mensaje de Cambio de Control  ................................ ..........................  27 \n4.2.  Kinect  ................................ ................................ ................................ ........  28 \n4.2.1.  Componentes y Funcionamiento  ................................ ........................  29 \n4.2.2.  Controladores  ................................ ................................ .....................  31  \n 4.2.2. 1. Open Kinect  ................................ ................................ .................  31 \n4.3.  Sistemas de Transmisi\u00f3n Inal\u00e1mbrica  ................................ ......................  32 \n4.3.1.  Redes Inal\u00e1mbricas  ................................ ................................ ............  32 \n4.3.2.  Transmisor MIDI: QmidiNet  ................................ ................................  34 \n4.4.  Sistemas Embebidos  ................................ ................................ ................  35 \n4.4.1.  Software  ................................ ................................ .............................  36 \n4.5.  Pure Data  ................................ ................................ ................................ .. 37 \n5. DESARROLLO INGENIERIL  ................................ ................................ ...........  39 \n5.1.  Adecuaci\u00f3n S.E.  ................................ ................................ .......................  39 \n5.1.1  Compilaci\u00f3n Sistema Operativo  ................................ .........................  41 \n5.1.1.1.  Compilaci\u00f3n Paso -a-Paso  ................................ ...........................  42 \n5.1.1.2.  Imag en Pre -Compilada  ................................ ................................  44 \n5.1.1  Interfaces Graficas de Ubuntu  ................................ ............................  45 \n5.1.1.1  XFCE  ................................ ................................ ...........................  46 \n5.1.1.2  KDE ................................ ................................ .............................  46 \n5.1.1.3  Gnome  ................................ ................................ .........................  47 \n5.1.1.4  LXDE  ................................ ................................ ...........................  48 \n5.1.1.5  Unity ................................ ................................ ............................  49 \n5.1.2  Sistemas Embebidos Implementados  ................................ ................  50 \n5.1.2.1  Beagleboard C3  ................................ ................................ ...........  50 \n5.1.2.2  Beagleboard xM  ................................ ................................ ...........  52 \n5.1.2.3  Pandaboard ES  ................................ ................................ ...........  54 \n5.2.  Transmisi\u00f3n mensajes MIDI por WLAN  ................................ ....................  56 \n5.2.1.  Configuraci\u00f3n Router para una Red Local Inal\u00e1mbrica (WLAN)  ........  57 \n5.2.2.  Configuraci\u00f3n de Red en Ubuntu  ................................ .......................  58 \n5.2.3.  Codificaci\u00f3n y env\u00edo de MIDI por UDP/IP Multicast  ............................  60 \n5.2.4.  Implementaci\u00f3n y Pruebas Transmisor MIDI QmidiNet  ......................  60 \n5.3.  Integraci\u00f3n Kinect  ................................ ................................ .....................  62 \n5.3.1.  Compilaci\u00f3n Pure Data Extended  ................................ ......................  62 \n5.3.2.  Integraci\u00f3n Controladores Kinect  ................................ .......................  65  \n 5.3.2.1.  Instalaci\u00f3n Controladores Freenect  ................................ .............  66 \n5.3.3.  Integraci\u00f3n Pure Data -Kinect  ................................ .............................  69 \n5.4.  Implementaci\u00f3n Controlador MIDI No Convencional  ................................  73 \n5.4.1.  Recepci\u00f3n y Decodificaci\u00f3n  ................................ ...............................  73 \n5.4.2.  Comprobaci\u00f3n  ................................ ................................ ....................  74 \n5.4.3.  Implementaci\u00f3n  ................................ ................................ ..................  75 \n6. AN\u00c1LISIS DE RESULTADOS  ................................ ................................ .........  79 \n7. CONCLUSIONES  ................................ ................................ ............................  80 \n8. PRODUCTOS  ................................ ................................ ................................ . 81 \n9. RECOMENDACIONES  ................................ ................................ ...................  82 \nBIBLIOGRAF\u00cdA  ................................ ................................ ................................ ...... 83 \nGLOSARIO  ................................ ................................ ................................ ............  89 \nANEXO A: Fotos e Im\u00e1genes Complementarias  ................................ ...................  91 \nANEXO B: Anexos digitales  ................................ ................................ ...................  95  \n LISTA DE FIGURAS  \nFig. 1 Controlador MIDI. Fuente: Propia  ................................ ................................  24 \nFig. 2 Conexiones protocolo MIDI. Fue nte: Propia  ................................ ................  25 \nFig. 3 Microsoft Kinect [32] ................................ ................................ .....................  28 \nFig. 4 Kinect sin carcasa exterior [32]  ................................ ................................ .... 29 \nFig. 5 Fotograf\u00eda de grilla de puntos de luz infrarroja emitidos por el Kinect e \nimagen de profundidad. Fuente: Propia.  ................................ ................................  30 \nFig. 6 Fotograf\u00eda de la c\u00e1mara RGB e imagen de profundidad del Kinect. Fuente: \nPropia  ................................ ................................ ................................ ....................  31 \nFig. 7 Conexi\u00f3n modo Ad -Hoc [33]  ................................ ................................ ........  33 \nFig. 8 Conexi\u00f3n modo infraestructura [33]  ................................ .............................  34 \nFig. 9 Acerca de QmidiNet. Fuente: Propia ................................ ............................  35 \nFig. 10 Sistema Embebido Raspberry Pi [35]  ................................ ........................  36 \nFig. 11 Secci\u00f3n de documentaci\u00f3n e informaci\u00f3n de Pure Data. Fuente: Propia  .. 38 \nFig. 12 Diagrama de bloques Adecuaci\u00f3n S.E. ................................ ......................  39 \nFig. 13 Descripci\u00f3n Desarrollo Controlador MIDI con Convencional  .....................  40 \nFig. 14 Descripci\u00f3n proceso instalaci\u00f3n Ubuntu en sistemas embebidos  ..............  41 \nFig. 15 Arquitectura general de un Sistema de Linux Embebido [39]  ....................  42 \nFig. 16 Ventana compilaci\u00f3n Ubuntu minimal. Fuente: Propia ...............................  43 \nFig. 17 Ventana creaci\u00f3n imagen pre compilada. Fuente: Propia  ..........................  45 \nFig. 18 Interfaz Gr\u00e1fica Xfce. Fuente: Propia  ................................ .........................  46 \nFig. 19 Interfaz Gr\u00e1fica Kde. Fuente: Propia  ................................ ..........................  47 \nFig. 20 Interfaz Gr\u00e1fica Gnome. Fuente: Propia  ................................ ....................  48 \nFig. 21 Interfaz Gr\u00e1fica  Lxde. Fuente: Propia  ................................ ........................  49 \nFig. 22 Interfaz gr\u00e1fica Unity. Fuente: Propia  ................................ .........................  50 \nFig. 23 Beagleboard C3. Fuente: Propia  ................................ ................................  52 \nFig. 24 Beagleboard xM. Fuente: Propia ................................ ................................  54 \nFig. 25 Pandaboard ES. Fuente: Propia  ................................ ................................  55 \nFig. 26 Transmisi\u00f3n Mensajes MIDI  ................................ ................................ ....... 57 \nFig. 27 Implementaci\u00f3n escritorio remoto desde una Tablet. Fuente: Propia  ........  59 \nFig. 28 Diagr ama de flujo codificaci\u00f3n y envi\u00f3 MIDI  ................................ ..............  60 \nFig. 29 Diagrama conexi\u00f3n QmidiNet  ................................ ................................ .... 60 \nFig. 30 Interfaz de configuraci\u00f3n QmidiNet. Fuente : Propia  ................................ .. 61 \nFig. 31 Entradas y Salidas MIDI de Ubuntu. Fuente: Propia  ................................ .. 61 \nFig. 32 Integraci\u00f3n Kinect  ................................ ................................ ......................  62 \nFig. 33 Descripci\u00f3n proceso compilaci\u00f3n Pure Data Extended ..............................  63 \nFig. 34 Interfaz gr\u00e1fica principal de Pd Extended. Fuente: Propia  .........................  65  \n Fig. 35 Ventana de Comando de Compilaci\u00f3n Freenect, con el Kinect conectado a \nla Pandaboard ES. Fuente: Propia  ................................ ................................ ........  66 \nFig. 36 Ejemplo imagen generada por los co ntroladores Freenect. Fuente: Propia\n ................................ ................................ ................................ ...............................  67 \nFig. 37 Diagrama de control de PrimeSense [40]  ................................ ..................  68 \nFig. 38 Ensamble implementado en Pd para  la captura de datos en el eje Z y X  .. 70 \nFig. 39 Secci\u00f3n principal ensamble  ................................ ................................ ....... 70 \nFig. 40 Secci\u00f3n activaci\u00f3n Gem  ................................ ................................ .............  71 \nFig. 41 Secci\u00f3n obtenci\u00f3n datos X y Z  ................................ ................................ ... 71 \nFig. 42 Configuraci\u00f3n MIDICTL  ................................ ................................ ..............  72 \nFig. 43 Con figuraci\u00f3n MIDINOTE  ................................ ................................ ..........  72 \nFig. 44 Descripci\u00f3n proceso de implementaci\u00f3n y prueba del sistema  ..................  73 \nFig. 45 Diagrama de bloques recepci\u00f3n  y decodificaci\u00f3n  ................................ ...... 74 \nFig. 46 Recepci\u00f3n de datos MIDI v\u00eda WiFi a MIDI -OX. Fuente: Propia  ..................  74 \nFig. 47 Recepci\u00f3n de datos MIDI desde V MPK al Kmidimon. Fuente: Propia  ....... 75 \nFig. 48 Implementaci\u00f3n Controlador MIDI no Convencional en Pandaboard ES. \nFuente: Propia  ................................ ................................ ................................ ....... 76 \nFig. 49 Interfaz  principal FL Studio. Fuente: Propia  ................................ ...............  77 \nFig. 50 Captura de pantalla de la implementaci\u00f3n en el FL Studio. Fuente: Propia\n ................................ ................................ ................................ ...............................  77 \nFig. 51 Interfaz de captura de los datos del Kinect implementado en Pure Data. \nFuente: Propia  ................................ ................................ ................................ ....... 78 \nFig. 52 Pandaboard ES conectada remotamente a Samsung Galaxy Tab 10.1. \nFuente: Propia  ................................ ................................ ................................ ....... 91 \nFig. 53 Interfaz del editor conexiones de red. Fuente: Propia  ................................  91 \nFig. 54 Configuraci\u00f3n de control remoto MIDI de FL Studio. Fuente : Propia  .........  92 \nFig. 55 Conexi\u00f3n Pandaboard ES con el Kinect. Fuente: Propia  ...........................  92 \nFig. 56 Interfaz de usuario de TouchOSC para Samsung G alaxy Tab 10.1. Fuente: \nPropia  ................................ ................................ ................................ ....................  93 \nFig. 57 Controlador MIDI Virtual VMPK. Fuente: Propia  ................................ ........  93 \nFig. 58 Ensamble de recepci\u00f3n OSC desde  la aplicaci\u00f3n TouchOSC. Fuente: \nPropia  ................................ ................................ ................................ ....................  94 \n \nLISTA DE TABLAS  \n \nTabla 1 Mensajes MIDI  ................................ ................................ ..........................  26 \nTabla 2 Comandos  Bytes de Estado  ................................ ................................ ...... 26 \nTabla 3 Comparaci\u00f3n especificaciones sistemas embebidos  ................................  56  \n RESUMEN  \n \n \nEl documento presenta el desarrollo de un controlador MIDI no convencion al \nimplementado en un Sistema Embebido utilizando el Kinect. El dispositivo permite \nutilizar el protocolo MIDI para controlar hardware  y/o software remoto v\u00eda WiFi por \nmedio de la captura de movimientos. Con l a utilizaci\u00f3n de  este tipo herramientas \ntecnol\u00f3 gicas se puede construir controladores no convencionales aplicados a la \ningenier\u00eda de sonido, integrables a diferentes redes de comunicaci\u00f3n de f orma \npr\u00e1ctica , eficaz  e innovadora . \n \n \n \n \nABSTRACT  \n \n \nThe document presents the development of a non -conventional MIDI controller \nimplemented into an embedded system using the Kinect.  The device uses the MIDI \nprotocol to control software and/or hardware via  WiFi through  movement detection. \nWhit the utilization of this kind of technological tools its possible developme nt no -\nconventional controllers to Sound Engineer, connecting to different network \nenvironment and practical and     Kinect allows developing such applications in a \npractical and effective way . \n \n \n \n \n \n \n \n \n \n 12 \n INTRODUCCI\u00d3N  \n \n \nLos sistemas embebidos son  herramient as pr\u00e1ctica s y vers\u00e1til es para la \nimplementaci\u00f3n de proyectos relacionados con  la ingenier\u00eda de sonido , los cuales \nincorporan nuevas opciones para el desarrollo de procesos control y producci\u00f3n \naudiovisual . \n   \nEn este campo  se han desarrollado  aplicaciones , tales como un compresor de \naudio y video e n tiempo real utilizando un Sistema Embebido, en el cual se obtuvo \nuna alta  velocidad  y calidad  en el  proces amiento y una disminuci\u00f3n en costos [38]. \nA su vez este tipo de sistema s permiten realizar procesos de t ransferencia \ntecnol\u00f3gica y de conocimientos, con herramientas econ\u00f3micas y de f\u00e1cil acceso, \ngracias a sus dimensiones y a las prestaciones  o caracter\u00edsticas de \nHardware /Software  que soportan . [4] \n \nEn comparaci\u00f3n con los computadores de prop\u00f3sito general, l os sistemas \nembebidos son dise\u00f1ados e implementados para ejecutar aplicaciones espec\u00edficas \ny previamente definidos  por parte de l dise\u00f1ador . [4][39] \n \nAl ser sistemas programables se pueden implementar diferentes sistemas de \ncomunicaci\u00f3n, entre los cuales se  encuentra el protocolo  MIDI, creado para \nunificar los criterios en cuanto a comunicaci \u00f3n de instrumentos digitales. Este  \nprotocolo se puede implementar en automatizaciones, desarrollo de sistemas de \ncontrol de luces, automatizaci\u00f3n de secuencias musicales  y sistemas dom\u00f3tico s.  \n \nA partir de herramientas tecnol\u00f3gicas modernas como el Kinect, se puede \nimplementar sistemas vers\u00e1tiles e interactivos para el usuario con el objetivo de \ndesarrollar controladores no convencionales para  diferentes aplicaciones. El \nKinect  es capaz de cambiar su espacio de funcionamiento, disminuyendo el \u00e1rea \nde captura a un rango determinado por el usuario gracias a su proyecto r y sensor  \ninfrarrojos.  \n \nLos controladores MIDI s on dispositivos utilizados  para realizar  edicion es, \nproducc iones y diferentes tipos de  control, los cuales  trabajan con  el protocolo \nMIDI que al ser universal permite la conexi\u00f3n a diferentes dispositivos  de forma 13 \n pr\u00e1ctica . Estos  dispositivos,  normalmente , est\u00e1n  compuestos por teclas, \npotenci\u00f3metros y botones, los  cuales son el medio de interacci\u00f3n con el usuario.  \n \nEl dispositivo implementado  en el proyecto de grado  se enfoca en el desarrollo  de \nuna herramienta vers\u00e1til e interactiva , en la cual el usuario es capaz de generar  \nmensajes MIDI por medio de detecci\u00f3n de  movimientos, para luego enviarlos v\u00eda \nWiFi y previamente proces ados por un computador que realiza  control MIDI de \nforma remota.  \n  14 \n 1. PLANTEAMIENTO DEL PROBLEMA  \n \n1.1. ANTECEDENTES  \n \n\uf0b7 \u201cFuture human interfaces to computer controlled sound \nsystems \u201d[28]  \n \nEste art\u00edculo  plantea  nuevas posibilidades de interacci\u00f3n hombre -m\u00e1quina  por \nmedio de seguimiento de posici\u00f3n especial, de ojos, de cabeza y de entradas \nt\u00e1ctiles . Presenta algunas tecnolog\u00eda s de interfaces humanas,  las cuales pueden \nser implementada s en los sistemas de sonido.  \n \nLos avances en la interacci\u00f3n hombre -m\u00e1quina  se divide en 3 secciones; ingreso y \nreconocimiento de  datos por la computador a, sistemas visuales y de escucha y \nan\u00e1lisis de espacialidad.  \n \nLos problemas asociados a estos dise\u00f1os suelen afectar la us abilidad de los \nsistemas que est\u00e1n conectados a este , implementar un dispositivo \u00f3ptico -el\u00e9ctrico \nconlleva diferentes problemas.  \n \nCon e l sentido de la vista, el sentido de la audici\u00f3n  es la forma principal en la que \nlos humanos recolectan informaci\u00f3n de s u entorno,  como  la localizaci\u00f3n espacial . \n[28]  \n \n\uf0b7 \"Gesture  to Operate  DAW Software \" [29] \n \nHoy en d\u00eda existen dife rentes formas de capturar gestos , como en un mouse o en \nuna pantalla multi -touch, para su aplicaci\u00f3n a las estaciones de trabajo de a udio \ndigita l, un ejemplo  es el movimiento de un dedo para el cambio de un valor de un \npar\u00e1metro espec\u00edfico . La pregunta es \u00bfen qu\u00e9 medida  el software de audio es ve \nbeneficiado de esto ? Se describe el dise\u00f1o de estrategias que consisten en \nintegrar gestos determinado s asociados a comandos. El art\u00edculo plantea  el uso de \n22 funciones DAW. En una tabla indica n los gestos y la funci\u00f3n asociada a este, y \nla reacci\u00f3n de las personas que hicieron las respectivas pruebas.  \nAl final se concluye que los participantes escogieron  algunas funciones por encima \nde otras. Sobre todo porque esto requiere cierto tipo de entrenamiento para que \npuedan explotar todas las posibilidades de gestos, y la habilidad de creaci\u00f3n de \ngestos por parte de los usuarios.  15 \n \uf0b7 \"Interactive  Mixing  Using Wii C ontroller \" [30]  \n \nEl art\u00edculo  describe el dise\u00f1o, construcci\u00f3n y an\u00e1lisis de un control interactivo por \nmedio de gestos para la me zcla de audio, utilizando un control inal\u00e1mbrico de \nvideo juegos. El concepto est\u00e1 basado en la idea que el ingeniero de mezcla  no \nest\u00e9 cerca la consola y se convierta en parte de la interpretaci\u00f3n de la pista de \naudio. El sistema permite un control total y en vivo de los controles de ganancia, \npaneo, ecualizaci\u00f3n, rango din\u00e1mico de la compresi\u00f3n y otra variedad de efectos \nmulti c anal.  \n \nEl control del Wii posee  varios sensores de movimiento, que permiten al usuario \nubicarse en 3 dimensiones gracias a su aceler\u00f3metro. Tambi\u00e9n cuenta con un \nsensor infrarrojo que determina la posi ci\u00f3n en el eje X y Y, y posee un dispositivo \nbluetooth  para su conexi\u00f3n . \n \nLa construcci\u00f3n de un  control de movimiento para la mezcla de audio muestra una \nforma de innovar y mejorar la me zcla en tiempo real. Permite al ingeniero liberarse \nde la forma convencional de mezcla, d\u00e1ndole libertad de mo vimiento.  \n \n \n\uf0b7 \"Embedded  Controllers  For Audio Devices \" [31]  \n \nLos sistemas embebidos para el audio son presentados como un controlador \nbasado en el protocolo MIDI,  son f\u00e1cilmente adaptados para el audio, el art\u00edculo \nmuestra el desarrollo y las herramientas utilizadas para programar un Sistema \nEmbebido para el control de dispositivos de audio.  \n \nLos sistemas embebidos abren un gran n\u00famero de posibilidades en la \nimplementaci\u00f3n de aplicaciones audio. El control requiere un Sistema Embebido el \ncual ser\u00e1 programado seg\u00fan sea nece sario. Este se divide en cuatro secciones:  \nmemoria, unidad l\u00f3gica, unidad de  control y entradas y salidas.  [31] \n \n\uf0b7 Memoria: Se almacena y se lee la informaci\u00f3n del sistema.  \n \n\uf0b7 Unidad L\u00f3gica: Realiza las operaciones l\u00f3gicas y matem\u00e1ticas de la \ninformaci\u00f3n.  \n 16 \n \uf0b7 Unidad De Control: Dirige las actividades de la computadora, siguiendo las \ninstrucciones almacenadas en la memoria para cumplir una tarea \nespec\u00edfica. Aqu\u00ed se encuentra el procesador y microprocesadores.  \n \n\uf0b7 Entradas y Salidas: En los dispositivos de entrada hay  interacci\u00f3n con el \nusuario de forma f\u00edsica para comunicarse con el computador. Los de salida \nse utilizan para que el computador se comunique con el usuario.  \n \n \n\uf0b7 Using Xbox 360 Kinect Games on Enhancing Visual Performance Skills \non Institutionalized Older A dults with Wheelchairs\u201d [76]  \n \nEl objetivo de este estudio es explorar los beneficios de los videojuegos en \npersonas de la tercera edad, el Kinect pueden llegar a ser una buena herramienta \npara poblaci\u00f3n de la tercera edad con silla de ruedas. El estudio se  realiz\u00f3 con 53 \nparticipantes divididos en dos grupos, un grupo experimental de 22 personas de \nunos 78 a\u00f1os, y un grupo de control de 31 personas de unos 79 a\u00f1os, el grupo \nexperimental accedi\u00f3 voluntariamente a practicar 3 sesiones de entrenamiento de \nXbox  360 con el Kinect por una semana, con una duraci\u00f3n de 30 minutos cada \nvez. El Vienna Test System y el test de  Soda Pop fueron usados para medir la \nreacci\u00f3n y la coordinaci\u00f3n entre ojos y manos de las habilidades de interpretaci\u00f3n \nvisual, cuyos resultados  favorables indicaron que las personas de la tercera edad \nmejoran este tipo de habilidades gracias a Xbox 360 Kinect.  [76] \n \n\uf0b7 \u201cKinect -based obstacle detection for manipulator\u201d [77]  \n \nEste art\u00edculo presenta un m\u00e9todo para distinguir obst\u00e1culos y poder manipula rlos \ncuando se encuentran en el mismo espacio, para esto se utiliza el Kinect como \ndispositivo de captura, adem\u00e1s de la explicaci\u00f3n del m\u00e9todo de calibraci\u00f3n de \nKinect, se describe el m\u00e9todo de calibraci\u00f3n interactivo de m\u00ednimos cuadrados \nentre el Kinect y  el manipulador. El modelo del manipulador es generado usando \nla librer\u00eda OpenGL. Finalmente, la superficie del manipulador es eliminada de la \nescena utilizando el sensor infrarrojos del Kinect. [77] \n \n 17 \n \uf0b7 \u201cHuman motion tracking of mobile robot with Kinect 3D sensor\u201d [78]  \nEste art\u00edculo presenta un sistema de control de seguimiento del movimiento con el \nKinect, implementado en robot m\u00f3vil. En este sistema, la informaci\u00f3n obtenida con \nel Kinect de la posici\u00f3n en tres dimensiones de la persona, permite controlar \ndirectamente la velocidad y los movimientos del robot.  \nPara reducir el ruido, se utiliz\u00f3 el efecto de oclusi\u00f3n incluida en los datos \nadquiridos por el  Kinect y asu estimar el estado del movimiento, se usa el filtro \nKalman, el cual tambi\u00e9n es descrito en e ste art\u00edculo. [78] \n \n\uf0b7 \u201cThe design and initial calibration of an optical tracking system using \nthe Microsoft Kinect\u201d [79]  \n \nLa correcci\u00f3n de movimientos requiere un confiable y minucioso seguimiento, el \ncual es llevado a cabo por sistemas que usan dispositivos  como el sensor de \nmovimiento Polaris Vicra1 para monitorear la posici\u00f3n y orientaci\u00f3n de una \nherramienta. Los sistemas de seguimiento del movimiento se fijan directamente en \nel objeto sin necesidad de usar marcadores, este m\u00e9todo fue desarrollado gracias \nal Kinect, que posee una c\u00e1mara RGB y un sensor infrarrojo de bajo costo el cual \npuede capturar movimientos r\u00edgidos del cuerpo. El algoritmo del proyecto abierto \nllamado \u201cPointCloudLibrary\u201d fue implementado para registrar la grilla de puntos \ngenerados por el Kinect.  [79] \n \n\uf0b7 \u201cStatic Hand Gesture Recognition Based on HOG with Kinect\u201d [80]  \n \nEn este art\u00edculo se implementa un m\u00e9todo de reconocimiento est\u00e1tico de gestos \nde la mano usando informaci\u00f3n de profundidad del Kinect. Debido a que la mano \nes relativamente u n objeto peque\u00f1o con articulaciones complejas, es dif\u00edcil lograr \nreconocer sus movimientos. Por tal raz\u00f3n, se emple\u00f3 la funci\u00f3n del momento \ngeom\u00e9trico invariante adaptado a los cambios de luz, mediante el an\u00e1lisis de las \ncaracter\u00edsticas de la mano. Gracias  al algoritmo de entrenamiento \u201cAdaboost\u201d se \nobtuvieron los modelos gestuales de prueba, con el fin de construir un sistema \n                                            \n1 Es un dispositivo de medici\u00f3n \u00f3 ptico que mide la posici\u00f3n en  3D de marcadores activos o pasivos \nque son capturados por una aplicaci\u00f3n especifica  18 \n preciso y eficiente de reconocimiento de gestos manuales usando el sensor del \nKinect.  [80] \n \n\uf0b7 \u201cThe Kinect up close: Adaptations for sh ort-range imaging\u201d [81]  \n \nEn este art\u00edculo se describe la calibraci\u00f3n y funcionamiento de captura de \nim\u00e1genes en rangos espec\u00edficos utilizando el Kinect, c on la calibraci\u00f3n adecuada \nde su c\u00e1mara RGB y de  profundidad, el Kinect puede capturar detallada mente  \nnubes de puntos hasta 30 fotogramas por segundo. Esta capacidad convierte al \nKinect  en una herramienta ideal  para su uso en la rob\u00f3tica como un sensor de \nnavegaci\u00f3n de bajo costo. Por lo tanto, las t\u00e9cnicas de calibrac i\u00f3n de  la c\u00e1mara de \nprofundidad Kinect  permiten determinar un rango de funcionamiento espec\u00edfico . \nPara realizar la calibraci\u00f3n de profundidad, es necesario tener una  plataforma de \ncalibraci\u00f3n y software , que fueron  desarrollados para asignar autom\u00e1ticamente \nvalores brutos de profundidad para  objeto s. La plataforma de calibraci\u00f3n consisti\u00f3 \nen un tablero de ajedrez blanco facilitado  al software  asignar los valores de \nprofundidad . Para modificar la \u00f3ptica del Kinect  y mejorar la imagen de corto \nalcance,  se utiliz\u00f3 el adaptador \u201c Nyko Zoom \u201d, aunque es eficaz en la reducci\u00f3n de \nla distancia m\u00ednima de Kinect, este introduce distorsi\u00f3n al sistema, para esto se \ndesarroll\u00f3 un modelo para corregir dicha distorsi\u00f3n mediante  software. Con esto \nse logr\u00f3 disminuir el alcance m\u00ednimo  del Kinect  en aproximadament e 30%.  [81] \n \n\uf0b7 \u201cA new embedded image information processing system design\u201c [82]  \n  Este art\u00edculo presenta un sistema embebido de adquisici\u00f3n de informaci\u00f3n de \nimagen, e l cual incluye la codificaci\u00f3n y almacenamiento de im\u00e1genes capturadas \ny otros m\u00e9todos de t ratamiento que cumplen diferentes secciones; la primera es \ninvestigar acerca de una pantalla en tiempo real de la informaci\u00f3n digital de \nimagen a trav\u00e9s de un LCD , y segundo  lograr el dise\u00f1o de una parte de \nalmacenamiento de informaci\u00f3n de imagen  en el sis tema a trav\u00e9s  de la \ncodificaci\u00f3n de imagen BMP. [82] \n \n 19 \n \uf0b7 \u201cMobile Robots Navigation in Indoor Environments Using Kinect \nSensor\u201d [83]  \n \nEste art\u00edculo presenta el desarrollo de un sistema de percepci\u00f3n para ambientes \nde interior con el prop\u00f3sito de permitir la n avegaci\u00f3n aut\u00f3noma de robots m\u00f3viles \nde vigilancia. El s istema se compone de dos partes,  la primera es un sistema de \nnavegaci\u00f3n reactiva en el cual el robot m\u00f3vil se mueve evadiendo obst\u00e1culos, \nusando el Kinect, y  la segunda parte usa una red neural artifi cial (ANN)  para \nreconocer diferentes configuraciones de l entorno. El ANN esta entrenado  usando \ninformaci\u00f3n capturada desde el Kinect en interiores , de este modo, el robot es \ncapaz de  realizar una navegaci\u00f3n topol\u00f3gica combinando un comportamiento \nreactivo interno. El mapa topol\u00f3gico es representado por una gr\u00e1fica que \nrepresenta la configuraci\u00f3n del  ambiente.  \nEl sistema tambi\u00e9n trabaja en la oscuridad, lo cual es una gran ventaja para \nsistemas de vigilancia. El experimento fue llevado a cabo con un robot Pi oneer P3 -\nAT equipado con un sensor Kinect con el fin de validar y evaluar este enfoque.  [83] \n \n\uf0b7 \u201cA Multi -User Interaction System Based on Kinect and Wii Remote\u201d \n[84] \n \nEl sistema de interacci\u00f3n multi -usuario que implementa el Kinect y un control \nremoto Wii, f ue desarrollado para manipular  el escritorio de W indows . Este \nsistema  combina la informaci\u00f3n gestual capturada desde estos sensores \nbrindando una experiencial m\u00e1s real y natural al usuario.  [84] \n \n \n  20 \n 1.2. DESCRIPCI\u00d3N Y FORMULACI\u00d3N DEL PROBLEMA  \n \nHoy en d\u00eda se ve como los avances tecnol\u00f3gicos simplifican procesos e \ninteract\u00faan de forma m\u00e1s amigable con el usuario, brind\u00e1ndole una experiencia \nm\u00e1s realista, hasta el punto de evitar en lo posible el contacto f\u00edsico con los \nobjetos para poder controlarlos, ya sea por s ensores o por detecci\u00f3n de \nmovimiento.  \n \nPor eso se quiere llevar esta tecnolog\u00eda al campo de la ingenier\u00eda de sonido, para \nofrecer en el mercado formas innovadoras  para realizar grabaciones, mezclas, \nmontajes de sonido en vivo, etc. Con el fin de captar la  atenci\u00f3n de las personas \nque a\u00fan no conocen la carrera.  \nAl ser software poco com\u00fan, se buscan formas pr\u00e1cticas  y sencillas para crear \nproyectos  caseros  de sonido  de forma interactiva, evitando  memorizar por ejemplo  \nm\u00e9todos abreviados  de teclado o tener qu e abrir pesta\u00f1a por pesta\u00f1a, buscando \nla opci\u00f3n que requiera.  \n \n\u00bfC\u00f3mo  brindar una experiencia m\u00e1s realista a los usuarios de programas de \nsonido, por medio de la implementaci\u00f3n de sistemas de control MIDI no \nconvencionales?  \n \n \n1.3. JUSTIFICACI\u00d3N  \n \nHoy en d\u00eda se b usca que todos los procesos se apliquen de una forma sencilla , y \nadem\u00e1s se cuente con  una interfaz amigable con el usuario, por eso se requiere  \nque la comunicaci\u00f3n  con un computador  sea lo m\u00e1s interactiva posible , evitando la \ninstalaci\u00f3n de  cualquier tipo de controladores para que un di spositivo externo a \u00e9l \nfuncione, por lo cual se utilizan avances tecnol\u00f3gicos, dise\u00f1ados para tal fin . \n \nLa implementaci\u00f3n de sistemas embebidos para este fin, a\u00fan no ha sido aplicada \na la ingenier\u00eda de sonido , por lo cual se  quiere promover su uso mediante la \ntransmisi\u00f3n de MIDI  v\u00eda WiFi para control de diferentes dispositivos aplicados a la \nIngenier\u00eda de Sonido.  \n \n \n 21 \n 1.4. OBJETIVOS  \n \n1.4.1.  Objetivo General  \n \nDesarrollar un controlador MIDI interactivo, implementado en un Sistema \nEmbebido que envi\u00e9 mensajes MIDI, utilizando el KINECT.  \n \n1.4.2.  Objetivos Espec\u00edficos  \n \n\uf0b7 Integrar el KINECT con un sistema embebido.  \n \n\uf0b7 Desarrollar interfaz gr\u00e1fica para la interacci\u00f3n con el usuario, que pueda \ninterpretar mensajes MIDI.  \n \n\uf0b7 Desarrollar sistema de control de usua rio, que permita el control por medio de \n3 tipos de mensaje MIDI con el sistema embebido  \n \n \n1.5. ALCANCES Y LIMITACIONES  \n \n1.5.1.  Alcances  \n \n\uf0b7 Se podr\u00e1  controlar software compatible con el protocolo  MIDI, con diferentes \nfunciones  seg\u00fan movimientos asignados por el usuario.  \n \n \n1.5.2.  Limitaciones  \n \n\uf0b7 Se programar\u00e1 n determinados mensajes MIDI, para evitar que el KINECT \nconfunda algunos movimientos que podr\u00edan llegar a ser muy similares, y envi\u00e9 \nmensajes err\u00f3neos al sistema.  \n \n \n \n 22 \n 2. METODOLOG\u00cdA  \n \n \n2.1. ENFOQUE DE LA INVESTIGACI\u00d3N  \n \nEl enfoq ue de es te proyecto es emp\u00edrico -anal\u00edtico, debido a que se est\u00e1n \naplicando nuevas formas de procesamiento y manejo  de mensajes MIDI a partir de \ncontroladores no convencionales, a trav\u00e9s de la aplicaci\u00f3n de procesos de \ntransferencia tecnol\u00f3gica.  \n \nLos sistemas embe bidos se han convertido en una fuente de desarrollo pr\u00e1ctico, \neste tipo de herramientas permite crear aplicaciones espec\u00edficas de software y \nhardware para el desarrollo de dispositivos, gracias a sus dimensiones y a las \nprestaciones.  \n \nCon el desarrollo de este dispositivo pueden comprobarse la efectividad y \nversatilidad de la aplicaci\u00f3n de sistemas embebidos para el procesamiento de \nse\u00f1ales.  \n \n \n2.2. HIP\u00d3TESIS  \n \nDe acuerdo al comportamiento del Kinect en un sistema embebido , se busca que \nla comunicaci\u00f3n del usuario  con el sistema  sea m\u00e1s agradable e interactiva , \ntomando los movimientos capturados para ejecutar acciones espec\u00edficas con \nayuda  de protocolo  MIDI , y se tendr\u00e1  en cuenta que la latencia  de captura de \nimagen  no afecte la interacci\u00f3n con el sistema.  \n \n2.3. VARIABL ES \n \n2.3.1.  Independientes  \n \nAsignar movimientos a los siguientes mensajes MIDI:  \n \n\uf0b7 Cambio de Control  \n\uf0b7 Cambio de Programa  23 \n \uf0b7 Nota MIDI  \n \n2.3.2.  Dependientes  \n \nComportamiento del Kinect en un Sistema Embebido y latencia del mensaje al \nllegar a alg\u00fan dispositivo  \n \n3. L\u00cdNEA DE INVESTIGA CI\u00d3N DE LA UNIVERSIDAD/ SUB -L\u00cdNEA DE LA \nFACULTAD/ CAMPO TEM\u00c1TICO DEL PROGRAMA  \n \n \nL\u00ednea de investigaci\u00f3n : an\u00e1lisis y procesamiento de se\u00f1ales . \nN\u00facleo Probl\u00e9mico: Ac\u00fastica y audio.  \n \n \n \n \n \n \n  24 \n 4. MARCO TE\u00d3RICO  \n \n \nEn el desarrollo de un controlador MIDI no convenciona l, utilizando el Kinect, es \nnecesario identificar las siguientes tem\u00e1ticas : Controladores MIDI , Kinect, \nSistemas de Transmisi\u00f3n Inal\u00e1mbrica, Sistemas Embebidos y Pure Data  \n \n4.1. Controlador MIDI \n \nDispositivo capaz de interpretar  y reproducir  mensajes MIDI. E n sus modelos m\u00e1s \nsimples cuenta n \u00fanicamente  con teclas, entrada y  salida MIDI,  con lo que \ncualquier cambio  que se desee  hacer  en el programa  debe hacerse directamente \ndesde un software espec\u00edfico . Los m\u00e1s completos  disponen de m\u00e1s opciones para \nel manejo de bancos, c ambio de control o de programa.  \n \nNormalmente el controlador tiene la apariencia de un instrumento  tradicional , \nredise\u00f1ado para funcionar bajo el prot ocolo MIDI. Los controladores comunes son \nteclados como el que se observa en la Figura 1, adiciona lmente pueden modificar  \nla modulaci\u00f3n , afinaci\u00f3n , etc... .Pero no produce sonidos por s\u00ed mismos .[2][3][5]  \n \n \n \nFig. 1 Controlador MIDI . Fuente: Propia  \n \n25 \n Para la interconexi\u00f3n de dos o m\u00e1s interfaces se utilizan tres diferentes puertos y \nun cable con conector es DIN de 5 pines. Los tres puertos son IN, OUT y THRU los \ncu\u00e1les cumplen las siguientes funciones:  \n \n \n \nFig. 2 Conexiones protocolo MIDI . Fuente: Propia  \n \n \nMIDI IN: Es la entrada del dispositivo, captura la informaci\u00f3n proveniente desde \notro dispositivo MID I. \n \nMIDI  OUT: Es la salida del dispositivo, por donde se env\u00eda la informaci\u00f3n \ngenerada por el dispositivo MIDI.  \n \nMIDI  THRU: Es un puerto que se utiliza para la interconexi\u00f3n de otro dispositivos \nMIDI. Este es una copia exacta de la informaci\u00f3n proveniente  del puerto MIDI IN y \nse utiliza en el caso de tener un dispositivo maestro que env\u00ede informaci\u00f3n a m\u00e1s \nde un dispositivo a la vez.[7]  \n \n \n \n \n \n \n  \n26 \n 4.1.1.  Bytes MIDI  \n \nHay dos clases de bytes: De estado y de datos. Principalmente se diferencian por \nel primer  bit, que p uede ser 0 o 1, siend o el primero de datos y el segundo de \nestado , al enviar un mensaje MIDI  se env\u00eda  un byte de estado, que puede estar \nseguido de determinada cantidad de bytes de datos , a su vez, los mensajes de \nestado se dividen en dos: mensajes  de cana l y mensajes de sistema ., los \nmensajes de canal se env\u00edan a un dispositivo espec\u00edfico  configurado en ese canal , \nmientras que  los mensajes de sistema son recibidos por todos los equipos. [2](Ver \nTabla 1, Tabla 2)  \n \nByte Estado  Descripci\u00f3n  \n1000cccc  Desactiv aci\u00f3n de nota  \n1001cccc  Activaci\u00f3n de nota  \n1010cccc  Post -pulsaci\u00f3n polif\u00f3nica  \n1011cccc  Cambio de control  \n1100cccc  Cambio de programa  \n1101cccc  Post -pulsaci\u00f3n monof\u00f3nica de canal  \n1110cccc  Pitch  \n11110000  Mensaje exclusivo del fabricante  \n111100 01  Mensaje de trama temporal  \n11110010  Puntero posici\u00f3n de canci\u00f3n  \n11110011  Selecci\u00f3n de canci\u00f3n  \n11110110  Requerimiento de entonaci\u00f3n  \n11110111  Fin de mensaje exclusivo  \n11111000  Reloj de temporizaci\u00f3n  \n11111010  Inicio  \n11111011  Continuaci \u00f3n  \n11111100  Parada  \n11111110  Espera activa  \n11111111  Reseteo del sistema  \nTabla 1 Mensajes MIDI  \nValor (Decimal)  Valor \n(Hexadecimal)  Comando  Byte de dato  \n128-143  80-8F Nota Off  2 (nota, Velocidad)  \n144-159  90-9F Nota ON  2 (nota, Velocidad)  \n160-175  A0-AF Presi\u00f3n de tecla  2 (nota, Presi\u00f3n)  \n176-191  B0-BF Cambio de Control  2 (# de Control, Valor)  \nTabla 2 Comandos Bytes de Estado  27 \n 4.1.2.  Mensaje de Nota  On/Off  \n \nAl momento de pulsar una tecla el controlador emite un mensaje MIDI  de Nota On, \nel byte de estado indicara por  cual canal se emitir\u00e1 el mensaje , seguido por  dos \nbytes que especifican el n\u00famero  de tecla y el valor de la velocidad de  la pulsaci\u00f3n \nel cual determina que tan fuerte fue pulsada .[2] \n \nAl soltar la tecla, el controlador emite un m ensaje MIDI  de Nota Off, este tambi\u00e9n \nlleva bytes de datos para determinar la  nota y la velocidad  con que se ha soltado \nla tecla, normalmente el byte de datos que determina la velocidad no es tomado \nen cuenta , ya que al apaga la nota por medio de l byte de estado.  \n \n \n4.1.3.  Mensaje de Cambio de Programa  \n \nEs el p ar\u00e1metro que modifica  los elementos que genera n el sonido dentro de un \nsintetizador, b\u00e1sicamente un cambio de programa  que se refiere a cambiar el \ninstrumento del programa  activo. Consiste  en un byte de encab ezamiento (1100) \nseguido por un byte de datos que indica el n\u00famero  de programa, al recibir este \nmensaje cambiar \u00e1 inmediatamente el timbre con el que se est\u00e1 tocando las notas. \n[3] \n \n \n4.1.4.  Mensaje de Cambio de Control  \n \nSe usan para controlar una gran variedad de funciones de un sintetizador , en los \nmensajes de cambio de control se incluye la mayor\u00eda de los controles de expresi \u00f3n \nde sonido, los cuales se transmiten en mensajes independientes , estos controles \ntienen asignado un n \u00famero que est \u00e1 establecido en la norm a MIDI.  \nEn los mensajes de control, el primer  byte de datos indica el n\u00famero de \ncontrolador o n\u00famero  de control y el segundo  indica el valor que se ha variado a \ndicho control. En  el caso de los controles que solo pueden tomar dos estados \n\u00fanicamente (On/Off ), como el sostenido, el segundo byte de datos toma el valor 0 \ncuando est\u00e1 apagado  y 127 cuando est\u00e1 activo.  28 \n 4.2. Kinect2 \n \nFue desarrollado con la idea de crear una interacci\u00f3n juego -humano m\u00e1s realista , \ncon lo que se logr\u00f3 obtener  la capacidad  de entende r las dimensiones del espacio \ny tener  reconocimiento de voz . Gracias a esto  identifica e interpreta sus \nmovimientos y los traduce en un formato en el que los desarrolladores  puedan \nusar para implementar nuevas aplicaciones y mejorar la experiencia  del usuario. \n[6] \n \nEste combina una c\u00e1mara RGB3, una c\u00e1mara  infrarroja , un sensor infrarrojo y  \ncuatro micr\u00f3fonos  de desarrollo propio. Estos  componentes  brinda n nuevas \nexperiencias a trav\u00e9s de cualquier consola  Xbox 360 , Gracias a esto se logra  \ncaptura r movimiento s en tres dimensiones, reconocimiento facial y de voz.  \n \n \nFig. 3 Microsoft Kinect  [32] \n \n \n  \n                                            \n2Controlador de juego libre desarrollado por Alex Kipman y Microsoft para la consola Xbox 360.  \n3Del ingl\u00e9s  Red, Green, Blue ; \"rojo, verde, azul\" modelo de color basado en l a s\u00edntesis aditiva , con \nel que es posible representar un color mediante la mezcla los tres colores luz primarios.  \n29 \n 4.2.1.  Componentes y Funcionamiento  \n \n \nLa c\u00e1mara  RGB percibe  la luz que es reflejada por los objetos hacia el lente de la \nc\u00e1mara, luego la imagen es reconstruida simulando  al ojo h umano . El Kinect \nobtiene datos de distancia en 3D de los objetos mediante la emisi\u00f3n de puntos de \nluz infrarroja que proyecta el sensor infrarrojo, el cual permite al Kinect percibir su \nposici\u00f3n en el espacio sin importar su forma  f\u00edsica.  \n \n \n \nFig. 4  Kinect  sin carcasa exterior [ 32] \n \nEl proyector de rayos infrarrojos se encuentra ubicado a la izquierda del Kinect \ncomo se puede ver en la Figura 4, este emite una grilla de puntos infrarr ojos, por \nel rango de frecuencia que maneja se hacen imperceptibles para e l ojo humano y \nsolo la c\u00e1mara infrarroja  es capaz de procesarlos , esta se encuentra ubicada a la \nderecha del Kinect.  \n \n \nProyector Rayos  \nInfrarrojos  \nC\u00e1mara Infrarroja  \nC\u00e1mara RGB  30 \n  \nFig. 5 Fotograf\u00eda  de grilla de puntos de luz infrarroja emitidos por el Kinect  e imagen de \nprofundidad.  Fuente: Propia.  \n \nEs posible determinar  la distancia de un objeto a la c\u00e1mara debido a  que cada \nKinect esta calibrado  a determinado rango de operaci\u00f3n,  as\u00ed cuando un objeto se \nencuentra fuera de ese rango,  los puntos generados por el sensor infrarrojo \ncambian de direcci\u00f3n , de esta maner a a partir de la posici\u00f3n de la grilla de puntos \nse puede conocer las distancias de cada objeto a l Kinect.  \n \nUna imagen de profundidad es m\u00e1s f\u00e1cil de entender por un computador que una \nimagen convencional, ya que cada pixel muestra que tal lejos est\u00e1 de la  c\u00e1mara, lo \ncual ayuda a determinar en qu\u00e9 punto inicia y termina un objeto. Tambi\u00e9n  contiene \ninformaci\u00f3n sobre el espacio en tres dimensiones, esto con el fin de identificar y \nseguir la trayectoria de los movimientos de cada individuo, inclusive localiza las \narticulaciones del cuerpo.  \n31 \n  \nFig. 6 Fotograf\u00eda  de la c\u00e1mara RGB e imagen de profundidad del Kinect . Fuente: Propia  \n \nLa c\u00e1 mara RGB  muestra una imagen com\u00fan  sin ninguna informaci\u00f3n  \naparentemente \u00fatil, pero al alinearla con la imagen de profundidad, se  puede \nalterar la imagen de la c\u00e1mara  RGB,  creando un espacio en tres dimen siones o un \nentorno virtual a color, con la capacidad de manipular el espacio gracias a los \ndatos proporcionados por el sensor infrarrojo. [7]  \n \n4.2.2.  Controladores  \n \nSon los encargados de con ectar el Kinect con el computador o sistema embebido, \ntienen la capacidad de traducir los datos capturados Kinect para que pued an ser \nentendidos por el ordenador . \n \n4.2.2.1.  Open Kinect  \n \n \nEs una comunidad de personas que desarrolla librer\u00edas  para el Kinect, \nprincipa lmente se enfocan en el libfreenect4, que es el controlador que utiliza esta \ncomunidad.  Maneja una licencia de c\u00f3digo completamente abierto, siendo este \ngratuito las  personas interesadas puede contribuir en el mejoramiento del mismo.  \n[9][7] \n \n                                            \n4 Enlace de la comunidad OpenKinect: http://openkinect.org/wiki/Main_Page  \n32 \n El libfreenec t soporta la c\u00e1mara RGB, c\u00e1mara infrarroja, motor, aceler\u00f3metro, led y \nmicr\u00f3fonos , brinda ndo un control completo sobre todos sus componentes, este \nmaneja la informaci\u00f3n  de posici\u00f3n  en los ejes X , Y y Z. \n \n4.3. Sistemas de Transmisi\u00f3n Inal\u00e1mbrica  \n \nSon los encarga dos de interconectar dos o m\u00e1s dispositivos por medio de la \ntransmisi\u00f3n de se\u00f1ales de un lugar a otro utilizando  la modulaci\u00f3n de ondas \nelectromagn\u00e9ticas. Los dispositivos f\u00edsicos son utilizados como emisor y receptor \nde se\u00f1al.  [11] \n \n4.3.1.  Redes Inal\u00e1mbricas  \n \nEs un mecanismo de conexi\u00f3n en red de dos o m\u00e1s dispositivos electr\u00f3nicos, sin \nla necesidad de una conexi\u00f3n cableada , este tipo de conexi\u00f3n esta presente en \nlos dispositivos habilitados con Wi Fi5, tales como: ordenador es port\u00e1tiles,  consola s \nde videojuegos , tel\u00e9fonos inteligentes  o un reproductor de audio digital .[12][15] \nExisten diferentes categor\u00edas de redes inal\u00e1mbricas y depende n del \u00e1rea de \ncobertura:  \n1. Red de \u00e1rea personal inal\u00e1mbrica (WPAN) . [72]  \n2. Red de \u00e1rea local inal\u00e1mbrica (WLAN) . [73]  \n3. Red de \u00e1rea me tropolitana inal\u00e1mbrica (WMAN) . [74]  \n4. Red d e \u00e1rea extendida inal\u00e1mbrica (WW AN). [75]  \n \nLa Red de \u00e1rea local inal\u00e1mbrica (WLAN) es la de inter\u00e9s, siendo esta la utilizando \nen hogares, empresas y sitios p\u00fablicos . Tiene un alcance de unos 20 metros en \ninterior es, se  pueden cubrir grandes \u00e1reas con la superposici\u00f3n de m\u00faltiples \npuntos de acceso.  [12][10]  \nLos receptores inal\u00e1mbricos en muchos casos se encuentran integrados dentro de \nlos mismos dispositivos, o son implementados como perif\u00e9ricos USB6, en su \n                                            \n5Marca de la  Wi-Fi Alliance . Est\u00e1ndar de comunicaci\u00f3n inal\u00e1mbrica.  \n6Universal Serial Bus . \"Bus Universal en Serie\". Es un est\u00e1ndar de conexi\u00f3n para dispositivos y \nperif\u00e9ricos electr\u00f3nicos.  33 \n mayor\u00eda  PnP7.Los transmisores utilizados son los enrutadores que proporcionan \nconectivida d de nivel de red de \u00e1rea local,  su funci\u00f3n es reenviar  y enrutar  \npaquetes de datos a d iferentes receptores conectados , los dispositivos  son \nidentificados por medio de direc ciones IP8. [10] \n \nTrabaja bajo el est\u00e1ndar IEEE  denominado  802.11 x, abarca la capa f\u00edsica  y una \nsubcapa de acceso al medio de la capa de enlace del modelo OSI9. Define el \nconcepto de Conjunto B\u00e1sico de Servicio (BSS), consiste en el reconocimiento de \ndos o  m\u00e1s nodos inal\u00e1mbricos con la capacidad de transmitir informaci\u00f3n entre \nellos.  [13] Pueden intercambiar informaci\u00f3n de dos maneras distintas:  \n \n1. Directa: Cada nodo  se comunica sin necesidad de una interfaz que se \nencargue del intercambio de datos,  creando u na red inal\u00e1mbrica \ndescentralizada. E ste modo es llamado Ad -Hoc, solo permite la \ntransmisi\u00f3n de datos entre dispositivos inal\u00e1mbricos .[13] \n \n \nFig. 7 Conexi\u00f3n modo Ad -Hoc [33] \n2. Por Interfaz: Cada nodo se comunica con una interfaz de comunicaci\u00f3n \nencargada de  gestionar la transmisi\u00f3n de datos y la creaci\u00f3n de una red \nlocal, pueden ser Enrutadores o Puntos de Acceso. Este es llamado \n                                            \n7Plug-and-Play, \"Conectar y utilizar\". es la tecnolog\u00eda que permite a un dispositivo ser conectado a \nuna computadora  sin necesidad de c ontroladores . \n8 Del Ingles Internet Protocol. \"Protocolo de Internet\u201d Protocolo  de comunicaci\u00f3n de datos digitales . \n9Open systeminterconnection. \"Modelo de interconexi\u00f3n de sistemas abiertos\" Marco de referencia \npara la definici\u00f3n de arquitecturas de inter conexi\u00f3n de sistemas de comunicaci\u00f3n.  \n34 \n modo Infraestructura y permite vincular red inal\u00e1mbrica con red \ncableada, ya que la interfaz funciona como puente de comunicaci\u00f3n \nentre estos dos.[13]  \n \nFig. 8 Conexi\u00f3n modo infraestructura  [33] \n \n4.3.2.  Transmisor MIDI: QmidiNet  \n \nSoftware encargado de codifica r y decodificar mensajes MIDI para su envi\u00f3 por \nmedio de redes locales.  Se encarga de abrir un enlace de red para la transmisi\u00f3n \nde m ensajes MIDI v\u00eda UDP/IP Multicast . Recibe y env\u00eda datos MIDI utilizando el \nsecuenciador de ALSA o el puerto MIDI de JACK a trav\u00e9s de redes, al\u00e1mbricas e \ninal\u00e1mbricas.  \nEste crea puertos MIDI virtuales que son reconocidos por JACK, que facilita su \ninterconex i\u00f3n con diferentes aplicaciones dentro de LINUX. Para su \nimplementaci\u00f3n se utiliza  un controlador MIDI para Linux llamado VMPK, el cual \ngenera y recibe mensajes MIDI. [14]  Es software libre, distribuido como GNU10 \nLicencia Publica General versi\u00f3n 2 o poster ior. \n                                            \n10Proyecto iniciado por Richard Stallman con el objetivo de crear un sistema operativo \ncompletamente libre . \n35 \n  \n \nFig. 9 Acerca de QmidiNet . Fuente: Propia  \n \n \n4.4. Sistemas Embebidos  \n \nSon sistemas programables, dise\u00f1ados para realizar tareas espec\u00edficas  \ndeterminadas por el usuario, con el fin de optimizar los procesos para mejorar su \ndesempe\u00f1o y eficiencia, reducien do tama\u00f1o y costos de producci\u00f3n. L os sistemas \nembebidos  se convierten en herramientas de desarrollo \u00fatiles  dentro de diversos \n\u00e1mbitos de la ingenier\u00eda de sonido. [18] \n \nA diferencia  de los computadores convencionales  se caracterizan  por el bajo \nconsumo de e nerg\u00eda, son econ\u00f3micos, poseen perif\u00e9ricos limitados, \nimplementaci\u00f3n de diferentes sistemas operativos y algunos son dise\u00f1ados para \nrealizar tareas espec\u00edficas . \n \nEst\u00e1n compuestos por tres componentes principales: Procesador, Dispositivos de \nAlmacenamiento y Perif\u00e9ricos. Los cuales var\u00edan seg\u00fan los par\u00e1metros de dise\u00f1o \nrequeridos. Para sistemas embebidos pre dise\u00f1ados o de uso general como lo son \nla BeagleBoard11, PandaBoard12 o Raspberry Pi13. Utilizan arquitect uras de \n                                            \n11 Sistema embebido de medianas prestaciones que permite a novatos, innovadores e ingenieros \nla implementaci\u00f3n d e proyectos.  \n12 Sistema embebido de altas prestaciones con una mayor cantidad de perif\u00e9ricos dise\u00f1ada para \nser correr varias aplicaciones simult\u00e1neamente.  \n13 Sistema embebido de muy bajo costo dise\u00f1ado para correr aplicaciones cotidianas de un \ncomputador de bajas prestaciones.  \n36 \n procesador similares, todas son  arquitect ura ARM14, utilizan una memoria \nSD/MicroSD15 como dispositivo de almacenamiento y memoria de trabajo RAM16. \n[35][36][37]  \n \n \n \nFig. 10 Sistema Embebido Raspberry Pi  [35] \n \n4.4.1.  Software  \n \nLo sistemas embebidos requieren la instalaci\u00f3n de un sistema operativo el cual \nest\u00e1 dise\u00f1ando para administrar de forma eficiente los recursos del dispositivo, \neste permite la comunicaci\u00f3n hardware/software con el fin de ejecutar las tareas \npara las que fue programado.[18] Algunos S.O. Embebidos que se trabajan \nactualmente son:  \n \n \n\uf0b7 Android: Plataforma m\u00f3vil desarrollada en base Linux creada por Google, \njunto con aplicaciones middleware est\u00e1 dise\u00f1ada para ser utilizada en \ntel\u00e9fonos inteligentes , tablets, televisores, etc.  Dise\u00f1ado principalmente \npara la arquitectura ARM.  \n                                            \n14es una familia de procesadores dise\u00f1ado por AcornComputers y desarrollado por Advanced RISC \nMachines Ltd.  \n15Secure Digital. Dispositivo digital de almacenamiento.  \n16del Ingles  random -accessmemory. \"Memoria de Acceso Aleatorio\"  \n37 \n Tiene una comun idad de desarrolladores  grande al ser una plataforma  de \nsoftware libre y de c\u00f3digo abierto . [19][20][21]  \n\uf0b7 Linux : Sistema operativo multiplataforma, desarrollado para las \narquitecturas x86, x86 -64 y ARM. Por lo cual puede ser ejecutado tanto en \ncomputadores convencionales como en sistema s embebidos,  aunque \nmuchas de las aplicaciones para Ubuntu est\u00e1n para las tres arquitecturas \nhay herramientas de compilaci\u00f3n cruzada gratuitas para llevar las \naplicaciones de una arquitectura a otra.[22][23][24][26]  \n \n4.5.  Pure Dat a \n \nEs un entorno de programaci\u00f3n por medio de bloques  para audio, video y \nprocesamiento de imagen . Es un software libre  desarrollado por Miller Puckette el \ncual tiene una gran cantidad de desarrolladores trabajando en nuevas librer\u00edas, \npor lo que todo el p aquete es en gran medida un  esfuerzo de la comunidad.17 \n \nEs un sistema  multiplataforma  en software , por lo que es muy port\u00e1til, existen \nversiones para Win32, IRIX, GNU / Linux, BSD, Mac  OSX y se ejecuta en \ncualquier equipo.  \n \n \nFue creado con el fin de  explor ar maneras alternativas de programaci\u00f3n por \nbloques, y para  que la implementaci\u00f3n de  aplicaciones en audio y MIDI  se \nextendiera a gr\u00e1ficos y v\u00eddeo.  \n \nPure Data cuenta con librer\u00edas externas que  son escritas en el lenguaje de \nprogramaci\u00f3n C++ , estas son de sarrolladas por los mismos usuarios y con el \ntiempo se incluyen en las librer\u00edas est\u00e1ndar de Pure Data .[27] \n \n \n                                            \n17La p\u00e1gina web de la comunidad de Pure Data es:  http://puredata.info/  38 \n  \nFig. 11 Secci\u00f3n de documentaci\u00f3n e informaci\u00f3n de Pure Data . Fuente: Propia  \n \n \n \n \n \n \n \n \n39 \n \n 5. DESARROLLO INGENIERIL  \n \n \nEn el proyecto de grado se desarroll \u00f3 un controlador MIDI no convencional \nimplementado en un sistema embebido, utilizando el Kinect . El sistema  utiliza el \nprotocolo MIDI para controlar hardware o software remoto v\u00eda WiFi por  medio de la \ncaptura de movimientos. El de sarroll\u00f3  se describe en  el diagrama de bloques \npresentado en la Figura 13. A continuaci\u00f3n se describen las  etapas de desarrollo \ndel proyecto:  \n \n5.1.  Adecuaci\u00f3n S. E. \n \nLos S.E. son dispositivos desarrollados a partir de un co -dise\u00f1o \nhardware/software, el cual se basa en la interacci\u00f3n d e los dos componentes de \nuna forma eficiente, con el fin de mejor ar los procesos del sistema.  \n \nEn el proyecto se implementaron sistemas embebidos comerciales , por lo que fue  \nnecesario determinar cu\u00e1l era el sistema operativo \u00f3ptimo para trabajar , se util iz\u00f3 \nLinux la distribuci\u00f3n de Ubuntu, puesto que es un S.O. vers\u00e1til, tiene un gran \nsoporte, es libre, adaptable y tiene fuentes de desarrollo completas.  [18] Estas \nventajas son las principales motivaciones por las cuales se emplea el Linux en el \ndesarrollo  de la tesis. Existen diferentes  versiones las cuales est\u00e1n dise\u00f1adas  \nespec\u00edficamente  para cada  procesador o memoria , con el fin de  obtener un mejor \nrendimiento dependiendo del hardware, algunas son pre-cargadas  con m\u00f3dulos \ninnecesarios y pueden afectar el  rendimiento del mismo.  \n \n \n \n \nFig. 12 Diagrama de bloques Adecuaci\u00f3n  S.E. Beagleboard C3  \nCompilaci\u00f3n Sistema \nOperativo  \nInterfaces Graficas de \nUbuntu  Beagleboard xM  \nCompilaci\u00f3n Sistema \nOperativo  \nInterfaces Graficas de \nUbuntu  Pandaboard ES  \nCompilaci\u00f3n Sistema \nOperativo  \nInterfaces Graficas de \nUbuntu  \nAdecuacion S.E.  \n 40 \n  \nFig. 13 Descripci\u00f3n Desarrollo Controlador MIDI con Convencional  \n41 \n 5.1.1  Compilaci\u00f3n Sistema Operativo  \n \n \nSe efectu\u00f3 el an\u00e1lisis de varias versiones de Ubuntu en tres sistemas embebidos \ndiferentes, con im\u00e1genes pre compiladas e im\u00e1genes compiladas manualmente, el \nproceso del desarrollo general para obtener la versi\u00f3n \u00f3ptima  se describe en el \ndiagrama de bloque de la Figura 14.  \n \n \nFig. 14 Descripci\u00f3n proceso instalaci\u00f3n Ubuntu en sist emas embebidos  Sistemas Operativos Embebidos  \nCompilacion Paso -a-Paso  \nKernel - RFS - GUI \nCross Compilaci\u00f3n  \nInstalaci\u00f3n  \nPrueba  \nError  Pre Compiladas  \nCross Compilaci\u00f3n  \nInstalaci\u00f3n  \nPrueba  \nError  42 \n 5.1.1.1.  Compilaci\u00f3n Paso -a-Paso  \n \nEl Kernel es el encarga do de gestionar y controlar directamente los recursos de \nhardware, este fue escogido en base a las recomendaciones dadas por las \nversiones de Ubuntu.  El RFS o sistema de Archivos Ra\u00edz son los archivos  \nencargados  del arranque del sistema operativo, poseen  una estructura de \ndirectorios jer\u00e1rquicos  en forma de \u00e1rbol, donde se almacenan aplicaciones, \nlibrer\u00edas y archivos de trabajo. La GUI o interfaz gr\u00e1fica  de usuario es la que se \nencarga de brin dar un entorno grafico amigable con el usuario, permitiendo su \nconfiguraci\u00f3n  por medio de ventanas, men\u00fas , explorador de archivos.  [18] \n \n \nFig. 1 5 Arquitectura general de un Sistema de Linux Embebido  [39] \n \nEn la Figura 15 se presenta  la estructura de l Kern el, el cual se compone  de: la  \nInterfaz de Bajo Nivel  y la  Abstracci \u00f3n de Alto Nivel, generalmente es \nindependiente del hardware  y provee abstracciones comunes a todos los sistemas \nUnix, incluyendo  procesos, archivos, sockets y se \u00f1ales. Entre estos dos niv eles se \nencuentran  los Componentes de interpretaci \u00f3n, interact \u00faan con las  estructuras de \ndatos recibidas o transmitidas por los dispositivos. Los tipos  de sistemas de \narchivos (FAT 32, NTFS, EXT2, EXT3, EXT4 ) y los protocolos  de red son ejemplos \nde estructu ras de datos.  \n \nCuando el K ernel se encuentra operando, requiere manejar una estructura  \nadecuada del sistema de archivo, que se denomina  RFS el cual es cargado al \nmomento del arranque del sistema  operativo,  en este caso solo  carga librer\u00edas \n43 \n necesarias para su ejecuci\u00f3n, por lo que si se requieren m\u00e1s deber\u00e1n ser \ninstaladas manualmente. Una vez se tienen  determinados estos par\u00e1metros se  \nenlazan gracias al script18 de cross compilaci\u00f3n : [18] \n \nSetup_sdcard.sh  \n \nEl comando  se encarga de preparar la memoria para q ue inicie desde un Sistema \nEmbebido como se observa en la Figura 16 , el script crea la partici\u00f3n de arranque \ndonde se encuentra el Kernel del sistema y la partici\u00f3n de archivos de ejecuci\u00f3n \nRFS.  \n \n \nFig. 16 Ventana compilaci\u00f3n Ubuntu minimal . Fuente: Propi a \n \nAl finalizar se inserta la memoria en el Sistema Embebido y se corren los \ncomandos necesario para instalar la GUI previamente escogida dependiendo del \nmismo.  \n \n                                            \n18 Conjunto de instrucciones generalmente almacenadas en un archivo de texto que deben ser \ninterpretados l\u00ednea a l\u00ednea en tiempo real para su ejecuci\u00f3n  \n44 \n Se realizan las pruebas del sistema operativo, en las que se analiza velocidad de \ninicio, si e l sistema es estable, si soporta las librer\u00edas  necesarias, etc. Esto \nesperando encontrar el sistema ideal con la interfaz gr\u00e1fica  adecuada para su \n\u00f3ptimo  funcionamiento.  \n \n5.1.1.2.  Imagen Pre -Compila da \n \nPor este m\u00e9todo  contamos con im\u00e1genes  desarrolladas oficialment e por Ubuntu \nen las que se encuentra un Kernel, RFS y GUI definidos, existen diferentes \nversiones  para cada  tipo de  Sistemas  Embebidos . \n \nLa imagen pre -compilada contiene un paquete de librer\u00edas m\u00e1s amplio lo cual las \nhace m\u00e1s densas que la versi\u00f3n minimal , pero ahorran mucho tiempo a la hora de \ndescargar librer\u00edas  extra o activar m\u00f3dulos  del Kernel. S e cross -compilan con el \ncomando:  \n \n$ zcat ./\"Nombre de la imagen\" |sudo dd bs=4M \nof=/dev/\"direcci\u00f3n dispositivo SD\" ; sudo sync  \n \nAl finalizar el script  como se  muestra en la Figura 17 se inserta  la memoria  en el \nsistema embebido, y a comparaci\u00f3n con en el m\u00e9todo Paso -a-Paso,  este va a \niniciar una interfaz gr\u00e1fica  autom\u00e1ticamente, la cual guiar\u00e1  al usuario a  trav\u00e9 s de la \ninstalaci\u00f3n del Sistema O perativo, similar  al proceso que se lleva en una \ncomputadora com\u00fan.  \n \nUna vez instalado se hacen las pruebas necesarias para determinar el sistema \noperativo ideal para el sistema, siguiendo los mismos par\u00e1metros analizados en el \nprimer m\u00e9todo: velocidad de i nicio, si el sis tema es estable o  si soporta las \nlibrer\u00edas necesarias . \n \n 45 \n  \nFig. 1 7 Ventana creaci\u00f3n imagen pre compilada . Fuente: Propia  \n \n \n5.1.1  Interfaces Graficas de Ubuntu  \n \nExisten varias interfaces gr\u00e1ficas que se pueden implementar en Ubuntu y son \nvariaciones del mismo, al gunas de ellas son Kubuntu, Lubuntu y Xubuntu. Estas \ndistribuciones incluyen algunos de los paquetes esenciales pero con interfaces \ngr\u00e1ficas ligeras.  \n \nLas cinco  interfaces utilizadas fueron KDE, LXDE, XFCE, Gnome y Unity. Gnome \nsol\u00eda ser el est\u00e1ndar en U buntu hasta la llegada de Unity una interfaz  m\u00e1s \ncompleta pero a su vez m\u00e1s pesada, est\u00e1 incluida desde la versi\u00f3n 11.04 de \nUbuntu.  \n \n \n \n \n \n46 \n 5.1.1.1  XFCE  \n \nLa interfaz XFCE fue la primera en ser implementada, con esta se obtuvieron \nmejoras  en cuanto a rendimiento, perm itiendo al usuario poder ingresar a los \ndiferentes men\u00fas, instalar software complementario y configurar sus perif\u00e9ricos \ndesde la interfaz gr\u00e1fica. El problema surge al instalar programas de \nprocesamiento digital de se\u00f1ales,  el monitor de memoria alcanza  el 80% de la \nmemoria por ende  disminuye el rendimiento del sistema .  \n \n$ sudo apt -get install xfce  \n \n \nFig. 1 8 Interfaz Gr\u00e1fica Xfce . Fuente: Propia  \n5.1.1.2  KDE  \n \nLa interfaz KDE surge de la necesidad de buscar un mejor rendimiento de la \nBeagleboard y aunque el rendi miento aument\u00f3 con respecto al Unity, no superaba \nal XFCE  ya que tan solo ejecutar la terminal e instalar paquetes por m\u00e1s sencillos \nque fueran, el monitor de memoria alcanzo el 100% por ello se descart\u00f3 su \nimplementaci\u00f3n . \n \n$ sudo apt -get install kde  \n47 \n  \nFig. 19 Interfaz Gr\u00e1fica Kde . Fuente: Propia  \n \n \n5.1.1.3  Gnome  \n \nLa interfaz Gnome es una interfaz eficiente para trabajar , las distribuciones de \nUbuntu que incluye Gnome pod\u00edan ser instaladas en computadoras con \nprocesadores mono n\u00facleo y con poca memoria RAM, s e concluye que puede se r \nuna soluci\u00f3n \u00f3ptima. Al hacer el proceso de cross -compilaci\u00f3n en la Beagleboard \nse encuentra una mejora con respecto a KDE pero aun as\u00ed no superaba a XFCE  el \ncual era el objetivo. Es una interfaz muy amigable y muy conocida por los usu arios \nantiguos de Ubuntu entonces esa es una ventaja sobre el XFCE  a pesar de su \nrendimiento.  \n \n$ sudo apt -get install gnome -panel \n48 \n  \n \n \nFig. 20  Interfaz Gr\u00e1fica Gnome . Fuente: Propia  \n \n \n5.1.1.4  LXDE  \n \n \nLa interfaz LXDE es una interfaz ligera donde  programas de proce samiento digital \nde se\u00f1ales tienen un mejor rendimiento  y el sistema tiene un comportamiento  m\u00e1s \nestable , teniendo en cuenta lo anterior se llevaron a cabo las primeras  pruebas de \nenv\u00edo MIDI a trav\u00e9s de red.  \n \n$ sudo apt -get install lxde  \n \n \n49 \n  \nFig. 2 1 Interf az Gr\u00e1fica Lxde . Fuente: Propia  \n \n5.1.1.5  Unity  \n \nLa interfaz gr\u00e1fica  Unity fue implementada \u00fanicamente  en la Pandaboard  ES \ndebido  a su procesador doble n\u00facleo , es una interfaz m\u00e1s amigable con el usuario  \npero a su vez consume una cantidad considerable de recursos del sistema . Se \ninstala con el comando:  \n \n$ sudo apt -get install ubuntu -desktop \n \n \n \n50 \n  \nFig. 22  Interfaz gr\u00e1fica Unity . Fuente: Propia  \n \n5.1.2  Sistemas Embebidos Implementados  \n \nEstos procesos se llevaron a cabo en los siguientes sistemas embebidos: \nBeagleboard  C3, B eagleboard  xM y Pandaboard ES. A con tinuaci\u00f3n se describe el \nprocedimiento  espec\u00edfico  para cada uno:  \n \n5.1.2.1  Beagleboard  C3 \n \nPara el  desarrollo en este Sistema Embebido  es importante  tener un buen manejo \nde herramientas de cross -compilaci\u00f3n , debido a sus limitado s recursos de \nhardware es  necesario conocer como optimizar el sistema , los resultados \nobtenidos fueron los siguientes:  \n \nLas pruebas in\u00edciales se llevaron a cabo en la  versi\u00f3n 11.04 de Ubuntu, se trabaj\u00f3  \nla cross -compilaci\u00f3n de Kernel y Root File System pre -compilados por el grupo de \ndesarrollo de Ubuntu , para  esto se ejecuta el comando : \n \n51 \n $ zcat ./ubuntu -11.04-preinstalled -headless -\narmel+omap.img.gz |sudo  dd bs=4M of=/dev/sdX ; sudo sync  \n \nAl compilar la imagen en la tarjeta SD se instalaron paquetes de ini cio que hicieron \ntardar m\u00e1s de lo normal el inicio del sistema , por lo que la descompresi\u00f3n del \nsistema tarda m\u00e1s de lo esperado . Se intent\u00f3 arreglar e l problema desinstalando \nmanualmente los paquetes pero sin obtener un mejor  rendimiento del S.E.  \n \nEl sigu iente sistema operativo fue Ubuntu 11.10, aunque las mejoras  obtenidas no \nfueron significativas  para el funcionamiento de varios programas simult\u00e1neamente . \nLa ventaja en cuanto a la versi\u00f3n 11.04 fue la implementaci\u00f3n de controladores de \nvideo dise\u00f1ados pa ra este sistema embebido. Se compila en la SD con el \nsiguiente comando:  \n \n$ zcat ./ubuntu -11.10-preinstalled -desktop-armel+omap.img.gz \n|sudo dd bs=4M of=/dev/sdX ; sudo sync  \n \nPor \u00faltimo se implement\u00f3 una compilaci\u00f3n paso -a-paso , utilizando un Kernel con \n\u00fanicamente los m\u00f3dulos necesarios para el arranque del sistema  y de los \nperif\u00e9ricos. Se dise\u00f1o una imagen optimizada para el funcionamiento exclusivo en \nla Beagleboard  C3. \n \nEstas im\u00e1genes son llamadas Ubuntu minima l y no incluyen interfaz gr\u00e1fica, el \nproces o de instalaci\u00f3n debe empezar desde la conf iguraci\u00f3n de la tarjeta de red \nhasta la instalaci\u00f3n de paquetes por medio de la terminal utilizando comandos \nshell. El Primer  paso a seguir es descarga r y se descomprimir  la imagen:  \n \n$ wget http://rcn -ee.net/deb/r ootfs/natty/ubuntu -11.04-r7-\nminimal-armel.tar.xz  \n$ tar xJf ubuntu-11.04-r3-minimal-armel.tar.xz  \n \nEn esta carpeta se encuentra el script que ejecuta  todo el proceso, en este punto \nse puede seleccionar Kernel y Root File System, pero es recomenda ble utiliza r los \nque est\u00e1n incluidos en la im agen:  \n \n$ sudo ./setup_sdcard.sh --mmc /dev/sdX \u2013uboot beagle_cx  \n \nAl iniciar la Beagleboard se  debe configura la red para poder descargar  librer\u00edas, \ncontroladores de video y paquete s de desarrollo . \n 52 \n $ sudo if config \u2013a \n$ sudo dhclient eth0 -v \n$ sudo apt -get update  \n$ sudo apt -get upgrade  \n$ sudo apt-get install xserver -xorg-video-omap3 network -          \nmanager build -essential libavformat -dev ffmpeg cmake \n \nAl realizar las  pruebas con el Kinect se presenta una limitante de p rocesamiento , \ndebido a que este requiere un mejor procesador,  por lo cual este Sistema \nEmbebido puede funcionar como un controlador MIDI inal\u00e1mbrico, pero la  \nrecepci\u00f3n de datos se debe hacer por medio de interfaces que no  realicen \nprocesamiento de im\u00e1gene s, por su limitaci\u00f3n de hardware.  \n \n \nFig. 2 3 Beagleboard  C3. Fuente: Propia  \n \n5.1.2.2  Beagleboard  xM \n \nDebido a l as limitaciones  de hardware de la Beagleboard C3, surge la necesidad \nde adquirir un n uevo sistema embebido con  un mejor p rocesador y memoria para \nobtener  mejores resultados . \n \nSe llev\u00f3 un pro ceso de compilaci\u00f3n similar  al de la Beagleboard C3 con la \ndiferencia que este disminuye el tiempo de instalaci\u00f3n y el procesamiento en \ngeneral es m\u00e1s eficiente por lo que se pudo probar m\u00e1s distribuciones de Ubuntu \ncon diferentes interfaces gr\u00e1ficas.  \n53 \n  \nSe trabaj\u00f3  con la image n pre compilada de Ubuntu 12.04, esta se tom\u00f3 alrededor \nde diez minutos en su descompresi\u00f3n e instalaci\u00f3n , se obtuvo  un Ubuntu similar al \nde escritorio , exitosamente se pudo enviar mensajes MIDI por WiFi y el \nprocesa miento de se\u00f1ales fue aceptable, p ero surge n problema s con  los \ncontroladores del Kinect , no funcionaban de la forma esperada, por lo que este \nSistema Operativo Embebido no posee controladores optimizado s para el chip  de \nvideo, obteniendo  latencia al momento de adquirir y procesar los datos.  \n \nFue necesario volv er a la versi\u00f3n 11.10 de Ubuntu, s u descompresi\u00f3n e \ninstalaci\u00f3n fue exitosa y r\u00e1pida , su instalaci\u00f3n tard\u00f3 alrededor de diez minutos , se \ndescargaron los controladores y paquetes necesa rios para hacer  pruebas  con el \nKinect. Los resultados obtenidos no fueron \u00f3ptimos  a pesar de contar con \ncontroladores de video optimizados para la Beagleboard xM  y se dete rmin\u00f3 \nrealizar un cambio de GUI, por lo que se  crea la imagen espec\u00edfica  con el \ncoman do: \n \n \n$ sudo ./setup_sdcard.sh --mmc /dev/sdX --uboot beagle_xm  \n \n \nAl incluir  controladores de video se escoge la versi\u00f3n 11.10 de Ubuntu con el fin \nde optimizar el sistema , se descarga l a versi\u00f3n m\u00ednimal de esta versi\u00f3n y  se \nimplement \u00f3 un Kernel op timizad o, al contar con mejor procesador se decide \ninstalar no solo la interfaz gr\u00e1fica si no todo el entorno de desarrollo, en este caso \nal obtener el mejor rendimiento con L XDE en la Beagleboard  C3, se escoge e l \nentorno de desarrollo Lubuntu,  con esto se obtien e un completo funcionamiento de \nlos servicios, y no es necesario activar los m\u00f3dulos  MIDI ni de red manualmente.  \n \n$ sudo apt -get install lubuntu -desktop \n \n \nSe logr\u00f3  optimizar el sistema  obteniendo mejores resultados del procesamiento de \nimagen y sonido, su  latencia fue m\u00ednima con lo que la ad quisici\u00f3n de datos se \npudo  hacer en tiempo real, se probaron los ensambles de Pure Data con los \ndrivers Freenect del Kinect y el resultado fue exitoso , se logr\u00f3  la captura de datos \nde profundidad convirti\u00e9ndolos en men sajes MIDI para posteriormente enviarlos \npor medio de WiFi.  \n 54 \n Buscando implementar la \u00faltima generaci\u00f3n se sistemas embebidos  se encuentra \nuno con mejor  procesamiento a un costo considerablemente bajo teniendo en \ncuen ta su mejor a en cuanto a hardware.  \n \n \nFig. 2 4 Beagleboard  xM. Fuente: Propia  \n \n5.1.2.3  Pandaboard ES  \n \n \nLas caracter\u00edsticas de hardware  de la  Pandaboard son superiores a  las de la  \nBeagleboard , proporcionando una mejor rendimiento  gracias al procesador doble \nn\u00facleo , debido a este  no existe la necesidad d e utilizar im\u00e1genes co mpiladas \nmanualmente, la idea era  minimizar el proceso teniendo en cuenta todo el \ndesarrollo ingenieril realizado en  las dos Beagleboard son la base para poder \nimplementar y entender otros tipos de sistemas  m\u00e1s complet os. \n \nSe utiliza n im\u00e1genes pre -compiladas , la ventaja es que los paquetes innecesarios \nno afectan al sistema,  si se quisiera compilar una interfaz gr\u00e1fica m\u00e1s ligera para \noptimizar m\u00e1s el sistema se podr\u00eda realizar el proceso manual de compilaci\u00f3n  con \nlos mismos comandos utilizados en los otros S.E.  \n \nPara la instalaci\u00f3n y cross -compilaci\u00f3n del Ubuntu 12.10,  se propone un nuevo \nsistema de instalaci\u00f3n que funciona exclusivamente para sistemas  OMAP 4, \n55 \n donde la creaci\u00f3n de la SD se hace desde el mismo S.E., utilizando  una memo ria \nUSB para iniciar  el sistema y continuar  el proceso de instalaci\u00f3n tal cual se har\u00eda \nen su versi\u00f3n para escritorio,  al parecer es sencillo  pero al ser tan rec iente no es \ncompatible con mucha s librer\u00edas  ya probados anterior mente , esta imagen solo se \ncrea con el fin de conocer el nuevo proceso y ver el rendimiento de esta S.O.  \n \n \n \nFig. 25 Pandaboard  ES. Fuente: Propia  \n \nDespu\u00e9s de varias pruebas se decide implementar la versi\u00f3n 12.04 de Ubuntu con \ninterfaz gr\u00e1fica Gnome y Unity , se logra ejecutar  el tiempo real el Kinect y  los \ncambio s son  notorio s con respecto a la Beagleboard , obteniendo un \nprocesamiento de se\u00f1ales m\u00e1s eficiente.  [Ver Tabla 3]  \n \n \n \n \n \n \n \n \n \n \n \n \n56 \n   Beagleboa rd C3 Beagleboard  xM Pandaboard ES  \nProcesador  720 MHz  1 GHz  1.2 GHz  \nTipo de \nProcesador  ARMCortexA8  ARMCortexA8  Dual Core ARM Cortex -A9 \nMemoria RAM  256 MB  512 MB  1 GB  \nGPU  PowerVR  SGX530  PowerVR  SGX2D/3D  PowerVR  SGX540 @ \n384 MHz  \nSalida de Video  DVI-D,  S Video  DVI-D,  S Video  DVI-D, HDMI (Full HD)  \nTipo de Memoria  SD MicroSD  SD \nEthernet  No Si Si \nWiFi  No No Si \nBluetooth  No No Si \nPower  Supply  5V 5V 5V \nPuertos de \nSonido  Conector 3.5 mm \nI/O Conector 3.5 mm \nI/O Conector 3.5 mm I/O  \nPuertos USB  1 4 2 \nCosto  US$ 125  US$ 149  US$ 162  \nDimensiones  7.62 cm x 7.62 cm  8.25 cm x 8.25 cm  10 cm \u00d7  11 cm \nTabla 3 Comparaci\u00f3n especificaciones sistemas embebidos  [36][37]  \n \nDespu\u00e9s de las diferentes pruebas se llega a la conclusi\u00f3n que la Pandaboard ES \nes la mejor opci\u00f3n  por la relaci\u00f3n de costo -beneficio  como se observa en la tabla \n3, a pesar de eso no se d escarta  la implementaci\u00f3n de m\u00e1s proyectos en la \nBeagleboard , a pesar de sus prestaci\u00f3n de hardware tambi\u00e9n demuestra una gran \ncapacidad de desarrollo en el campo de la ingenier\u00eda de sonido.  \n \n \n5.2. Transmisi\u00f3n mensajes MIDI  por WLAN  \n \nEn este proceso es necesari o conocer el funcionamiento y configuraci\u00f3n de los \nrouters, de la red con  IP est\u00e1tica y  la cross -compilaci\u00f3n del  software para \ntransmitir MIDI por medio del protocolo UDP , como se presenta en la Figura 26. \n \n \n \n 57 \n \n  \n \n \n \n \nFig. 2 6 Transmisi\u00f3n Mensajes MIDI  \n \n \n \n5.2.1.  Configuraci\u00f3n Router para una Red Local Inal\u00e1mbrica (WLAN)  \n \nLos routers actuales son dise\u00f1ados  para ser configurados por usuarios finales con \no sin experiencia  para la creaci\u00f3n de una red local inal\u00e1mbrica (WLAN), el primer \npaso es determinar si se desean d irecciones IP est\u00e1ticas o din\u00e1micas, las IPs \ndin\u00e1micas brindan  la posibilidad de tener un rango amplio de direcciones \ndisponibles para la conexi\u00f3n de dispositivo WiFi, este asigna autom\u00e1ticamente \nestas direcciones para no tener conflicto de conexi\u00f3n.  \n \nLas IPs est\u00e1t icas est\u00e1n limitadas a las IPs  configuradas, esta configuraci\u00f3n \ntambi\u00e9n debe ser aplicada en el dispositivo asign\u00e1ndole una de las IPs \nconfiguradas previamente, provee mayor seguridad pero es menos pr\u00e1ctica y m\u00e1s \ncomplicada para un usuario final sin experiencia.  \n \n \n \nConfiguraci\u00f3n \nRouter  \nConfiguraci\u00f3n \nde Red en \nUbuntu  \nCodificaci\u00f3n y \nenv\u00edo de MIDI  \nImplementaci\u00f3n \ny Pruebas de \nTransmisor  \nRouter  \nTransmisi\u00f3n Mensajes  \nMIDI por WLAN  \n 58 \n 5.2.2.  Configuraci\u00f3n de Red en  Ubuntu  \n \nLa configur aci\u00f3n se realiza con direcciones IPs  din\u00e1micas en el router , se le \nasigna un a direcci\u00f3n fija al Sistema Embebido con el fin de implementar la funci\u00f3n \nde escritorio remoto  como se muestra en la Figura 27 de forma r\u00e1pida y sencilla  \npara evitar conectar una  pantalla al puerto HDMI.  \n \nPrimero  se debe  conocer el rango el cual fue configurado el router y la puerta de \nenlace, luego  se modifican  las configuraciones de red  del embebido , de forma \ngr\u00e1fica  o por l\u00ednea  de comando . \n \nEn la ventana de conexiones se encuentran  las pesta\u00f1as de Cableada o \nInal\u00e1mbrica  como se muestra en la Figura 5 3, dependiendo de la conexi\u00f3n del \ndispositivo se elegir\u00e1 uno de los dos, en  cualquiera de los dos casos se selecciona \nla conexi\u00f3n activa y se edita  IPv4, dentro de esta pesta\u00f1a se modifica el m \u00e9todo \nde Autom\u00e1tico  a Manual  y se agregan las opciones de: Direcci\u00f3n, M\u00e1scara de red \ny Puerta de  enlace , se ingresa preferiblemente  una de las ultimas direcciones de \nred del rango dis ponible para no tener conflictos con la direcci\u00f3n de los dem\u00e1s \ndispositivo; en M\u00e1scara de red se ingresa: \"255.255.255.0\"  y al final  la puerta de \nenlace  que es la direcci\u00f3n IP del router.  \n \nPara hacer la configuraci\u00f3n  por l\u00ednea  de comando  es necesario modif icar el \narchivo interfaces  \n \n$ sudo vim /etc/network/interfaces  \n \nSi dentro del archivo  existen comandos como:  iface , eth0, inet o dhcp , se deben  \nborrar para evitar conflictos  y se agregara las configuraciones de red, para esto se \ndebe determinar la interf az de red que se quiera utilizar, ya sea eth0 para la \ninterfaz cableada, o wlan0  para la inal\u00e1mbrica, dependiendo de eso el archivo \ncambiara, a continuaciones se muestra un ejemplo para la interfaz cableada:  \n \n \n# Configuraci\u00f3n  IP est\u00e1tica en eth0  \nauto eth0  \niface eth0 inet static  \naddress x .x.x.x \ngateway x. x.x.x \nnetmask 255.255.255.0  59 \n  \nSe cambian los valores  deseados, donde Address  es la direcci\u00f3n IP que se le \nquiere designar al dispositivo y Gateway es la puerta de enlace del router , una vez \nconfigurado se de ben reiniciar los servicios de red para que surta efecto con el \nsiguiente comando:  \n \n$ sudo /etc/init.d/networking restart  \n \nCon esto se finaliza  la configuraci\u00f3n  de red, para comprobar  que todo haya \nquedado correctamente configurado se ejecuta ifconfig  para conocer el estado de \nlas interfaces de red activas, en el cual se presentan  los par\u00e1metros modificados \npreviamente.  \n \n \n \n \nFig. 27 Implementaci\u00f3n escritorio remoto desde una Tablet . Fuente: Propia  \n \n \n \n60 \n 5.2.3.  Codificaci\u00f3n y env\u00edo de MIDI  \n \nEl protocolo de Datagrama de Usuario se implementa sin la necesidad de una \nconexi\u00f3n, func iona a trav\u00e9s de direcciones IP y  ofrec e un enlace directo para  \nenviar y recibir datagramas, por lo que se utiliza para enviar audio a trav\u00e9s de \nredes. La ventaja que ofrece el empaquetamiento de datos por medio de \ndatagramas es que se maneja de forma independiente; y Al no requerir conexi\u00f3n \nse pueden enviar datos sin la necesidad de proporcionar direcci\u00f3n IP o nombre del \nequipo receptor, est\u00e9 posee la facultad de ser multicast, mientras el rece ptor \nposea el decodificador podr\u00e1 recibir los datos MIDI, solo se debe asignar un puerto \npara conocer qu\u00e9 puerto debe ser habilitado por el receptor, cada puerto cuenta \ncon los 16 Canales MIDI predeterminados del protocolo, por lo que se cuenta con \nun gran  n\u00famero de canales MIDI para enviar datos independientes.  \n \n \nFig. 28 Diagrama de flujo codificaci\u00f3n y envi\u00f3 MIDI  \n \n5.2.4.  Implementaci\u00f3n y Pruebas Transmisor MIDI  QmidiNet  \n \nLa compilaci\u00f3n de este software se realiza utilizando la herramienta GCC, al tener \nacceso a l c\u00f3digo fuente se puede portar la aplicaci\u00f3n a diferentes plataformas, se \ncompila utilizando los comandos:  \n \nFig. 29 Diagrama conexi\u00f3n QmidiNet  Mensajes \nMIDI  Codificador \nUDP  WLAN  \nQmidiNet  \nMIDI IN  \nRouter  JACK  Pure  Data  \n\u2022MIDI OUT  61 \n $ ./configure  \n$ make \n \nLa interfaz  gr\u00e1fica permite  escoger interfaz de transmisi\u00f3n:  red al\u00e1mb rica o \ninal\u00e1mbrica , puerto UDP, n\u00famero de puertos y secuenciador MIDI, es \nrecomendado utilizar ALSA.  \n \n \nFig. 30 Interfaz de configuraci\u00f3n QmidiNet.  Fuente: Propia  \n \nUna vez configurado  se ingresa a JACK donde aparecen las conexiones MIDI de \nSistema Embebido como lo muestra la Figura 26, en la interfaz s e pueden \ninterconectar los software que posean  entradas y salidas MIDI, como ejemplo se \nconecta la salida MIDI 1 de Pd a la entrada del puerto 0 de QmidiNet para enviar \nlos datos generados de Pd hacia otro dispositivo.  \n \n \nFig. 31 Entradas y Salidas MIDI de Ubuntu.  Fuente: Propia  \n62 \n \n 5.3.  Integraci\u00f3n Kinect  \n \nEsta fase se divide en 3 partes las cuales son cross -compilaci\u00f3n de Pure Data \nExtended, integraci\u00f3n de los  controladores  del Kinect e integraci\u00f3n de Pure Data -\nKinect, como lo descri be la Figura 32.  \n \n \n \nFig. 32  Integraci\u00f3n Kinect  \n \n5.3.1.  Compilaci\u00f3n Pure Data Extended  \n \nPure Data tiene versiones disponibles para diferentes arquitecturas  y Sistemas \nOperativos,  en Ubuntu est\u00e1 incluido dentro de sus repositorios  pero no la versi\u00f3n \nextended , la cual se debe implementar  debido a sus d iferentes \u201cExternals\u201d , El \ndiagrama de bloques de la Figura 33 describe el proceso de cross -compilaci\u00f3n:  \n \nIntegracion Pure \nData -Freenect  \nIntegraci\u00f3n \nControladores \nKinect  \nCompilaci\u00f3n \nPure Data \nExtended  \nIntegraci\u00f3n Kinect  \n 63 \n  \n \nFig. 33  Descripci\u00f3n proceso compilaci\u00f3n Pure Data Extended  \n \n \nEl primer paso es instalar todos los paque tes necesarios para poder compilar Pure \nData Extended los cuales son: \n \n$ sudo apt -get install  build-essential  git subversion \nlibmp3lame0 libmp3lame -dev ladspa -sdk dssi -dev libimlib2 -dev \nlibtheora -dev libjack0 libjack -dev fakeroot puredata gem \nttf-dejavu li bfftw3-dev libspeex -dev libvorbis -dev  libflac-\ndev libsndfile1 -dev libgavl -dev libmad0 -dev dssi -dev liblo -\ndev flite1 -dev libtk -img tcllib libmp3lame0 libmp3lame -dev \nlibimlib2 -dev libtheora -dev libusb -0.1-4 libusb -dev \nliblua5.1 -0-dev lua5.1 tcl8.5 -de swig l ibnetpbm10 -dev ruby \nnasm libcv -dev libdc1394 -22-dev \n \nSe debe descargar los c\u00f3digos fuente de  Pd Extended, \u201cExternals\u201d  de Pd \nExtended y Gem de la siguiente manera:  \n Archivos Base Pd \nExtended  \nEnlaces  \nExternals  \nCross \nCompilaci\u00f3n  \nError  Paquetes  \nInstalaci\u00f3n  \n64 \n git clone git://pure -data.git.sourceforge.net/gitroot/pure -\ndata/pd-extended.git  \n \nsvn co htt ps://pure -data.svn.sourceforge.net/svnroot/pure -\ndata/trunk pd -svn \n \ngit clone git://pd -gem.git.sourceforge.net/gitroot/pd -\ngem/Gem gem.git  \n \nA partir de estas carpetas se debe crear una carpeta que enlace  todo utilizando \naccesos directos de la siguiente mane ra:  \n \nCd pd-svn/ \nmv pd pd-original  \nln -s ../pd-extended.git  pd \n \nln -s ../gem.git Gem  \ncd externals  \nln -s ../../gem.git Gem  \n \n \nUna vez enlazados el archivo Make  para realizar la compilaci\u00f3n  se encuentra en la \nsiguiente carpeta:  \n \ncd pure-data/packages/linux_m ake \nmake install && make package  \n \n \nLa compilaci\u00f3n puede tardar dependiendo del Sistema Embebido entre dos y cinco \nhoras,  al final se obtendr\u00e1 el instalador  as\u00ed que e l proceso solo debe ser ejecutado \nuna vez mientras no se cambie de arquitectura.  \n \n 65 \n  \nFig. 34 Interfaz gr\u00e1fica principal de Pd Extended . Fuente: Propia  \n \n \n5.3.2.  Integraci\u00f3n Controladores Kinect  \n \nEstos controladores se implementan en dos sistemas embebidos  por cuesti\u00f3n de \nprocesamiento, el Freenect puede ser ejecutado desde la Beagleboard xM y la \nPandab oard ES.  \n \nLos paquetes necesarios  para compilar los dos controladores son los siguientes:  \n \n$ sudo apt -get install default -jre git-core cmake freeglut3 -\ndev pkg-config libxmu -dev libxi -dev libusb -1.0-0-dev doxygen \ngraphviz mono -complete g++python  gcc-multilib default -jdk \nlibcv-dev \n \n66 \n 5.3.2.1.  Instalaci\u00f3n Controladores Freenect  \n \n \nLos controladores freenect se compilan con  la herramienta cmake19 previamente \ninstalada , es importante con ceder  los permisos necesarios pa ra que funcionen \ncorrectamente, para esto se implementan  reglas de ejecuci\u00f3n.  \n \n \nFig. 35 Ventana de Comando de Compilaci\u00f3n Freenect , con el Kinect conectado a la \nPandaboard ES . Fuente: Propia  \n \nDentro de la carpeta K inect se inicia la descarga y la compilaci\u00f3n:  \n \ngit clone https://github.com/OpenKinect/libfreenec t.git \ncd libfreenect  \nmkdir build && cd build  \ncmake ..  \nmake \nsudo make install  \n                                            \n19 Es una herramienta de  compilaci\u00f3n  multiplat aforma de c\u00f3digo abierto, dise\u00f1ada para compilar, \ncomprobar y empaquetar so ftware  \n67 \n Al finalizar se agrega  al usuario de Ubuntu a los siguientes grupos:  \n$ sudo add user $USER video  \n$ sudo add user $USER  plugdev \n \nSe a\u00f1ade una regla de ejecuci\u00f3n para no tener la necesidad de ejecutarlo como \ns\u00faper usuario, para esto se edita el archivo \u201c51-kinect.rules\u201d se le agrega lo \nsiguiente:  \n \n$ sudo gedit /etc/udev/rules.d/51 -kinect.rules  \n \n#Rules for Kinect######################################  \nSYSFS{idVendor}==\"045e\", SYSFS{ idProduct}==\"02ae\", \nMODE=\"0660\",GROUP=\"video\"  \n \nSYSFS{idVendor}==\"045e\", SYSFS{idProduct}==\"02ad\", \nMODE=\"0660\",GROUP=\"video\"  \n \nSYSFS{idVendor}==\"045e\", SYSFS{idProduct}==\"02b0\", \nMODE=\"0660\",GROUP=\"video\"  \n### END############################################### ## \n \n \n \nFig. 36 Ejemplo imagen generada  por los controladores Freenect . Fuente: Propia  \n68 \n El controlador Freenect permite acceder al sistema multi -sensor de PrimeSense20, \ninstala nuevos m\u00f3dulos en el Kernel y agrega librer\u00edas al sistema.  \n \nLa Figura 37 muestra como es implementado el chip PS1080 SoC21, este es \nsistema multi -sensor, capaz de sincronizar la imagen de profundidad con la de \ncolor y a la vez capturar sonido. Todos los algoritmos de adquisici\u00f3n de datos de \nprofundidad se ejecutan dentro de este SoC, y con la facultad de enviarlos a otros \nsistemas por medio de un cable USB, gracias a esto puede ser implementado en \ndispositivos con capacidad limitada. [40]  \n \n \n \nFig. 37  Diagrama de control de PrimeSense [40]  \n \n \n \n \n \n                                            \n20 Compa\u00f1\u00eda encargada de fabricar el sistema multi -sensor para el Kinect  \n21 Tecnolog\u00edas de fabricaci\u00f3n que integran todos o gran parte de los m\u00f3dulos de un sistema \nelectr\u00f3nico en un  \u00fanico circuito integrado o chip.  \n69 \n 5.3.3.  Integraci\u00f3n Pure Data -Kinect  \n \nPara ejecutar  los ejemplos de P ure Data dise\u00f1ados para estos controladores es \nnecesario compilar dos \u201cExternals\u201d  fundamentales: pix_freenect  y pix_depth2rgba,  \nlos cuales se compilan utilizando los paquetes descargados de Pure Data y los \nm\u00f3dulos instalado por el freenect . \n \nEl primero en compilar es el pix_freenect, al descargarlo hay que  tener en cuenta \nque hay  dos archivos  Make  el de inter\u00e9s es el Makefile_linux , los otros se eliminan  \ny a est\u00e9 se le renombra como  Makefile, a continuaci\u00f3n se edita y se le da la ruta \nde ub icaci\u00f3n de la carpeta de Pure Data Extended, Gem  y Freenect. Al terminar se \ncierra y desde la terminal se ejecuta el comando :  \n \n$ make  \n \nSe copia el \u201cExternal\u201d  creado y el archivo de ayuda del Pd con los siguientes \ncomandos:  \n \n$ sudo cp *.pd_linux /usr/lib/ pd-extended/extra  \n$ sudo cp *.pd /usr/lib/pd -extended/doc/5.reference  \n \nSe compila el pix_depth2rgba de la misma manera, se modifica el archivo Make  y \nse compila, al finalizar  se copian las librer\u00edas y la ayuda de Pd:  \n \n$ sudo cp *.pd_linux /usr/lib/pd -extended/extra  \n$ sudo cp *.pd /usr/lib/pd -extended/doc/5.reference  \n \nAhora ya se pueden ver la imagen del Kinect a trav\u00e9s de Pd y su complemento \ngr\u00e1fico Gem.  \n 70 \n  \nFig. 38 Ensamble implementado en Pd para la captura de datos en el eje Z y X  \n \nEn la primera secci\u00f3n se encuentra l a caja principal del programa  pix_freenect  la \ncual se muestra en la Figura 39, esta cuenta con entradas y salidas, en las \nentradas se tienen propiedades, aceler\u00f3metro y Gem. pd properties  maneja qu\u00e9 \ntipo de imagen se desea mostrar, calidad de  imagen, control de led, control del \nmotor,  etc. A la salida se encuentran los datos RGB e infrarrojos , adicional se \npuede adquirir los datos del aceler\u00f3metro en 3 ejes.  \n \n \nFig. 39 Secci\u00f3n principal ensamble  \n \nEn la segunda secci\u00f3n del ensamble la cual se e ncuentra en la Figura 39, se hace \nla activaci\u00f3n de la interfaz de Gem, se  crea a partir de la caja de mensaje \u201cdimen \n640 480, create, 1\u201d donde se puede modificar la resoluci\u00f3n de la ventana de Gem; \n71 \n con la caja de mensajes \u201cdestroy \u201d se elimina la interfaz c reada,  adicionalmente \nesta la caja de pd android , la cual da acceso al TouchOSC para controlar el \nensamble a partir de dispositivos Android.  \n \n \nFig. 40 Secci\u00f3n activaci\u00f3n Gem  \nLa tercera secci\u00f3n se divide entre los datos obtenidos en el eje X y los datos de  \nprofundidad en el eje Z como se muestra en la Figura 41. \n \n \n \nFig. 41 Secci\u00f3n obtenci\u00f3n datos X y Z  \nLas cajas de n\u00famero  X y Z se utilizan para mostrar  los valor es capturados  en esos \ndos ejes respectivamente, los valores son enviados  a las cajas  pd MIDICTL  y pd \nMIDINOTE  respectivamente,  las que se muestran en detalle en las figuras 42 y 43 \n \n72 \n  \nFig. 42 Configuraci\u00f3n MIDICTL  \n \n \n \nFig. 43 Configuraci\u00f3n MIDINOTE  \n \n \n \n73 \n \n 5.4. Implementaci\u00f3n Controlador MIDI No Convencional  \n \nLa \u00faltima fase  donde se llevan a cabo pruebas y se  analizan los resultados par a \nsacar conclusiones acerca del  funcionamiento  del Kinect  sobre Sistemas \nEmbebidos , se describe  en la Figura 44. \n \n \n \n \n \n \n \n \nFig. 44 Descripci\u00f3n proceso de implementaci\u00f3n y prueba del sistema  \n \n5.4.1.  Recepci\u00f3n y Decodificaci\u00f3n  \n \nPara la recepci\u00f3n de los datos MIDI se utilizan el software ipMIDI, el cual es una \nversi\u00f3n de prueba para Windows, es un receptor de datagramas por medio del \nprotocolo UDP, se encarga de decodificar los da tagramas generando nuevamente \nmensajes MIDI, est\u00e9 cuenta co n 20 puertos y cada puerto con 16 canales MIDI, \ncon lo que se tiene un total de 32 0 canales MIDI independientes . \nRecepci\u00f3n  \n Decodificaci\u00f3n  \n Comprobaci\u00f3n  \nImplementaci\u00f3n  \nAn\u00e1lisis de \nResultados  \nConclusiones  \nProducctos  \nImplementaci\u00f3n Controlador \nMIDI No Convencional  74 \n  \nFig. 45 Diagrama de bloques recepci\u00f3n y decodificaci\u00f3n  \n \n5.4.2.  Comprobaci\u00f3n  \n \nLa recepci\u00f3n  es monitorizada con  el software MIDI -OX, el cual se encarg a de \nanalizar el puerto de entrada MIDI deseado y m ostrar  la informaci\u00f3n de los datos \nMIDI recibidos, co mo tipo de mensajes o velocidad,  la interfaz de usuario se \nmuestra en la Figura 46. \n \nPara comprobar que el receptor  est\u00e1 funcionando de forma correcta s e utiliza un \ncelular con sistema operativo Android para enviar mensaje s MIDI  desde la \naplicaci\u00f3n  TouchOSC, esto con el fin de asegurarse que las conexiones y los \npuertos de recepci\u00f3n sean los indicados.  \n \n \nFig. 46 Recepci\u00f3n de datos MIDI v\u00eda  WiFi a MIDI -OX. Fuente: Propia  WLAN  Decodificador \nUDP  Mensaje MIDI  \n75 \n Una vez se comprueba que el receptor est\u00e1 en funcio namiento se utiliza el \nKmidimon  para poder comprobar  los tipos de mensajes que se est\u00e1n enviando  \ndesde el Pure Data  o desde el VMPK que es un controlador MIDI virtual el cual se \nobserva en  la figura 57.  Este es  software similar a MIDI -OX pero para Linux.  \n \n \nFig. 47 Recepci\u00f3n de datos MIDI desde VMPK al Kmidimon.  Fuente: Propia  \n \n5.4.3.  Implementaci\u00f3n  \n \n \nLa implementaci\u00f3n se hace con el software FL Studio \u212222, el cual es  un software \namigable  para la  configuraci\u00f3n  de los mensajes MIDI  de control , se realiza  por \nmedio de  detecci\u00f3n con el fin de optimizar la conexi\u00f3n.  \n \nSe utiliza un sintetizador para la recepci\u00f3n de mensajes MIDI de Nota On/Off y el \ncontrol de Faders  con los mensajes de cambio de control.  \n \nLas Figuras 48 muestran el funcionamiento desde la Pandaboard  ES conectada \nremotamente a un computador de escritorio y a una Tablet  \n \n                                            \n22 Es un software de producci\u00f3n capaz de grabar en m\u00faltiples pistas, secuenciador y mezclador \npara producciones profesionales de alta calidad . \n76 \n  \nFig. 48 Implementaci\u00f3n Controlador MIDI no Convencional en Pandaboard ES . Fuente: \nPropia  \n \nLa Figura 49 muestra la panta lla principal del FL Studio y la configuraci\u00f3n del \npuerto de entrada MIDI por Ethernet  \nLa transmisi\u00f3n MIDI se lleva acabo exitosamente, con lo cual se logra la recepci\u00f3n  \nde mensajes MIDI desde un Sistema Embebido a un computador utilizando los \ndatos del K inect para el control  del sistema.  \n \n77 \n  \nFig. 49 Interfaz  principal FL Studio . Fuente: Propia  \n \n \n \nFig. 50 Captura de pantalla de la implementaci\u00f3n  en el FL Studio . Fuente: Propia  \n \n78 \n La adquisicion de datos del Pure Data se puede observar en la Figura 51, donde  a \npartir del desplazamiento de la persona en los ejes X y Z se generan mensajes \nMIDI de control y de nota On/Off que son adquiridos por el FL Studio como se \nobserva en la Figura 50, en la que el cambio de control es asiganado al control \nprincipal de volum en y las notas On/Off al sintetizador POIZONE23. \n \n \nFig. 51 Interfaz de captura de los datos del Kinect implementado en Pure Data . Fuente: \nPropia  \n \n \n \n  \n                                            \n23 Sintetizador substractivo dise\u00f1ado para realizar producciones profesional es, se puede \nimplementar como complemento VST o como aplicaci\u00f3n Standalone.  \n79 \n 6. AN\u00c1LISIS DE RESULTADOS  \n \n \nResultados  obtenidos  implementando el Sistema Embebido Pandaboard ES con \nsistema operativo Ubuntu 12.04 se presentan a continuaci\u00f3n : \n \n\uf0b7 Los datos obtenidos por el computador receptor corresponden a los \nenviados a trav\u00e9s de Pure D ata como efectivamente se comprob\u00f3  con el \nMIDI -OX y Kmidimon, esta precisi\u00f3n  se logr\u00f3 gracias a la segmentaci \u00f3n de \nimagen generada por el Kinect, el cual permite crear l\u00edmites de captura, en \neste caso, una distancia m\u00e1xima de 1.75m y una distancia m\u00ednima de 0.5m.  \n \n\u25cf El protocolo UDP  es confiable y r\u00e1pido para su implementaci\u00f3n  como \ntransmisor  MIDI , esto  se observ\u00f3 en los resultados obtenidos  donde el \ntiempo de respuesta fue instant\u00e1ne a. \n \n\u25cf La renderizaci\u00f3 n de imagen  realizada  por la Pandaboard ES  es \u00f3ptima y se \nmuestra de una forma fluida, el usuario puede realizar movimientos que se \nver\u00e1n proyectados en la pantalla  o en la tablet  de manera instant\u00e1nea  por lo \nque el usuario puede monitorizar los datos en tiempo real.  \n \n\u25cf Con este tipo de sistemas de captura no convencionales se pueden tener \nimprecisi\u00f3n en los datos que el usuario desea enviar, esto debido a que el \nsistema  de captura por medio de posici\u00f3n no es 100% preciso, a pesar de \nestos gracias a la habilidad del Kinect para crear l\u00edmites de captura, se \npuede asegurar que otros objetos no interfieran dentro del sistema.  \n \n  \n \n \n \n \n \n \n \n \n \n  80 \n 7. CONCLUSIONES  \n \n\uf0b7 El documento  presen ta el dise\u00f1o y desarrollo de un controlador MIDI no \nconvencional utilizando el Kinect, implementado en el Sistema E mbebido \nPandaboard ES. En el S.E. se implement\u00f3 la distribuci\u00f3n de Ubuntu, la cual \npermite la instalaci\u00f3n y configuraci\u00f3n de los programas y servicios con los \ncuales se realiza la transmisi\u00f3n de los datos en prot ocolo MIDI a un \ncomputador fijo adquiriendo los datos a partir de movimientos capturados \npor el Kinect.  \n \n\uf0b7 El desarrollo de la interfaz gr\u00e1fica  para la interacci\u00f3n con el usuario fue un \napoyo visual para monitorear los datos generados y capturados por el \nKinect, el Pure Data fue una herramienta esencial para presentarle al \nusuario los datos de una forma ordenada y coherente de tal forma que \npudiera interpretarlos.  \n \n\u25cf La portabilidad  de hard ware y software demuestra  de los sistemas \nembebidos son una herramienta de desarrollo eficiente , y el sistema \noperativo Ubuntu se encuentra en la capacidad de brindar las herramientas \nsuficientes para el desarrollo de nuevas tecnolog\u00edas  dentro de los Siste mas \nEmbebidos aplicados a la Ingenier\u00eda de Sonido  \n \n\u25cf La implementaci\u00f3n de herramientas tecnol\u00f3gica como los Sistemas \nEmbebidos o el Kinect, permiten el desarrollo de una gran variedad de \ndispositivos no disponibles en el mercado , adaptables a hardware o \nsoftware existente.  \n \n  81 \n 8. PRODUCTOS  \n \nA partir de la implementaci\u00f3n del proyecto se desarrollaron los siguientes \nproductos:  \nARTICULOS EN EDICION  \n\uf0b7 Desarrollo de un Controlador MIDI no Convencional, Implementado en \nun Sistema Embebido, Utilizando el Kinect.  \nEl art\u00edculo presenta el desarrollo de un controlador MIDI no convencional \nimplementado en un Sistema Embebido utilizando el Kinect. El dispositivo \npermite utilizar el protocolo MIDI para controlar hardware y/o software remoto \nv\u00eda WiFi por medio de la captura de m ovimientos. Con la utilizaci\u00f3n de este tipo \nherramientas tecnol\u00f3gicas se puede construir controladores no convencionales \naplicados a la ingenier\u00eda de sonido, integrables a diferentes redes de \ncomunicaci\u00f3n de forma pr\u00e1ctica, eficaz e innovadora.  \n\uf0b7 Controlador  MIDI WiFi Implementado en un Sistema Embebido . \nEl art\u00edculo presenta el desarrollo del proyecto de Investigaci\u00f3n, en el cual se \ndise\u00f1\u00f3 un sistema para realizar la transmisi\u00f3n por WiFi del protocolo MIDI,  el \ncual utiliza herramientas de software libre y si stemas embebidos para su \nimplementaci\u00f3n.  \n\uf0b7 Compresor de Formato de Audio Desarrollado en Pure Data, \nImplementado en un Sistema Embebido  \n \nGRUPO DE INVESTIGACI\u00d3N : Ac\u00fastica Aplicada  \nEn el grupo de investigaci\u00f3n ING 006A -028 se desarroll\u00f3 un Sistema  De \nTransmisi \u00f3n Inal\u00e1mbrica Para El Protocolo De Comunicaci\u00f3n Midi, Utilizando \nSistemas Embebidos  \nEl proyecto consiste en dise\u00f1ar un sistema para realizar la transmisi\u00f3n por WiFi \ndel protocolo MIDI, el cual utilice herramientas de software libre y sistemas \nembebidos . \n \n 82 \n 9. RECOMENDACIONES  \n \n \n\uf0b7 Crear interfaz de usuario f\u00edsica para  generar  cambio s del e nsamble de Pure \nData en de forma externa al sistema para tener un control especifico , ya \nfuera por medio de micro -controladores  o por sensores inal\u00e1mbricos.   \n \n\uf0b7 Implementar  c\u00e1maras  alternativas  al Kinect como el ASUS  Xtion PRO LIVE  \nel cual fue de desarrollado por el mismo grupo que desarrollo el Kinect, \npero fue creado espec\u00edficamente para desarrollo y no para una consola de \njuegos.  \n \n\uf0b7 Buscar Sistema Embebidos y Sistema Operativos alt ernativos que pudieran \nser \u00f3ptimos para la implementaci\u00f3n como controladores MIDI no \nconvencionales . \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n 83 \n BIBLIOGRAF\u00cdA  \n \n \n[1] Abbott, Doug. Linux for Embedded and Real -Time Application.  Newnes. 2003  \n[2] Rona, Jeffrey. The MIDI Companion:  The Ins, Outs and Throughs. Hal Leonard, \n1994  \n[3] Miles Huber, David. The MIDI Manual: A Practical Guide to MIDI in the Project \nStudio. 2012  \n[4] Camargo Bare\u00f1o, Carlos Iv\u00e1n. \" Transferencia tecnol\u00f3gica y de conocimientos \nen el dise\u00f1o de sistemas embebidos\".  Universidad Nacional de Colombia. Bogot\u00e1, \nColombia. 2011  \n[5] Milano, Dominic. Mind  Over  MIDI. H. Leonard Books. 1987  \n[6] Zhang, Zhengyou. \"Microsoft Kinect Sensor and Its Effect\" . University of \nMissouri.  Misuri, Estados  Unidos.  \n[7] Fry, Ben. Reas, Casey. Getting Started with Processing . O\u2019reilly.  \n \n[8] PrimeSense. Willow Garage.  Side-Kick.  ASUS.  AppSide.  <<OpenNI \norganization>>http://openni.org/  \n \n[9] Martin, Hector. Blake, Josh.  Machulis, Kyle. <<OpenKinect Community>> \nhttp://openkinect.org/wiki/Main_Page  \n \n[10] Gralla, Preston. C\u00f3mo funcionan las redes inal\u00e1mbricas . Anaya \nMultimedia.  2007  \n \n[11] Engst, Adam . Introducci\u00f3n a las redes inal\u00e1mbricas . Anaya Multimedia.  2005  \n[12] Varela, Carlos. Dominguez, Luis. Redes Inal\u00e1mbricas. Universidad de \nValladolid. Vallad olid, Espa\u00f1a. 2002  \n[13] Werchau, Pablo Jara. Nazar, Patricia. Est\u00e1ndar IEEE 802.11 X de las WLAN.  \nUniversidad Tecnol\u00f3gica Nacional. Buenos Aires, Argentina.  \n 84 \n [14] Capela, Rui  Nuno. QmidiNet  A MIDI Network Gateway via  UDP/IP Multicast. \nhttp://qmidinet.sourc eforge.net/qmidinet -index.html  \n[15] Dhawan, S.  Analogy of Promising Wireless Technologies on Diferent \nFrequencies: Bluetooth,  WiFi, and WiMAX , 2007.  \n \n[16] Steve Heath.  Embedded Systems Design . Second Edition.  Newnes, ,2002.  \n \n[17] P.Raghavan, Amol Lad, Srira m, Neelakandan.  Embedded Linux System \nDesingand  Development  .Auerbach  Publications, 2005.  \n \n[18] Rosas Jim\u00e9nez, Nelson Felipe. Dise\u00f1o E Implementaci\u00f3n De Un Sistema \nEmbebido Para La Adquisici\u00f3n Y Transmisi\u00f3n De Se\u00f1ales Biom\u00e9dicas A Trav\u00e9s \nDe La Red Celular . Universidad Nacional De Colombia. Bogot\u00e1, Colombia. 2011  \n \n[19] Amaro Soriano, Jos\u00e9 Enrique. Android: Programaci\u00f3n de dispositivos m\u00f3viles \na trav\u00e9s de ejemplos.  Marcombo, 2011  \n[20] Meier, Reto. Professional Android 4 Application Development.  John Wiley & \nSons, 2012  \n[21] Gargenta, Marko. Learning Android.  O'Reilly Media, Inc., 2011  \n[22] Thomas, Keir. Ubuntu Pocket Guide and Reference. Ubuntu Pocket Guide, \n2009  \n[23] Helmke , Matthew . Graner , Amber.  Rankin , Kyle.  Mako  Hill, Benjamin.  Bacon , \nJono.  The Official Ubuntu Book . Prentice Hall, 2012  \n[24] Helmke, Matthew. Ubuntu Unleashed 2012 Edition: Covering 11.10 and \n12.04. Sams Publishing, 2012  \n[25] Miller , Charlie.  Blazakis , Dion.  DaiZovi , Dino . Esser , Stefan.  Lozzo , Vincenzo.  \nWeinmann , Ralf Philip.  iOS Hacker's Handbook. John Wiley & Sons, 2012  \n[26] Ray, Deborah  S. Ray, Eric J. Unix and Linux.  Peachpit Press, 2009  \n[27] Brinkmann, peter. Making Mu sical Apps: Real -time audio synthesis on Android \nand iOS.  O'Reilly Media, Inc., 2012  \n \n[28] Rosenberg Craig, Moses Bob. Future Human Interfaces to Computer \nControlled Sound Systems . University of Washington, Seattle.  Rane  Corporation, \nMukilteo. 1993  85 \n  \n[29] Balind  Wincent, Lovis  cach  Jorn. Gestures to Operate DAW Software . \nUniversity Oldenburg, Oldenburg. Fachhochschule Bielefeld, Bielefeld. 2011  \n \n[30] Selfridge Rod, Reiss Josh. Interactive Mixing Using Wii Controller . Queen \nMary University of London . Lond res. Inglaterra.  2011  \n \n[31] Bartlett Greg. Embedded Controllers for Audio Devices . Pavo, Philadelphia.  \n1994  \n \n[32] Luke.  Kyle.  <<iFixit >>. h ttp://www.ifixit.com/Teardown/Microsoft+Kinect+  \nTeardown/4066/3  \n \n[33] Azhar.  <<How to Set Up an AdHoc Wireless Network  in Windows XP>> . \nhttp://www.sizledcore.com/2010/01/how -to-set-up-an-adhoc -wireless -network -in-\nwindows -xp/ \n \n[34] Fry, Ben.Reas, Casey.<<Processing>>. http://processing.org/  \n \n[35] Upton, Eben. Mullins,  Rob. Lang, Jack. Mycroft, Alan.  <<Raspberry Pi>>  \nhttp:// raspberrypi.org/  \n \n[36] <<Pandaboard>>http://pandaboard.org/  \n  \n[37] Kridner,  Jason. Coley, Gerald. Osier -Mixon, Jeffery.  <<Beagleboard>> \nhttp://beagleboard.org/  \n \n[38] Zhang,  Yongqiang . Zhang,  Handan  Bing.  Design of Embedded Audio and \nVideo Compression Syste m. Hebei University of Engineering . Hadan, China IEEE \nExplorer  \n[39] Yaghmour, Karim. Building Embedded Linux Systems.  O'Reilly Media, Inc., \n2003  \n[40] Maizels, Aviad . <<PrimeSense Natural Interaction>>  \nhttp://www.primesense.com  \n[41] Kamal , Raj. Embedded Systems 2E . Tata McGraw -Hill Education, 2008  \n[42] Ganssle , Jack G. Embedded Systems: World Class Design . Newnes, 2008  86 \n [43] Collins, Christopher Michael. An Evaluation o f Embedded System Behavior \nUsing  Full-System Software Emulation.  University of Maryland. California, Estados \nUnidos. 2000  \n[44] Yu, Tingting. Testing Embedded System Applications . University of Nebraska, \nLincoln , Estados Unidos. 2010  \n[45] Huang, Fay. Wang , Reen -Cheng . Arts and Technology . Springer, 2010  \n[46] Sean, Jared St. Kinect Hacks: Tips & Tools for Motion and Pattern Detection.  \nO'Reilly Media, 2012  \n[47] Helmke, Matthew - Hudson, Andrew. Ubuntu Unleashed 2012: Covering 11.10 \nand 12.04 . Sams Publishing, 2012  \n[48] Borenstein, Greg. Making Th ings See: 3D vision with Kinect, Processing, \nArduino, and MakerBot. O'Reilly Media, Inc., 2012  \n[49] Webb, Jarrett - Ashley, James. Beginning Kinect Programming with the \nMicrosoft Kinect SDK. Apress, 2012  \n[50] Kean, Sean -Hall, Jonathan -Perry, Phoenix. Meet t he Kinect: An Introduction to \nProgramming Natural User Interfaces . Apress, 2011  \n[51] Raggi, Emilio -Thomas, Keir -Van Vugt, Sander. Beginning Ubuntu Linux: Natty \nNarwhal Edition . Apress, 2011  \n[52] Nixon, Robert. Ubuntu: Up and Running: Up and Running . O'Reil ly Media, Inc., \n2010.  \n[53] Books Llc. Audio Programming Languages: Mathematica, Csound, Max, Pure \nData, Supercollider, Comparison of Audio Synthesis Environments . General Books \nLLC, 2010  \n[54] Noble, Joshua. Programming Interactivity . O'Reilly Media, Inc.,  2012  \n[55] Igoe, Tom. Making Things Talk: Practical Methods for Connecting Physical \nObjects.  O'Reilly Media, Inc., 2007  \n[56] Harke, Werner. Dom\u00f3tica para Viviendas y Edificios . Marcombo, 2010  \n[57] Huidobro Moya,  Jos\u00e9 Manuel . Mill\u00e1n Tejedor, Ram\u00f3n Jes\u00fas . Dom\u00f3tica: \nedificios inteligentes . Creaciones Copyright, 2004   87 \n [58] Shneiderman, Ben.  Plaisant, Catherine . Dise\u00f1o de interfaces de usuario: \nestrategias para una interacci\u00f3n persona -computadora efectiva . Pearson \nEducaci\u00f3n, 2005  \n[59] Raskin, Jef. The Human Int erface: New Directions for Designing Interactive \nSystems.  Addison -Wesley Professional, 2000  \n[60] Wong , Ronnie Anthony . Assessment of Open Source Business Strategies in \nthe Domain of Embedded Systems . University of Oulu. Oulu, Finlandia. 2011  \n[61] Granlund,  G\u00f6sta H. Knutsson, Hans.  Signal Processing for Computer Vision . \nSpringer, 1994  \n[62] Ngan, King Ngi. Li, Hongliang.  Video Segmentation and Its Applications . \nSpringer, 2011  \n[63] Zhang , Yu-Jin. Advances in Image And Video Segmentation . Idea Group Inc \n(IGI), 2006  \n[64] Belbachir, Ahmed Nabil. Smart Cameras.  Springer, 2009  \n[65] Bradski, Gary. Kaehler, Adrian.  Learning OpenCV: Computer Vision with the \nOpenCV Library.  O'Reilly Media, Inc., 2008  \n[66] Kisacanin , Branislav , Bhattacharyya, Shuvra S. Chai l, Sek. Embe dded \nComputer Vision.  Springer, 2008  \n[67] Hammoud, Riad I. Augmented Vision Perception in Infrared: Algorithms and \nApplied Systems . Springer, 2008  \n[68] Kisacanin, Branislav. Pavlovic, Vladimir. Huang, Thomas S. Real-Time Vision \nfor Human -Computer Interacti on. Springer, 2005  \n[69] Dietrich, Dietmar. Garn, Heinrich. Kebschull, Udo . Embedded Vision System . \nLightning Source Incorporated, 2006  \n[70] Bigun, Josef. Vision with Direction: A Systematic Introduction to Image \nProcessing and Computer Vision . Springer, 2 006  \n[71] Dal Mutto, Carlo. Zanuttigh, Pietro. Cortelazzo, Guido M. Time -of-Flight \nCameras and Microsoft Kinect\u2122.  Springer, 2012  \n[72] Fisher, R.   60 GHz WPAN Standardization within IEEE 802.15.3c . 2007  88 \n [73] Kim, Yong Soo.   Kim, Juho . Security enhanced IEEE  802.1x authentication \nmethod for WLAN mobile router.  2012  \n[74] Chung, Yun Won. Yun , Mi Young.  Kim, Yeong -Jin. An efficient Diameter -\nbased accounting scheme for wireless metropolitan area network (WMAN) . 2004  \n[75] Guo, Chuanxiong. Guo, Zihua. Zhu, Wenwu. Efficient mobility management for \nvertical handoff between WWAN and WLAN . 2003  \n[76] I -Tsun Chiang.  Performance Skills on Institutionalized Older Adults with \nWheelchairs. Grad. Inst. of Sports & Health, Nat. Changhua Univ. of Educ., \nChanghua, Taiwan, 2012  \n[77] Rakprayoon, P.  Kinect -based obstacle detection for manipulator. Fac. of Eng., \nKasetsart Univ., Bangkok, Thailand, 2011  \n[78] Machida E. Human motion tracking of mobile robot with Kinect 3D sensor. \nTokyo Metropolitan Coll. of Ind. Technol., Tokyo, Japan , 2012.  \n[79] Noonan, P.J. -Wolfson Mol.  The design and initial calibration of an optical \ntracking system using the Microsoft Kinect. Univ. of Manchester, Manchester, UK, \n2011  \n[80] Hui Li. Static Hand Gesture Recognition Based on HOG with Kinect. Intelligent  \nHuman -Machine Systems and Cybernetics (IHMSC), 2012 4th International \nConference.  Nanchang, Jiangxi,  2012  \n[81] Qiu -hong, Chen. A new embedded image info rmation processing system \ndesign. Dept. of Comput. Sci. & Eng., Henan Univ. of Urban Constr., \nPingding shan, China . 2010  \n[82] Chen Qiu -hong. A new embedded image information processing system \ndesign. Dept. of Comput. Sci. & Eng., Henan Univ. of Urban Constr., \nPingdingshan, China,2010.   \n[83] Correa, D.S.O. Mobile Robots Navigation in Indoor Environments Usi ng Kinect \nSensor. ICMC - SSC - LRM (Mobile Robots Lab.), USP - Univ. of Sao Paulo, Sao \nCarlos, Brazil, 2012  \n [84] Yihua Lou. A Multi -User Interaction System Based on Kinect and Wii Remote. \nState Key Lab. of Software Dev. Environ., Beihang Univ., Beijing, C hina, 2012.  \n  89 \n GLOSARIO  \n \nTERMINAL:  Es una forma de acceder al sistema sin utilizar la interfaz gr\u00e1fica, \nrealizar todo tipo de tareas en formato texto.  \nEXTERNAL:  Complementos de librer\u00edas  de Pure Data.  \nCOMPILACI\u00d3N:  Proceso de traducci\u00f3n de un c\u00f3digo a datos que puedan ser \nejecutados por una computadora.  \nCROSS COMPILACI\u00d3N:  Proceso de traducci\u00f3n de un c\u00f3digo de datos de un \nsistema a otro.  \nMULTICAST:  En espa\u00f1ol \"Multidifusi\u00f3n\", es el env\u00edo de la informaci\u00f3n en una red \na m\u00faltiples destinos simult\u00e1neamente.  \nCOMAND OS SHELL:  Sistemas de comandos utilizados por el sistema UNIX que \npermite administrar el sistema sin entorno gr\u00e1fico.  \nKERNEL:  o N\u00facleo,  es el encargado de conectar el hardware con el software y \ngestionar los recursos de manera adecuada.  \nROOT FILE SYSTEM (R FS): Es el conjunto de archivos fundamentales para \nejecutar  un sistema operativo.  \nS.E.:  Sistema Embebido  \nS.O.E.:  Sistema Operativo Embebido . \nFREENECT : Controlador para Kinect desarrollado por la comunidad Open Kinect  \nTOUCHOSC:  Superficie de control MIDI y OSC que utiliza el protocolo UDP para \nel env\u00edo de datos por medio de WiFi, desarrollado para Android e iOS   \nSOCKETS : Mecanismo que permite la conexi\u00f3n entre distintos procesos  \nOMAP:  Procesador multin\u00fa cleo ARM desarrollado para diferentes aplicaciones \nembeb idas, fabricado po r Texas Instruments  \nHDMI  (High -Definition Multimedia Interface ): Conector de audio y v\u00eddeo digital  \ncifrado sin compresi\u00f3n  de alta definici\u00f3n.  \nIPV4 : Cuarta versi\u00f3n del protocolo de comunicaci\u00f3n de datos digitales clasificado \nfuncionalmente  en la Capa de Red . 90 \n UDP  (User Datagram Protocol ): Protocolo basado en el intercambio de \ndatagramas  a trav\u00e9s de la red , sin necesidad de establecer previamente una \nconexi\u00f3n . \nSISTEMA DOMOTICO : Sistemas aplicados al control y la automatizaci\u00f3n \ninteligente de una vivienda, aportando servicios de gesti\u00f3n energ\u00e9tica, seguridad, \nbienestar o comunicaci\u00f3n .  91 \n ANEXO A : Fotos  e Im\u00e1genes  Complementarias  \n \n \nFig. 52  Pandaboard ES conectada remotamente a Samsung Galaxy Tab 10.1 . Fuente: \nPropia  \n \n \nFig. 53 Interfaz del editor  conexiones de red . Fuente: Propia  \n92 \n  \nFig. 54 Configuraci\u00f3n de control remoto MIDI de FL Studio.  Fuente: Propia  \n \n \n \nFig. 5 5 Conexi\u00f3n Pandaboard ES con el Kinect . Fuente: Propia  \n \n93 \n  \nFig. 56 Interfaz de usuario de TouchOSC para Samsung Galaxy Tab 10.1 . Fuente:  Propia  \n \n \n \nFig. 57 Controlador MIDI Virtual VMPK . Fuente: Propia  \n \n \n94 \n  \nFig. 5 8 Ensamble de recepci\u00f3n OSC desde la aplicaci\u00f3n TouchOSC.  Fuente: Propia  \n95 \n ANEXO B : Anexos digitales  \n \nLos siguientes archivos se encuentran en el CD  anexado al documento:  \n\uf0b7 A1. Video prueba del Controlador MIDI no Convencional . \u201cTesis.mp4 \u201d \n \n\uf0b7 A2. Videos demostrativos diferentes fases de desarrollo y productos \nrealizados en el proceso. \u201cCompresor.mp4 \u201d y \u201cControladorMidi.mp4 \u201d \n ", "language": "PDF", "image": "PDF", "pagetype": "PDF", "links": "PDF"}